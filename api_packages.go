/*
Cloud Foundry API

OpenAPI specification for the Cloud Foundry API.

API version: 3.195.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package capiclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


type PackagesAPI interface {

	/*
	V3AppsGuidPackagesGet List packages for an app

	List all packages associated with an app

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The app GUID
	@return ApiV3AppsGuidPackagesGetRequest
	*/
	V3AppsGuidPackagesGet(ctx context.Context, guid string) ApiV3AppsGuidPackagesGetRequest

	// V3AppsGuidPackagesGetExecute executes the request
	//  @return V3AppsGuidPackagesGet200Response
	V3AppsGuidPackagesGetExecute(r ApiV3AppsGuidPackagesGetRequest) (*V3AppsGuidPackagesGet200Response, *http.Response, error)

	/*
	V3PackagesGet List packages

	Retrieve a paginated list of packages the user has access to

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3PackagesGetRequest
	*/
	V3PackagesGet(ctx context.Context) ApiV3PackagesGetRequest

	// V3PackagesGetExecute executes the request
	//  @return V3AppsGuidPackagesGet200Response
	V3PackagesGetExecute(r ApiV3PackagesGetRequest) (*V3AppsGuidPackagesGet200Response, *http.Response, error)

	/*
	V3PackagesGuidCopyPost Copy a package

	Copy a package to create a new package. Useful for creating multiple builds from the same source.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The source package GUID
	@return ApiV3PackagesGuidCopyPostRequest
	*/
	V3PackagesGuidCopyPost(ctx context.Context, guid string) ApiV3PackagesGuidCopyPostRequest

	// V3PackagesGuidCopyPostExecute executes the request
	//  @return Package
	V3PackagesGuidCopyPostExecute(r ApiV3PackagesGuidCopyPostRequest) (*Package, *http.Response, error)

	/*
	V3PackagesGuidDelete Delete a package

	Delete a package. This will fail if the package is in use by a build or droplet.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The package GUID
	@return ApiV3PackagesGuidDeleteRequest
	*/
	V3PackagesGuidDelete(ctx context.Context, guid string) ApiV3PackagesGuidDeleteRequest

	// V3PackagesGuidDeleteExecute executes the request
	V3PackagesGuidDeleteExecute(r ApiV3PackagesGuidDeleteRequest) (*http.Response, error)

	/*
	V3PackagesGuidDownloadGet Download package bits

	Download the bits for a package as a zip file. Only valid for packages of type 'bits' in READY state.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The package GUID
	@return ApiV3PackagesGuidDownloadGetRequest
	*/
	V3PackagesGuidDownloadGet(ctx context.Context, guid string) ApiV3PackagesGuidDownloadGetRequest

	// V3PackagesGuidDownloadGetExecute executes the request
	//  @return *os.File
	V3PackagesGuidDownloadGetExecute(r ApiV3PackagesGuidDownloadGetRequest) (*os.File, *http.Response, error)

	/*
	V3PackagesGuidGet Get a package

	Retrieve details of a specific package

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The package GUID
	@return ApiV3PackagesGuidGetRequest
	*/
	V3PackagesGuidGet(ctx context.Context, guid string) ApiV3PackagesGuidGetRequest

	// V3PackagesGuidGetExecute executes the request
	//  @return Package
	V3PackagesGuidGetExecute(r ApiV3PackagesGuidGetRequest) (*Package, *http.Response, error)

	/*
	V3PackagesGuidPatch Update a package

	Update metadata for a package

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The package GUID
	@return ApiV3PackagesGuidPatchRequest
	*/
	V3PackagesGuidPatch(ctx context.Context, guid string) ApiV3PackagesGuidPatchRequest

	// V3PackagesGuidPatchExecute executes the request
	//  @return Package
	V3PackagesGuidPatchExecute(r ApiV3PackagesGuidPatchRequest) (*Package, *http.Response, error)

	/*
	V3PackagesGuidUploadPost Upload package bits

	Upload source code bits for a package. Only valid for packages of type 'bits'.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The package GUID
	@return ApiV3PackagesGuidUploadPostRequest
	*/
	V3PackagesGuidUploadPost(ctx context.Context, guid string) ApiV3PackagesGuidUploadPostRequest

	// V3PackagesGuidUploadPostExecute executes the request
	//  @return Package
	V3PackagesGuidUploadPostExecute(r ApiV3PackagesGuidUploadPostRequest) (*Package, *http.Response, error)

	/*
	V3PackagesPost Create a package

	Create a new package for an app. Packages contain the source code or image reference for an app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3PackagesPostRequest
	*/
	V3PackagesPost(ctx context.Context) ApiV3PackagesPostRequest

	// V3PackagesPostExecute executes the request
	//  @return Package
	V3PackagesPostExecute(r ApiV3PackagesPostRequest) (*Package, *http.Response, error)
}

// PackagesAPIService PackagesAPI service
type PackagesAPIService service

type ApiV3AppsGuidPackagesGetRequest struct {
	ctx context.Context
	ApiService PackagesAPI
	guid string
	page *int32
	perPage *int32
	orderBy *string
	states *string
	types *string
}

// Page number for pagination
func (r ApiV3AppsGuidPackagesGetRequest) Page(page int32) ApiV3AppsGuidPackagesGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3AppsGuidPackagesGetRequest) PerPage(perPage int32) ApiV3AppsGuidPackagesGetRequest {
	r.perPage = &perPage
	return r
}

// Field to sort results by
func (r ApiV3AppsGuidPackagesGetRequest) OrderBy(orderBy string) ApiV3AppsGuidPackagesGetRequest {
	r.orderBy = &orderBy
	return r
}

// Filter by package states (comma-separated)
func (r ApiV3AppsGuidPackagesGetRequest) States(states string) ApiV3AppsGuidPackagesGetRequest {
	r.states = &states
	return r
}

// Filter by package types (comma-separated)
func (r ApiV3AppsGuidPackagesGetRequest) Types(types string) ApiV3AppsGuidPackagesGetRequest {
	r.types = &types
	return r
}

func (r ApiV3AppsGuidPackagesGetRequest) Execute() (*V3AppsGuidPackagesGet200Response, *http.Response, error) {
	return r.ApiService.V3AppsGuidPackagesGetExecute(r)
}

/*
V3AppsGuidPackagesGet List packages for an app

List all packages associated with an app

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The app GUID
 @return ApiV3AppsGuidPackagesGetRequest
*/
func (a *PackagesAPIService) V3AppsGuidPackagesGet(ctx context.Context, guid string) ApiV3AppsGuidPackagesGetRequest {
	return ApiV3AppsGuidPackagesGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidPackagesGet200Response
func (a *PackagesAPIService) V3AppsGuidPackagesGetExecute(r ApiV3AppsGuidPackagesGetRequest) (*V3AppsGuidPackagesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidPackagesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesAPIService.V3AppsGuidPackagesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/packages"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.states != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "states", r.states, "form", "")
	}
	if r.types != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "types", r.types, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3PackagesGetRequest struct {
	ctx context.Context
	ApiService PackagesAPI
	page *int32
	perPage *int32
	orderBy *string
	guids *string
	states *string
	types *string
	appGuids *string
	spaceGuids *string
	organizationGuids *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

// Page number for pagination
func (r ApiV3PackagesGetRequest) Page(page int32) ApiV3PackagesGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3PackagesGetRequest) PerPage(perPage int32) ApiV3PackagesGetRequest {
	r.perPage = &perPage
	return r
}

// Field to sort results by
func (r ApiV3PackagesGetRequest) OrderBy(orderBy string) ApiV3PackagesGetRequest {
	r.orderBy = &orderBy
	return r
}

// Filter by package GUIDs (comma-separated)
func (r ApiV3PackagesGetRequest) Guids(guids string) ApiV3PackagesGetRequest {
	r.guids = &guids
	return r
}

// Filter by package states (comma-separated)
func (r ApiV3PackagesGetRequest) States(states string) ApiV3PackagesGetRequest {
	r.states = &states
	return r
}

// Filter by package types (comma-separated)
func (r ApiV3PackagesGetRequest) Types(types string) ApiV3PackagesGetRequest {
	r.types = &types
	return r
}

// Filter by app GUIDs (comma-separated)
func (r ApiV3PackagesGetRequest) AppGuids(appGuids string) ApiV3PackagesGetRequest {
	r.appGuids = &appGuids
	return r
}

// Filter by space GUIDs (comma-separated)
func (r ApiV3PackagesGetRequest) SpaceGuids(spaceGuids string) ApiV3PackagesGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

// Filter by organization GUIDs (comma-separated)
func (r ApiV3PackagesGetRequest) OrganizationGuids(organizationGuids string) ApiV3PackagesGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

// Filter by labels using label selector syntax
func (r ApiV3PackagesGetRequest) LabelSelector(labelSelector string) ApiV3PackagesGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Filter by creation timestamp range
func (r ApiV3PackagesGetRequest) CreatedAts(createdAts string) ApiV3PackagesGetRequest {
	r.createdAts = &createdAts
	return r
}

// Filter by update timestamp range
func (r ApiV3PackagesGetRequest) UpdatedAts(updatedAts string) ApiV3PackagesGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3PackagesGetRequest) Execute() (*V3AppsGuidPackagesGet200Response, *http.Response, error) {
	return r.ApiService.V3PackagesGetExecute(r)
}

/*
V3PackagesGet List packages

Retrieve a paginated list of packages the user has access to

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3PackagesGetRequest
*/
func (a *PackagesAPIService) V3PackagesGet(ctx context.Context) ApiV3PackagesGetRequest {
	return ApiV3PackagesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3AppsGuidPackagesGet200Response
func (a *PackagesAPIService) V3PackagesGetExecute(r ApiV3PackagesGetRequest) (*V3AppsGuidPackagesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidPackagesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesAPIService.V3PackagesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/packages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "")
	}
	if r.states != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "states", r.states, "form", "")
	}
	if r.types != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "types", r.types, "form", "")
	}
	if r.appGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "app_guids", r.appGuids, "form", "")
	}
	if r.spaceGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", r.spaceGuids, "form", "")
	}
	if r.organizationGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", r.organizationGuids, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3PackagesGuidCopyPostRequest struct {
	ctx context.Context
	ApiService PackagesAPI
	guid string
	v3PackagesGuidCopyPostRequest *V3PackagesGuidCopyPostRequest
}

func (r ApiV3PackagesGuidCopyPostRequest) V3PackagesGuidCopyPostRequest(v3PackagesGuidCopyPostRequest V3PackagesGuidCopyPostRequest) ApiV3PackagesGuidCopyPostRequest {
	r.v3PackagesGuidCopyPostRequest = &v3PackagesGuidCopyPostRequest
	return r
}

func (r ApiV3PackagesGuidCopyPostRequest) Execute() (*Package, *http.Response, error) {
	return r.ApiService.V3PackagesGuidCopyPostExecute(r)
}

/*
V3PackagesGuidCopyPost Copy a package

Copy a package to create a new package. Useful for creating multiple builds from the same source.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The source package GUID
 @return ApiV3PackagesGuidCopyPostRequest
*/
func (a *PackagesAPIService) V3PackagesGuidCopyPost(ctx context.Context, guid string) ApiV3PackagesGuidCopyPostRequest {
	return ApiV3PackagesGuidCopyPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Package
func (a *PackagesAPIService) V3PackagesGuidCopyPostExecute(r ApiV3PackagesGuidCopyPostRequest) (*Package, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Package
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesAPIService.V3PackagesGuidCopyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/packages/{guid}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3PackagesGuidCopyPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3PackagesGuidCopyPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3PackagesGuidCopyPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3PackagesGuidDeleteRequest struct {
	ctx context.Context
	ApiService PackagesAPI
	guid string
}

func (r ApiV3PackagesGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3PackagesGuidDeleteExecute(r)
}

/*
V3PackagesGuidDelete Delete a package

Delete a package. This will fail if the package is in use by a build or droplet.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The package GUID
 @return ApiV3PackagesGuidDeleteRequest
*/
func (a *PackagesAPIService) V3PackagesGuidDelete(ctx context.Context, guid string) ApiV3PackagesGuidDeleteRequest {
	return ApiV3PackagesGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *PackagesAPIService) V3PackagesGuidDeleteExecute(r ApiV3PackagesGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesAPIService.V3PackagesGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/packages/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3PackagesGuidDownloadGetRequest struct {
	ctx context.Context
	ApiService PackagesAPI
	guid string
}

func (r ApiV3PackagesGuidDownloadGetRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.V3PackagesGuidDownloadGetExecute(r)
}

/*
V3PackagesGuidDownloadGet Download package bits

Download the bits for a package as a zip file. Only valid for packages of type 'bits' in READY state.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The package GUID
 @return ApiV3PackagesGuidDownloadGetRequest
*/
func (a *PackagesAPIService) V3PackagesGuidDownloadGet(ctx context.Context, guid string) ApiV3PackagesGuidDownloadGetRequest {
	return ApiV3PackagesGuidDownloadGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return *os.File
func (a *PackagesAPIService) V3PackagesGuidDownloadGetExecute(r ApiV3PackagesGuidDownloadGetRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesAPIService.V3PackagesGuidDownloadGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/packages/{guid}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/zip", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3PackagesGuidGetRequest struct {
	ctx context.Context
	ApiService PackagesAPI
	guid string
}

func (r ApiV3PackagesGuidGetRequest) Execute() (*Package, *http.Response, error) {
	return r.ApiService.V3PackagesGuidGetExecute(r)
}

/*
V3PackagesGuidGet Get a package

Retrieve details of a specific package

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The package GUID
 @return ApiV3PackagesGuidGetRequest
*/
func (a *PackagesAPIService) V3PackagesGuidGet(ctx context.Context, guid string) ApiV3PackagesGuidGetRequest {
	return ApiV3PackagesGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Package
func (a *PackagesAPIService) V3PackagesGuidGetExecute(r ApiV3PackagesGuidGetRequest) (*Package, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Package
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesAPIService.V3PackagesGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/packages/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3PackagesGuidPatchRequest struct {
	ctx context.Context
	ApiService PackagesAPI
	guid string
	v3PackagesGuidPatchRequest *V3PackagesGuidPatchRequest
}

func (r ApiV3PackagesGuidPatchRequest) V3PackagesGuidPatchRequest(v3PackagesGuidPatchRequest V3PackagesGuidPatchRequest) ApiV3PackagesGuidPatchRequest {
	r.v3PackagesGuidPatchRequest = &v3PackagesGuidPatchRequest
	return r
}

func (r ApiV3PackagesGuidPatchRequest) Execute() (*Package, *http.Response, error) {
	return r.ApiService.V3PackagesGuidPatchExecute(r)
}

/*
V3PackagesGuidPatch Update a package

Update metadata for a package

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The package GUID
 @return ApiV3PackagesGuidPatchRequest
*/
func (a *PackagesAPIService) V3PackagesGuidPatch(ctx context.Context, guid string) ApiV3PackagesGuidPatchRequest {
	return ApiV3PackagesGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Package
func (a *PackagesAPIService) V3PackagesGuidPatchExecute(r ApiV3PackagesGuidPatchRequest) (*Package, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Package
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesAPIService.V3PackagesGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/packages/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3PackagesGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3PackagesGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3PackagesGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3PackagesGuidUploadPostRequest struct {
	ctx context.Context
	ApiService PackagesAPI
	guid string
	bits *os.File
	resources *string
}

// Zip file containing application source code
func (r ApiV3PackagesGuidUploadPostRequest) Bits(bits *os.File) ApiV3PackagesGuidUploadPostRequest {
	r.bits = bits
	return r
}

// Fingerprints of already-uploaded bits for resource matching
func (r ApiV3PackagesGuidUploadPostRequest) Resources(resources string) ApiV3PackagesGuidUploadPostRequest {
	r.resources = &resources
	return r
}

func (r ApiV3PackagesGuidUploadPostRequest) Execute() (*Package, *http.Response, error) {
	return r.ApiService.V3PackagesGuidUploadPostExecute(r)
}

/*
V3PackagesGuidUploadPost Upload package bits

Upload source code bits for a package. Only valid for packages of type 'bits'.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The package GUID
 @return ApiV3PackagesGuidUploadPostRequest
*/
func (a *PackagesAPIService) V3PackagesGuidUploadPost(ctx context.Context, guid string) ApiV3PackagesGuidUploadPostRequest {
	return ApiV3PackagesGuidUploadPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Package
func (a *PackagesAPIService) V3PackagesGuidUploadPostExecute(r ApiV3PackagesGuidUploadPostRequest) (*Package, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Package
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesAPIService.V3PackagesGuidUploadPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/packages/{guid}/upload"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bits == nil {
		return localVarReturnValue, nil, reportError("bits is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var bitsLocalVarFormFileName string
	var bitsLocalVarFileName     string
	var bitsLocalVarFileBytes    []byte

	bitsLocalVarFormFileName = "bits"
	bitsLocalVarFile := r.bits

	if bitsLocalVarFile != nil {
		fbs, _ := io.ReadAll(bitsLocalVarFile)

		bitsLocalVarFileBytes = fbs
		bitsLocalVarFileName = bitsLocalVarFile.Name()
		bitsLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: bitsLocalVarFileBytes, fileName: bitsLocalVarFileName, formFileName: bitsLocalVarFormFileName})
	}
	if r.resources != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "resources", r.resources, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3PackagesPostRequest struct {
	ctx context.Context
	ApiService PackagesAPI
	v3PackagesPostRequest *V3PackagesPostRequest
}

func (r ApiV3PackagesPostRequest) V3PackagesPostRequest(v3PackagesPostRequest V3PackagesPostRequest) ApiV3PackagesPostRequest {
	r.v3PackagesPostRequest = &v3PackagesPostRequest
	return r
}

func (r ApiV3PackagesPostRequest) Execute() (*Package, *http.Response, error) {
	return r.ApiService.V3PackagesPostExecute(r)
}

/*
V3PackagesPost Create a package

Create a new package for an app. Packages contain the source code or image reference for an app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3PackagesPostRequest
*/
func (a *PackagesAPIService) V3PackagesPost(ctx context.Context) ApiV3PackagesPostRequest {
	return ApiV3PackagesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Package
func (a *PackagesAPIService) V3PackagesPostExecute(r ApiV3PackagesPostRequest) (*Package, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Package
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackagesAPIService.V3PackagesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/packages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3PackagesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3PackagesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3PackagesPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
