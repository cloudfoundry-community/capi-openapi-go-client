/*
Cloud Controller API

API specification for managing environment variable groups in Cloud Controller.

API version: v3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package capiclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
	"os"
)


type DefaultAPI interface {

	/*
	ApplyOrganizationQuotaToOrganizations Apply an organization quota to organizations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param quotaGuid
	@return ApiApplyOrganizationQuotaToOrganizationsRequest
	*/
	ApplyOrganizationQuotaToOrganizations(ctx context.Context, quotaGuid string) ApiApplyOrganizationQuotaToOrganizationsRequest

	// ApplyOrganizationQuotaToOrganizationsExecute executes the request
	//  @return ApplyOrganizationQuotaToOrganizations201Response
	ApplyOrganizationQuotaToOrganizationsExecute(r ApiApplyOrganizationQuotaToOrganizationsRequest) (*ApplyOrganizationQuotaToOrganizations201Response, *http.Response, error)

	/*
	AssignDefaultIsolationSegment Assign Default Isolation Segment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiAssignDefaultIsolationSegmentRequest
	*/
	AssignDefaultIsolationSegment(ctx context.Context, guid string) ApiAssignDefaultIsolationSegmentRequest

	// AssignDefaultIsolationSegmentExecute executes the request
	//  @return map[string]interface{}
	AssignDefaultIsolationSegmentExecute(r ApiAssignDefaultIsolationSegmentRequest) (map[string]interface{}, *http.Response, error)

	/*
	CreateOrganization Create an Organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateOrganizationRequest
	*/
	CreateOrganization(ctx context.Context) ApiCreateOrganizationRequest

	// CreateOrganizationExecute executes the request
	//  @return Organization
	CreateOrganizationExecute(r ApiCreateOrganizationRequest) (*Organization, *http.Response, error)

	/*
	CreateOrganizationQuota Create an organization quota

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateOrganizationQuotaRequest
	*/
	CreateOrganizationQuota(ctx context.Context) ApiCreateOrganizationQuotaRequest

	// CreateOrganizationQuotaExecute executes the request
	//  @return OrganizationQuota
	CreateOrganizationQuotaExecute(r ApiCreateOrganizationQuotaRequest) (*OrganizationQuota, *http.Response, error)

	/*
	DeleteOrganization Delete an Organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiDeleteOrganizationRequest
	*/
	DeleteOrganization(ctx context.Context, guid string) ApiDeleteOrganizationRequest

	// DeleteOrganizationExecute executes the request
	//  @return map[string]interface{}
	DeleteOrganizationExecute(r ApiDeleteOrganizationRequest) (map[string]interface{}, *http.Response, error)

	/*
	DeleteOrganizationQuota Delete an organization quota

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiDeleteOrganizationQuotaRequest
	*/
	DeleteOrganizationQuota(ctx context.Context, guid string) ApiDeleteOrganizationQuotaRequest

	// DeleteOrganizationQuotaExecute executes the request
	//  @return DeleteOrganizationQuota202Response
	DeleteOrganizationQuotaExecute(r ApiDeleteOrganizationQuotaRequest) (*DeleteOrganizationQuota202Response, *http.Response, error)

	/*
	GetDefaultDomain Get Default Domain

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiGetDefaultDomainRequest
	*/
	GetDefaultDomain(ctx context.Context, guid string) ApiGetDefaultDomainRequest

	// GetDefaultDomainExecute executes the request
	//  @return map[string]interface{}
	GetDefaultDomainExecute(r ApiGetDefaultDomainRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetDefaultIsolationSegment Get Default Isolation Segment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiGetDefaultIsolationSegmentRequest
	*/
	GetDefaultIsolationSegment(ctx context.Context, guid string) ApiGetDefaultIsolationSegmentRequest

	// GetDefaultIsolationSegmentExecute executes the request
	//  @return map[string]interface{}
	GetDefaultIsolationSegmentExecute(r ApiGetDefaultIsolationSegmentRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetOrganization Get an Organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiGetOrganizationRequest
	*/
	GetOrganization(ctx context.Context, guid string) ApiGetOrganizationRequest

	// GetOrganizationExecute executes the request
	//  @return Organization
	GetOrganizationExecute(r ApiGetOrganizationRequest) (*Organization, *http.Response, error)

	/*
	GetOrganizationQuota Get an organization quota

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiGetOrganizationQuotaRequest
	*/
	GetOrganizationQuota(ctx context.Context, guid string) ApiGetOrganizationQuotaRequest

	// GetOrganizationQuotaExecute executes the request
	//  @return OrganizationQuota
	GetOrganizationQuotaExecute(r ApiGetOrganizationQuotaRequest) (*OrganizationQuota, *http.Response, error)

	/*
	GetUsageSummary Get Usage Summary

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiGetUsageSummaryRequest
	*/
	GetUsageSummary(ctx context.Context, guid string) ApiGetUsageSummaryRequest

	// GetUsageSummaryExecute executes the request
	//  @return map[string]interface{}
	GetUsageSummaryExecute(r ApiGetUsageSummaryRequest) (map[string]interface{}, *http.Response, error)

	/*
	ListOrganizationQuotas List organization quotas

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListOrganizationQuotasRequest
	*/
	ListOrganizationQuotas(ctx context.Context) ApiListOrganizationQuotasRequest

	// ListOrganizationQuotasExecute executes the request
	//  @return ListOrganizationQuotas200Response
	ListOrganizationQuotasExecute(r ApiListOrganizationQuotasRequest) (*ListOrganizationQuotas200Response, *http.Response, error)

	/*
	ListOrganizations List Organizations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListOrganizationsRequest
	*/
	ListOrganizations(ctx context.Context) ApiListOrganizationsRequest

	// ListOrganizationsExecute executes the request
	//  @return []Organization
	ListOrganizationsExecute(r ApiListOrganizationsRequest) ([]Organization, *http.Response, error)

	/*
	ListUsersForOrganization List Users for an Organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiListUsersForOrganizationRequest
	*/
	ListUsersForOrganization(ctx context.Context, guid string) ApiListUsersForOrganizationRequest

	// ListUsersForOrganizationExecute executes the request
	//  @return []User
	ListUsersForOrganizationExecute(r ApiListUsersForOrganizationRequest) ([]User, *http.Response, error)

	/*
	RootGet Global API Root

	Returns links to the APIs available on a given Cloud Foundry deployment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRootGetRequest
	*/
	RootGet(ctx context.Context) ApiRootGetRequest

	// RootGetExecute executes the request
	//  @return Get200Response
	RootGetExecute(r ApiRootGetRequest) (*Get200Response, *http.Response, error)

	/*
	UpdateOrganization Update an Organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiUpdateOrganizationRequest
	*/
	UpdateOrganization(ctx context.Context, guid string) ApiUpdateOrganizationRequest

	// UpdateOrganizationExecute executes the request
	//  @return Organization
	UpdateOrganizationExecute(r ApiUpdateOrganizationRequest) (*Organization, *http.Response, error)

	/*
	UpdateOrganizationQuota Update an organization quota

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiUpdateOrganizationQuotaRequest
	*/
	UpdateOrganizationQuota(ctx context.Context, guid string) ApiUpdateOrganizationQuotaRequest

	// UpdateOrganizationQuotaExecute executes the request
	//  @return OrganizationQuota
	UpdateOrganizationQuotaExecute(r ApiUpdateOrganizationQuotaRequest) (*OrganizationQuota, *http.Response, error)

	/*
	V3AdminActionsClearBuildpackCachePost Clear buildpack cache

	This endpoint will delete all of the existing buildpack caches in the blobstore.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3AdminActionsClearBuildpackCachePostRequest
	*/
	V3AdminActionsClearBuildpackCachePost(ctx context.Context) ApiV3AdminActionsClearBuildpackCachePostRequest

	// V3AdminActionsClearBuildpackCachePostExecute executes the request
	V3AdminActionsClearBuildpackCachePostExecute(r ApiV3AdminActionsClearBuildpackCachePostRequest) (*http.Response, error)

	/*
	V3AppsGet List apps

	Retrieve a list of all apps.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3AppsGetRequest
	*/
	V3AppsGet(ctx context.Context) ApiV3AppsGetRequest

	// V3AppsGetExecute executes the request
	//  @return App
	V3AppsGetExecute(r ApiV3AppsGetRequest) (*App, *http.Response, error)

	/*
	V3AppsGuidActionsClearBuildpackCachePost Clear buildpack cache for application

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3AppsGuidActionsClearBuildpackCachePostRequest
	*/
	V3AppsGuidActionsClearBuildpackCachePost(ctx context.Context, guid string) ApiV3AppsGuidActionsClearBuildpackCachePostRequest

	// V3AppsGuidActionsClearBuildpackCachePostExecute executes the request
	V3AppsGuidActionsClearBuildpackCachePostExecute(r ApiV3AppsGuidActionsClearBuildpackCachePostRequest) (*http.Response, error)

	/*
	V3AppsGuidActionsRestartPost Restart an app

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3AppsGuidActionsRestartPostRequest
	*/
	V3AppsGuidActionsRestartPost(ctx context.Context, guid string) ApiV3AppsGuidActionsRestartPostRequest

	// V3AppsGuidActionsRestartPostExecute executes the request
	//  @return V3AppsGuidActionsRestartPost200Response
	V3AppsGuidActionsRestartPostExecute(r ApiV3AppsGuidActionsRestartPostRequest) (*V3AppsGuidActionsRestartPost200Response, *http.Response, error)

	/*
	V3AppsGuidActionsStartPost Start an app

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3AppsGuidActionsStartPostRequest
	*/
	V3AppsGuidActionsStartPost(ctx context.Context, guid string) ApiV3AppsGuidActionsStartPostRequest

	// V3AppsGuidActionsStartPostExecute executes the request
	//  @return V3AppsGuidActionsRestartPost200Response
	V3AppsGuidActionsStartPostExecute(r ApiV3AppsGuidActionsStartPostRequest) (*V3AppsGuidActionsRestartPost200Response, *http.Response, error)

	/*
	V3AppsGuidActionsStopPost Stop an app

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3AppsGuidActionsStopPostRequest
	*/
	V3AppsGuidActionsStopPost(ctx context.Context, guid string) ApiV3AppsGuidActionsStopPostRequest

	// V3AppsGuidActionsStopPostExecute executes the request
	//  @return V3AppsGuidActionsRestartPost200Response
	V3AppsGuidActionsStopPostExecute(r ApiV3AppsGuidActionsStopPostRequest) (*V3AppsGuidActionsRestartPost200Response, *http.Response, error)

	/*
	V3AppsGuidBuildsGet List builds for an app

	Retrieve all builds for the app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the app.
	@return ApiV3AppsGuidBuildsGetRequest
	*/
	V3AppsGuidBuildsGet(ctx context.Context, guid string) ApiV3AppsGuidBuildsGetRequest

	// V3AppsGuidBuildsGetExecute executes the request
	V3AppsGuidBuildsGetExecute(r ApiV3AppsGuidBuildsGetRequest) (*http.Response, error)

	/*
	V3AppsGuidDelete Delete an app

	Delete the specified app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the app.
	@return ApiV3AppsGuidDeleteRequest
	*/
	V3AppsGuidDelete(ctx context.Context, guid string) ApiV3AppsGuidDeleteRequest

	// V3AppsGuidDeleteExecute executes the request
	V3AppsGuidDeleteExecute(r ApiV3AppsGuidDeleteRequest) (*http.Response, error)

	/*
	V3AppsGuidDropletsCurrentGet Get current droplet

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3AppsGuidDropletsCurrentGetRequest
	*/
	V3AppsGuidDropletsCurrentGet(ctx context.Context, guid string) ApiV3AppsGuidDropletsCurrentGetRequest

	// V3AppsGuidDropletsCurrentGetExecute executes the request
	//  @return V3AppsGuidDropletsCurrentGet200Response
	V3AppsGuidDropletsCurrentGetExecute(r ApiV3AppsGuidDropletsCurrentGetRequest) (*V3AppsGuidDropletsCurrentGet200Response, *http.Response, error)

	/*
	V3AppsGuidDropletsGet List droplets for an app

	Retrieve a list of droplets belonging to an app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the app
	@return ApiV3AppsGuidDropletsGetRequest
	*/
	V3AppsGuidDropletsGet(ctx context.Context, guid string) ApiV3AppsGuidDropletsGetRequest

	// V3AppsGuidDropletsGetExecute executes the request
	//  @return V3AppsGuidDropletsGet200Response
	V3AppsGuidDropletsGetExecute(r ApiV3AppsGuidDropletsGetRequest) (*V3AppsGuidDropletsGet200Response, *http.Response, error)

	/*
	V3AppsGuidEnvGet Get environment for an app

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3AppsGuidEnvGetRequest
	*/
	V3AppsGuidEnvGet(ctx context.Context, guid string) ApiV3AppsGuidEnvGetRequest

	// V3AppsGuidEnvGetExecute executes the request
	//  @return V3AppsGuidEnvGet200Response
	V3AppsGuidEnvGetExecute(r ApiV3AppsGuidEnvGetRequest) (*V3AppsGuidEnvGet200Response, *http.Response, error)

	/*
	V3AppsGuidEnvironmentVariablesGet Get environment variables for an app

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3AppsGuidEnvironmentVariablesGetRequest
	*/
	V3AppsGuidEnvironmentVariablesGet(ctx context.Context, guid string) ApiV3AppsGuidEnvironmentVariablesGetRequest

	// V3AppsGuidEnvironmentVariablesGetExecute executes the request
	//  @return V3AppsGuidEnvironmentVariablesGet200Response
	V3AppsGuidEnvironmentVariablesGetExecute(r ApiV3AppsGuidEnvironmentVariablesGetRequest) (*V3AppsGuidEnvironmentVariablesGet200Response, *http.Response, error)

	/*
	V3AppsGuidEnvironmentVariablesPatch Update environment variables for an app

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3AppsGuidEnvironmentVariablesPatchRequest
	*/
	V3AppsGuidEnvironmentVariablesPatch(ctx context.Context, guid string) ApiV3AppsGuidEnvironmentVariablesPatchRequest

	// V3AppsGuidEnvironmentVariablesPatchExecute executes the request
	//  @return V3AppsGuidEnvironmentVariablesGet200Response
	V3AppsGuidEnvironmentVariablesPatchExecute(r ApiV3AppsGuidEnvironmentVariablesPatchRequest) (*V3AppsGuidEnvironmentVariablesGet200Response, *http.Response, error)

	/*
	V3AppsGuidFeaturesGet List app features

	Retrieves the list of features for the specified app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the app.
	@return ApiV3AppsGuidFeaturesGetRequest
	*/
	V3AppsGuidFeaturesGet(ctx context.Context, guid string) ApiV3AppsGuidFeaturesGetRequest

	// V3AppsGuidFeaturesGetExecute executes the request
	V3AppsGuidFeaturesGetExecute(r ApiV3AppsGuidFeaturesGetRequest) (*http.Response, error)

	/*
	V3AppsGuidFeaturesNameGet Get an app feature

	Retrieves a specific feature for the specified app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the app.
	@param name The name of the feature.
	@return ApiV3AppsGuidFeaturesNameGetRequest
	*/
	V3AppsGuidFeaturesNameGet(ctx context.Context, guid string, name string) ApiV3AppsGuidFeaturesNameGetRequest

	// V3AppsGuidFeaturesNameGetExecute executes the request
	V3AppsGuidFeaturesNameGetExecute(r ApiV3AppsGuidFeaturesNameGetRequest) (*http.Response, error)

	/*
	V3AppsGuidFeaturesNamePatch Update an app feature

	Updates a specific feature for the specified app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the app.
	@param name The name of the feature.
	@return ApiV3AppsGuidFeaturesNamePatchRequest
	*/
	V3AppsGuidFeaturesNamePatch(ctx context.Context, guid string, name string) ApiV3AppsGuidFeaturesNamePatchRequest

	// V3AppsGuidFeaturesNamePatchExecute executes the request
	V3AppsGuidFeaturesNamePatchExecute(r ApiV3AppsGuidFeaturesNamePatchRequest) (*http.Response, error)

	/*
	V3AppsGuidGet Retrieve a specific app

	Retrieve a specific app by its GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the app.
	@return ApiV3AppsGuidGetRequest
	*/
	V3AppsGuidGet(ctx context.Context, guid string) ApiV3AppsGuidGetRequest

	// V3AppsGuidGetExecute executes the request
	//  @return App
	V3AppsGuidGetExecute(r ApiV3AppsGuidGetRequest) (*App, *http.Response, error)

	/*
	V3AppsGuidPatch Update an app

	Update an existing app by its GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the app.
	@return ApiV3AppsGuidPatchRequest
	*/
	V3AppsGuidPatch(ctx context.Context, guid string) ApiV3AppsGuidPatchRequest

	// V3AppsGuidPatchExecute executes the request
	//  @return App
	V3AppsGuidPatchExecute(r ApiV3AppsGuidPatchRequest) (*App, *http.Response, error)

	/*
	V3AppsGuidPermissionsGet Get permissions for an app

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3AppsGuidPermissionsGetRequest
	*/
	V3AppsGuidPermissionsGet(ctx context.Context, guid string) ApiV3AppsGuidPermissionsGetRequest

	// V3AppsGuidPermissionsGetExecute executes the request
	//  @return V3AppsGuidPermissionsGet200Response
	V3AppsGuidPermissionsGetExecute(r ApiV3AppsGuidPermissionsGetRequest) (*V3AppsGuidPermissionsGet200Response, *http.Response, error)

	/*
	V3AppsGuidProcessesGet List processes for app

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3AppsGuidProcessesGetRequest
	*/
	V3AppsGuidProcessesGet(ctx context.Context, guid string) ApiV3AppsGuidProcessesGetRequest

	// V3AppsGuidProcessesGetExecute executes the request
	//  @return ProcessList
	V3AppsGuidProcessesGetExecute(r ApiV3AppsGuidProcessesGetRequest) (*ProcessList, *http.Response, error)

	/*
	V3AppsGuidRelationshipsCurrentDropletGet Get current droplet association for an app

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3AppsGuidRelationshipsCurrentDropletGetRequest
	*/
	V3AppsGuidRelationshipsCurrentDropletGet(ctx context.Context, guid string) ApiV3AppsGuidRelationshipsCurrentDropletGetRequest

	// V3AppsGuidRelationshipsCurrentDropletGetExecute executes the request
	//  @return V3AppsGuidRelationshipsCurrentDropletGet200Response
	V3AppsGuidRelationshipsCurrentDropletGetExecute(r ApiV3AppsGuidRelationshipsCurrentDropletGetRequest) (*V3AppsGuidRelationshipsCurrentDropletGet200Response, *http.Response, error)

	/*
	V3AppsGuidRevisionsDeployedGet List deployed revisions for an app

	Retrieve deployed revisions for an app the user has access to. Deployed revisions are revisions that are linked to started processes in the app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid Unique identifier for the app
	@return ApiV3AppsGuidRevisionsDeployedGetRequest
	*/
	V3AppsGuidRevisionsDeployedGet(ctx context.Context, guid string) ApiV3AppsGuidRevisionsDeployedGetRequest

	// V3AppsGuidRevisionsDeployedGetExecute executes the request
	//  @return RevisionsList
	V3AppsGuidRevisionsDeployedGetExecute(r ApiV3AppsGuidRevisionsDeployedGetRequest) (*RevisionsList, *http.Response, error)

	/*
	V3AppsGuidRevisionsGet List revisions for an app

	Retrieve revisions for an app the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid Unique identifier for the app
	@return ApiV3AppsGuidRevisionsGetRequest
	*/
	V3AppsGuidRevisionsGet(ctx context.Context, guid string) ApiV3AppsGuidRevisionsGetRequest

	// V3AppsGuidRevisionsGetExecute executes the request
	//  @return RevisionsList
	V3AppsGuidRevisionsGetExecute(r ApiV3AppsGuidRevisionsGetRequest) (*RevisionsList, *http.Response, error)

	/*
	V3AppsGuidRoutesGet Retrieve all routes for an app

	Retrieve all routes that have destinations that point to the given app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The app GUID
	@return ApiV3AppsGuidRoutesGetRequest
	*/
	V3AppsGuidRoutesGet(ctx context.Context, guid string) ApiV3AppsGuidRoutesGetRequest

	// V3AppsGuidRoutesGetExecute executes the request
	//  @return RouteList
	V3AppsGuidRoutesGetExecute(r ApiV3AppsGuidRoutesGetRequest) (*RouteList, *http.Response, error)

	/*
	V3AppsGuidSidecarsGet List sidecars for an app

	Retrieves all sidecars associated with an app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3AppsGuidSidecarsGetRequest
	*/
	V3AppsGuidSidecarsGet(ctx context.Context, guid string) ApiV3AppsGuidSidecarsGetRequest

	// V3AppsGuidSidecarsGetExecute executes the request
	//  @return V3AppsGuidSidecarsGet200Response
	V3AppsGuidSidecarsGetExecute(r ApiV3AppsGuidSidecarsGetRequest) (*V3AppsGuidSidecarsGet200Response, *http.Response, error)

	/*
	V3AppsGuidSidecarsPost Create a sidecar associated with an app

	Creates a sidecar associated with an app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3AppsGuidSidecarsPostRequest
	*/
	V3AppsGuidSidecarsPost(ctx context.Context, guid string) ApiV3AppsGuidSidecarsPostRequest

	// V3AppsGuidSidecarsPostExecute executes the request
	//  @return Sidecar
	V3AppsGuidSidecarsPostExecute(r ApiV3AppsGuidSidecarsPostRequest) (*Sidecar, *http.Response, error)

	/*
	V3AppsGuidSshEnabledGet Get SSH enabled for an app

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3AppsGuidSshEnabledGetRequest
	*/
	V3AppsGuidSshEnabledGet(ctx context.Context, guid string) ApiV3AppsGuidSshEnabledGetRequest

	// V3AppsGuidSshEnabledGetExecute executes the request
	//  @return V3AppsGuidSshEnabledGet200Response
	V3AppsGuidSshEnabledGetExecute(r ApiV3AppsGuidSshEnabledGetRequest) (*V3AppsGuidSshEnabledGet200Response, *http.Response, error)

	/*
	V3AppsGuidTasksPost Create a task

	Create a new task for an app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3AppsGuidTasksPostRequest
	*/
	V3AppsGuidTasksPost(ctx context.Context, guid string) ApiV3AppsGuidTasksPostRequest

	// V3AppsGuidTasksPostExecute executes the request
	//  @return Task
	V3AppsGuidTasksPostExecute(r ApiV3AppsGuidTasksPostRequest) (*Task, *http.Response, error)

	/*
	V3AppsPost Create an app

	Create a new app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3AppsPostRequest
	*/
	V3AppsPost(ctx context.Context) ApiV3AppsPostRequest

	// V3AppsPostExecute executes the request
	//  @return App
	V3AppsPostExecute(r ApiV3AppsPostRequest) (*App, *http.Response, error)

	/*
	V3BuildpacksGet List buildpacks

	Retrieve a list of all buildpacks.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3BuildpacksGetRequest
	*/
	V3BuildpacksGet(ctx context.Context) ApiV3BuildpacksGetRequest

	// V3BuildpacksGetExecute executes the request
	V3BuildpacksGetExecute(r ApiV3BuildpacksGetRequest) (*http.Response, error)

	/*
	V3BuildpacksGuidPatch Update a buildpack

	Update an existing buildpack.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the buildpack.
	@return ApiV3BuildpacksGuidPatchRequest
	*/
	V3BuildpacksGuidPatch(ctx context.Context, guid string) ApiV3BuildpacksGuidPatchRequest

	// V3BuildpacksGuidPatchExecute executes the request
	V3BuildpacksGuidPatchExecute(r ApiV3BuildpacksGuidPatchRequest) (*http.Response, error)

	/*
	V3BuildpacksGuidUploadPost Upload buildpack bits

	Upload a zip file containing a Cloud Foundry compatible buildpack.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the buildpack.
	@return ApiV3BuildpacksGuidUploadPostRequest
	*/
	V3BuildpacksGuidUploadPost(ctx context.Context, guid string) ApiV3BuildpacksGuidUploadPostRequest

	// V3BuildpacksGuidUploadPostExecute executes the request
	V3BuildpacksGuidUploadPostExecute(r ApiV3BuildpacksGuidUploadPostRequest) (*http.Response, error)

	/*
	V3BuildpacksPost Create a buildpack

	Create a new buildpack.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3BuildpacksPostRequest
	*/
	V3BuildpacksPost(ctx context.Context) ApiV3BuildpacksPostRequest

	// V3BuildpacksPostExecute executes the request
	V3BuildpacksPostExecute(r ApiV3BuildpacksPostRequest) (*http.Response, error)

	/*
	V3BuildsGet List builds

	Retrieve a list of all builds.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3BuildsGetRequest
	*/
	V3BuildsGet(ctx context.Context) ApiV3BuildsGetRequest

	// V3BuildsGetExecute executes the request
	V3BuildsGetExecute(r ApiV3BuildsGetRequest) (*http.Response, error)

	/*
	V3BuildsGuidPatch Update a build

	Update an existing build.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the build.
	@return ApiV3BuildsGuidPatchRequest
	*/
	V3BuildsGuidPatch(ctx context.Context, guid string) ApiV3BuildsGuidPatchRequest

	// V3BuildsGuidPatchExecute executes the request
	V3BuildsGuidPatchExecute(r ApiV3BuildsGuidPatchRequest) (*http.Response, error)

	/*
	V3BuildsPost Create a build

	Create a new build.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3BuildsPostRequest
	*/
	V3BuildsPost(ctx context.Context) ApiV3BuildsPostRequest

	// V3BuildsPostExecute executes the request
	V3BuildsPostExecute(r ApiV3BuildsPostRequest) (*http.Response, error)

	/*
	V3DeploymentsGet List deployments

	Retrieve a list of all deployments.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3DeploymentsGetRequest
	*/
	V3DeploymentsGet(ctx context.Context) ApiV3DeploymentsGetRequest

	// V3DeploymentsGetExecute executes the request
	V3DeploymentsGetExecute(r ApiV3DeploymentsGetRequest) (*http.Response, error)

	/*
	V3DeploymentsGuidActionsCancelPost Cancel a deployment

	Cancel an ongoing deployment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the deployment.
	@return ApiV3DeploymentsGuidActionsCancelPostRequest
	*/
	V3DeploymentsGuidActionsCancelPost(ctx context.Context, guid string) ApiV3DeploymentsGuidActionsCancelPostRequest

	// V3DeploymentsGuidActionsCancelPostExecute executes the request
	V3DeploymentsGuidActionsCancelPostExecute(r ApiV3DeploymentsGuidActionsCancelPostRequest) (*http.Response, error)

	/*
	V3DeploymentsGuidActionsContinuePost Continue a deployment

	Continue a paused deployment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the deployment.
	@return ApiV3DeploymentsGuidActionsContinuePostRequest
	*/
	V3DeploymentsGuidActionsContinuePost(ctx context.Context, guid string) ApiV3DeploymentsGuidActionsContinuePostRequest

	// V3DeploymentsGuidActionsContinuePostExecute executes the request
	V3DeploymentsGuidActionsContinuePostExecute(r ApiV3DeploymentsGuidActionsContinuePostRequest) (*http.Response, error)

	/*
	V3DeploymentsGuidGet Get a deployment

	Retrieve a deployment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the deployment.
	@return ApiV3DeploymentsGuidGetRequest
	*/
	V3DeploymentsGuidGet(ctx context.Context, guid string) ApiV3DeploymentsGuidGetRequest

	// V3DeploymentsGuidGetExecute executes the request
	V3DeploymentsGuidGetExecute(r ApiV3DeploymentsGuidGetRequest) (*http.Response, error)

	/*
	V3DeploymentsPost Create a deployment

	Create a new deployment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3DeploymentsPostRequest
	*/
	V3DeploymentsPost(ctx context.Context) ApiV3DeploymentsPostRequest

	// V3DeploymentsPostExecute executes the request
	V3DeploymentsPostExecute(r ApiV3DeploymentsPostRequest) (*http.Response, error)

	/*
	V3DropletsGet List droplets

	Retrieve all droplets the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3DropletsGetRequest
	*/
	V3DropletsGet(ctx context.Context) ApiV3DropletsGetRequest

	// V3DropletsGetExecute executes the request
	//  @return V3AppsGuidDropletsGet200Response
	V3DropletsGetExecute(r ApiV3DropletsGetRequest) (*V3AppsGuidDropletsGet200Response, *http.Response, error)

	/*
	V3DropletsGuidGet Get a droplet

	Retrieve a specific droplet.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the droplet
	@return ApiV3DropletsGuidGetRequest
	*/
	V3DropletsGuidGet(ctx context.Context, guid string) ApiV3DropletsGuidGetRequest

	// V3DropletsGuidGetExecute executes the request
	//  @return Droplet
	V3DropletsGuidGetExecute(r ApiV3DropletsGuidGetRequest) (*Droplet, *http.Response, error)

	/*
	V3DropletsPost Create a droplet

	Create a droplet without a package.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3DropletsPostRequest
	*/
	V3DropletsPost(ctx context.Context) ApiV3DropletsPostRequest

	// V3DropletsPostExecute executes the request
	//  @return Droplet
	V3DropletsPostExecute(r ApiV3DropletsPostRequest) (*Droplet, *http.Response, error)

	/*
	V3EnvironmentVariableGroupsNameGet Get an environment variable group

	Retrieve a specific environment variable group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name The name of the environment variable group (running or staging)
	@return ApiV3EnvironmentVariableGroupsNameGetRequest
	*/
	V3EnvironmentVariableGroupsNameGet(ctx context.Context, name string) ApiV3EnvironmentVariableGroupsNameGetRequest

	// V3EnvironmentVariableGroupsNameGetExecute executes the request
	//  @return EnvironmentVariableGroup
	V3EnvironmentVariableGroupsNameGetExecute(r ApiV3EnvironmentVariableGroupsNameGetRequest) (*EnvironmentVariableGroup, *http.Response, error)

	/*
	V3EnvironmentVariableGroupsNamePatch Update environment variable group

	Update the environment variable group. The variables given in the request will be merged with the existing environment variable group. Any requested variables with a value of null will be removed from the group. Environment variable names may not start with VCAP_. PORT is not a valid environment variable.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name The name of the environment variable group (running or staging)
	@return ApiV3EnvironmentVariableGroupsNamePatchRequest
	*/
	V3EnvironmentVariableGroupsNamePatch(ctx context.Context, name string) ApiV3EnvironmentVariableGroupsNamePatchRequest

	// V3EnvironmentVariableGroupsNamePatchExecute executes the request
	//  @return EnvironmentVariableGroup
	V3EnvironmentVariableGroupsNamePatchExecute(r ApiV3EnvironmentVariableGroupsNamePatchRequest) (*EnvironmentVariableGroup, *http.Response, error)

	/*
	V3FeatureFlagsGet List feature flags

	Retrieve all feature flags.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3FeatureFlagsGetRequest
	*/
	V3FeatureFlagsGet(ctx context.Context) ApiV3FeatureFlagsGetRequest

	// V3FeatureFlagsGetExecute executes the request
	//  @return V3FeatureFlagsGet200Response
	V3FeatureFlagsGetExecute(r ApiV3FeatureFlagsGetRequest) (*V3FeatureFlagsGet200Response, *http.Response, error)

	/*
	V3FeatureFlagsNameGet Get a feature flag

	Retrieve a specific feature flag.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name The name of the feature flag
	@return ApiV3FeatureFlagsNameGetRequest
	*/
	V3FeatureFlagsNameGet(ctx context.Context, name string) ApiV3FeatureFlagsNameGetRequest

	// V3FeatureFlagsNameGetExecute executes the request
	//  @return FeatureFlag
	V3FeatureFlagsNameGetExecute(r ApiV3FeatureFlagsNameGetRequest) (*FeatureFlag, *http.Response, error)

	/*
	V3FeatureFlagsNamePatch Update a feature flag

	Update the status or custom error message of a feature flag.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name The name of the feature flag
	@return ApiV3FeatureFlagsNamePatchRequest
	*/
	V3FeatureFlagsNamePatch(ctx context.Context, name string) ApiV3FeatureFlagsNamePatchRequest

	// V3FeatureFlagsNamePatchExecute executes the request
	//  @return FeatureFlag
	V3FeatureFlagsNamePatchExecute(r ApiV3FeatureFlagsNamePatchRequest) (*FeatureFlag, *http.Response, error)

	/*
	V3Get V3 API Root

	Returns links to all the resources available on the v3 API.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3GetRequest
	*/
	V3Get(ctx context.Context) ApiV3GetRequest

	// V3GetExecute executes the request
	//  @return V3Get200Response
	V3GetExecute(r ApiV3GetRequest) (*V3Get200Response, *http.Response, error)

	/*
	V3InfoGet Get platform info

	Retrieve Cloud Controller configuration information.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3InfoGetRequest
	*/
	V3InfoGet(ctx context.Context) ApiV3InfoGetRequest

	// V3InfoGetExecute executes the request
	//  @return PlatformInfo
	V3InfoGetExecute(r ApiV3InfoGetRequest) (*PlatformInfo, *http.Response, error)

	/*
	V3InfoUsageSummaryGet Get platform usage summary

	Retrieve a high-level summary of usage across the entire Cloud Foundry installation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3InfoUsageSummaryGetRequest
	*/
	V3InfoUsageSummaryGet(ctx context.Context) ApiV3InfoUsageSummaryGetRequest

	// V3InfoUsageSummaryGetExecute executes the request
	//  @return UsageSummary
	V3InfoUsageSummaryGetExecute(r ApiV3InfoUsageSummaryGetRequest) (*UsageSummary, *http.Response, error)

	/*
	V3IsolationSegmentsGet List isolation segments

	Retrieve all isolation segments to which the user has access.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3IsolationSegmentsGetRequest
	*/
	V3IsolationSegmentsGet(ctx context.Context) ApiV3IsolationSegmentsGetRequest

	// V3IsolationSegmentsGetExecute executes the request
	//  @return V3IsolationSegmentsGet200Response
	V3IsolationSegmentsGetExecute(r ApiV3IsolationSegmentsGetRequest) (*V3IsolationSegmentsGet200Response, *http.Response, error)

	/*
	V3IsolationSegmentsGuidDelete Delete an isolation segment

	Delete an isolation segment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the isolation segment
	@return ApiV3IsolationSegmentsGuidDeleteRequest
	*/
	V3IsolationSegmentsGuidDelete(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidDeleteRequest

	// V3IsolationSegmentsGuidDeleteExecute executes the request
	V3IsolationSegmentsGuidDeleteExecute(r ApiV3IsolationSegmentsGuidDeleteRequest) (*http.Response, error)

	/*
	V3IsolationSegmentsGuidGet Get an isolation segment

	Retrieve an isolation segment to which the user has access.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the isolation segment
	@return ApiV3IsolationSegmentsGuidGetRequest
	*/
	V3IsolationSegmentsGuidGet(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidGetRequest

	// V3IsolationSegmentsGuidGetExecute executes the request
	//  @return IsolationSegment
	V3IsolationSegmentsGuidGetExecute(r ApiV3IsolationSegmentsGuidGetRequest) (*IsolationSegment, *http.Response, error)

	/*
	V3IsolationSegmentsGuidPatch Update an isolation segment

	Update the name or metadata of an isolation segment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the isolation segment
	@return ApiV3IsolationSegmentsGuidPatchRequest
	*/
	V3IsolationSegmentsGuidPatch(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidPatchRequest

	// V3IsolationSegmentsGuidPatchExecute executes the request
	//  @return IsolationSegment
	V3IsolationSegmentsGuidPatchExecute(r ApiV3IsolationSegmentsGuidPatchRequest) (*IsolationSegment, *http.Response, error)

	/*
	V3IsolationSegmentsGuidRelationshipsOrganizationsGet List organizations relationship

	List the organizations entitled for the isolation segment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the isolation segment
	@return ApiV3IsolationSegmentsGuidRelationshipsOrganizationsGetRequest
	*/
	V3IsolationSegmentsGuidRelationshipsOrganizationsGet(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidRelationshipsOrganizationsGetRequest

	// V3IsolationSegmentsGuidRelationshipsOrganizationsGetExecute executes the request
	//  @return V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response
	V3IsolationSegmentsGuidRelationshipsOrganizationsGetExecute(r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsGetRequest) (*V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response, *http.Response, error)

	/*
	V3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDelete Revoke entitlement to isolation segment for an organization

	Revoke the entitlement for the specified organization to the isolation segment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the isolation segment
	@param orgGuid The guid of the organization
	@return ApiV3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteRequest
	*/
	V3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDelete(ctx context.Context, guid string, orgGuid string) ApiV3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteRequest

	// V3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteExecute executes the request
	V3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteExecute(r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteRequest) (*http.Response, error)

	/*
	V3IsolationSegmentsGuidRelationshipsOrganizationsPost Entitle organizations for an isolation segment

	Entitle the specified organizations for the isolation segment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the isolation segment
	@return ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest
	*/
	V3IsolationSegmentsGuidRelationshipsOrganizationsPost(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest

	// V3IsolationSegmentsGuidRelationshipsOrganizationsPostExecute executes the request
	//  @return V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response
	V3IsolationSegmentsGuidRelationshipsOrganizationsPostExecute(r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest) (*V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response, *http.Response, error)

	/*
	V3IsolationSegmentsGuidRelationshipsSpacesGet List spaces relationship

	List the spaces to which the isolation segment is assigned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the isolation segment
	@return ApiV3IsolationSegmentsGuidRelationshipsSpacesGetRequest
	*/
	V3IsolationSegmentsGuidRelationshipsSpacesGet(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidRelationshipsSpacesGetRequest

	// V3IsolationSegmentsGuidRelationshipsSpacesGetExecute executes the request
	//  @return V3IsolationSegmentsGuidRelationshipsSpacesGet200Response
	V3IsolationSegmentsGuidRelationshipsSpacesGetExecute(r ApiV3IsolationSegmentsGuidRelationshipsSpacesGetRequest) (*V3IsolationSegmentsGuidRelationshipsSpacesGet200Response, *http.Response, error)

	/*
	V3IsolationSegmentsPost Create an isolation segment

	Create a new isolation segment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3IsolationSegmentsPostRequest
	*/
	V3IsolationSegmentsPost(ctx context.Context) ApiV3IsolationSegmentsPostRequest

	// V3IsolationSegmentsPostExecute executes the request
	//  @return IsolationSegment
	V3IsolationSegmentsPostExecute(r ApiV3IsolationSegmentsPostRequest) (*IsolationSegment, *http.Response, error)

	/*
	V3PackagesGet List packages

	Retrieve all packages the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3PackagesGetRequest
	*/
	V3PackagesGet(ctx context.Context) ApiV3PackagesGetRequest

	// V3PackagesGetExecute executes the request
	//  @return V3PackagesGet200Response
	V3PackagesGetExecute(r ApiV3PackagesGetRequest) (*V3PackagesGet200Response, *http.Response, error)

	/*
	V3PackagesGuidDelete Delete a package

	Delete a package by its GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3PackagesGuidDeleteRequest
	*/
	V3PackagesGuidDelete(ctx context.Context, guid string) ApiV3PackagesGuidDeleteRequest

	// V3PackagesGuidDeleteExecute executes the request
	//  @return V3PackagesGuidDelete202Response
	V3PackagesGuidDeleteExecute(r ApiV3PackagesGuidDeleteRequest) (*V3PackagesGuidDelete202Response, *http.Response, error)

	/*
	V3PackagesGuidDropletsGet List droplets for a package

	Retrieve a list of droplets belonging to a package.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the package
	@return ApiV3PackagesGuidDropletsGetRequest
	*/
	V3PackagesGuidDropletsGet(ctx context.Context, guid string) ApiV3PackagesGuidDropletsGetRequest

	// V3PackagesGuidDropletsGetExecute executes the request
	//  @return V3AppsGuidDropletsGet200Response
	V3PackagesGuidDropletsGetExecute(r ApiV3PackagesGuidDropletsGetRequest) (*V3AppsGuidDropletsGet200Response, *http.Response, error)

	/*
	V3PackagesGuidGet Get a package

	Retrieve a package by its GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3PackagesGuidGetRequest
	*/
	V3PackagesGuidGet(ctx context.Context, guid string) ApiV3PackagesGuidGetRequest

	// V3PackagesGuidGetExecute executes the request
	//  @return Package
	V3PackagesGuidGetExecute(r ApiV3PackagesGuidGetRequest) (*Package, *http.Response, error)

	/*
	V3PackagesGuidPatch Update a package

	Update a package by its GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3PackagesGuidPatchRequest
	*/
	V3PackagesGuidPatch(ctx context.Context, guid string) ApiV3PackagesGuidPatchRequest

	// V3PackagesGuidPatchExecute executes the request
	//  @return Package
	V3PackagesGuidPatchExecute(r ApiV3PackagesGuidPatchRequest) (*Package, *http.Response, error)

	/*
	V3PackagesGuidUploadPost Upload package bits

	Upload a new package by its GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3PackagesGuidUploadPostRequest
	*/
	V3PackagesGuidUploadPost(ctx context.Context, guid string) ApiV3PackagesGuidUploadPostRequest

	// V3PackagesGuidUploadPostExecute executes the request
	//  @return Package
	V3PackagesGuidUploadPostExecute(r ApiV3PackagesGuidUploadPostRequest) (*Package, *http.Response, error)

	/*
	V3PackagesPost Create a package

	Create a new package.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3PackagesPostRequest
	*/
	V3PackagesPost(ctx context.Context) ApiV3PackagesPostRequest

	// V3PackagesPostExecute executes the request
	//  @return Package
	V3PackagesPostExecute(r ApiV3PackagesPostRequest) (*Package, *http.Response, error)

	/*
	V3ProcessesGet List processes

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ProcessesGetRequest
	*/
	V3ProcessesGet(ctx context.Context) ApiV3ProcessesGetRequest

	// V3ProcessesGetExecute executes the request
	//  @return ProcessList
	V3ProcessesGetExecute(r ApiV3ProcessesGetRequest) (*ProcessList, *http.Response, error)

	/*
	V3ProcessesGuidActionsScalePost Scale a process

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ProcessesGuidActionsScalePostRequest
	*/
	V3ProcessesGuidActionsScalePost(ctx context.Context, guid string) ApiV3ProcessesGuidActionsScalePostRequest

	// V3ProcessesGuidActionsScalePostExecute executes the request
	//  @return Process
	V3ProcessesGuidActionsScalePostExecute(r ApiV3ProcessesGuidActionsScalePostRequest) (*Process, *http.Response, error)

	/*
	V3ProcessesGuidInstancesIndexDelete Terminate a process instance

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@param index
	@return ApiV3ProcessesGuidInstancesIndexDeleteRequest
	*/
	V3ProcessesGuidInstancesIndexDelete(ctx context.Context, guid string, index int32) ApiV3ProcessesGuidInstancesIndexDeleteRequest

	// V3ProcessesGuidInstancesIndexDeleteExecute executes the request
	V3ProcessesGuidInstancesIndexDeleteExecute(r ApiV3ProcessesGuidInstancesIndexDeleteRequest) (*http.Response, error)

	/*
	V3ProcessesGuidPatch Update a process

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ProcessesGuidPatchRequest
	*/
	V3ProcessesGuidPatch(ctx context.Context, guid string) ApiV3ProcessesGuidPatchRequest

	// V3ProcessesGuidPatchExecute executes the request
	//  @return Process
	V3ProcessesGuidPatchExecute(r ApiV3ProcessesGuidPatchRequest) (*Process, *http.Response, error)

	/*
	V3ProcessesGuidSidecarsGet List sidecars for a process

	Retrieves all sidecars associated with a process.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ProcessesGuidSidecarsGetRequest
	*/
	V3ProcessesGuidSidecarsGet(ctx context.Context, guid string) ApiV3ProcessesGuidSidecarsGetRequest

	// V3ProcessesGuidSidecarsGetExecute executes the request
	//  @return V3AppsGuidSidecarsGet200Response
	V3ProcessesGuidSidecarsGetExecute(r ApiV3ProcessesGuidSidecarsGetRequest) (*V3AppsGuidSidecarsGet200Response, *http.Response, error)

	/*
	V3ProcessesGuidStatsGet Get stats for a process

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ProcessesGuidStatsGetRequest
	*/
	V3ProcessesGuidStatsGet(ctx context.Context, guid string) ApiV3ProcessesGuidStatsGetRequest

	// V3ProcessesGuidStatsGetExecute executes the request
	//  @return []ProcessStats
	V3ProcessesGuidStatsGetExecute(r ApiV3ProcessesGuidStatsGetRequest) ([]ProcessStats, *http.Response, error)

	/*
	V3ResourceMatchesPost Create a resource match

	This endpoint matches given resource SHA-1/file size pairs against the Cloud Controller cache and reports the subset that describes already cached files. This is usually used to avoid uploading duplicate files when pushing an app which has only been partially changed. The path and mode fields are not used when matching.

When uploading package bits, the response from this endpoint should be used as the resources form field. As such, it is useful to include the path and mode fields for each resource even though they are not used when determining a resource match.

Cloud Foundry operators may set minimum/maximum file sizes to match against. If the file size provided is outside this range, it will not be matched against.

If the resource_matching feature flag is disabled, resource matching will always return an empty array.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ResourceMatchesPostRequest
	*/
	V3ResourceMatchesPost(ctx context.Context) ApiV3ResourceMatchesPostRequest

	// V3ResourceMatchesPostExecute executes the request
	//  @return ResourceMatchResponse
	V3ResourceMatchesPostExecute(r ApiV3ResourceMatchesPostRequest) (*ResourceMatchResponse, *http.Response, error)

	/*
	V3RevisionsGuidEnvironmentVariablesGet Get environment variables for a revision

	Retrieve the environment variables associated with the revision.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid Unique identifier for the revision
	@return ApiV3RevisionsGuidEnvironmentVariablesGetRequest
	*/
	V3RevisionsGuidEnvironmentVariablesGet(ctx context.Context, guid string) ApiV3RevisionsGuidEnvironmentVariablesGetRequest

	// V3RevisionsGuidEnvironmentVariablesGetExecute executes the request
	//  @return EnvironmentVariables
	V3RevisionsGuidEnvironmentVariablesGetExecute(r ApiV3RevisionsGuidEnvironmentVariablesGetRequest) (*EnvironmentVariables, *http.Response, error)

	/*
	V3RevisionsGuidPatch Update a revision

	Update metadata for a specific revision.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid Unique identifier for the revision
	@return ApiV3RevisionsGuidPatchRequest
	*/
	V3RevisionsGuidPatch(ctx context.Context, guid string) ApiV3RevisionsGuidPatchRequest

	// V3RevisionsGuidPatchExecute executes the request
	//  @return Revision
	V3RevisionsGuidPatchExecute(r ApiV3RevisionsGuidPatchRequest) (*Revision, *http.Response, error)

	/*
	V3RolesGet List roles

	List roles that the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3RolesGetRequest
	*/
	V3RolesGet(ctx context.Context) ApiV3RolesGetRequest

	// V3RolesGetExecute executes the request
	//  @return RolesList
	V3RolesGetExecute(r ApiV3RolesGetRequest) (*RolesList, *http.Response, error)

	/*
	V3RolesGuidDelete Delete a role

	Delete an individual role.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid Unique identifier for the role
	@return ApiV3RolesGuidDeleteRequest
	*/
	V3RolesGuidDelete(ctx context.Context, guid string) ApiV3RolesGuidDeleteRequest

	// V3RolesGuidDeleteExecute executes the request
	V3RolesGuidDeleteExecute(r ApiV3RolesGuidDeleteRequest) (*http.Response, error)

	/*
	V3RolesGuidGet Get a role

	Get an individual role resource.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid Unique identifier for the role
	@return ApiV3RolesGuidGetRequest
	*/
	V3RolesGuidGet(ctx context.Context, guid string) ApiV3RolesGuidGetRequest

	// V3RolesGuidGetExecute executes the request
	//  @return Role
	V3RolesGuidGetExecute(r ApiV3RolesGuidGetRequest) (*Role, *http.Response, error)

	/*
	V3RolesPost Create a role

	Create a new role for a user in an organization or space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3RolesPostRequest
	*/
	V3RolesPost(ctx context.Context) ApiV3RolesPostRequest

	// V3RolesPostExecute executes the request
	//  @return Role
	V3RolesPostExecute(r ApiV3RolesPostRequest) (*Role, *http.Response, error)

	/*
	V3RoutesGet List routes

	Retrieve all routes the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3RoutesGetRequest
	*/
	V3RoutesGet(ctx context.Context) ApiV3RoutesGetRequest

	// V3RoutesGetExecute executes the request
	//  @return V3RoutesGet200Response
	V3RoutesGetExecute(r ApiV3RoutesGetRequest) (*V3RoutesGet200Response, *http.Response, error)

	/*
	V3RoutesGuidGet Get a route

	Retrieve a route by its GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The route GUID
	@return ApiV3RoutesGuidGetRequest
	*/
	V3RoutesGuidGet(ctx context.Context, guid string) ApiV3RoutesGuidGetRequest

	// V3RoutesGuidGetExecute executes the request
	//  @return Route
	V3RoutesGuidGetExecute(r ApiV3RoutesGuidGetRequest) (*Route, *http.Response, error)

	/*
	V3RoutesPost Create a route

	Create a new route.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3RoutesPostRequest
	*/
	V3RoutesPost(ctx context.Context) ApiV3RoutesPostRequest

	// V3RoutesPostExecute executes the request
	//  @return Route
	V3RoutesPostExecute(r ApiV3RoutesPostRequest) (*Route, *http.Response, error)

	/*
	V3SecurityGroupsGet List security groups

	Retrieves a list of security groups.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3SecurityGroupsGetRequest
	*/
	V3SecurityGroupsGet(ctx context.Context) ApiV3SecurityGroupsGetRequest

	// V3SecurityGroupsGetExecute executes the request
	//  @return SecurityGroupList
	V3SecurityGroupsGetExecute(r ApiV3SecurityGroupsGetRequest) (*SecurityGroupList, *http.Response, error)

	/*
	V3SecurityGroupsGuidDelete Delete a security group

	Deletes a security group by its GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The security group GUID
	@return ApiV3SecurityGroupsGuidDeleteRequest
	*/
	V3SecurityGroupsGuidDelete(ctx context.Context, guid string) ApiV3SecurityGroupsGuidDeleteRequest

	// V3SecurityGroupsGuidDeleteExecute executes the request
	V3SecurityGroupsGuidDeleteExecute(r ApiV3SecurityGroupsGuidDeleteRequest) (*http.Response, error)

	/*
	V3SecurityGroupsGuidGet Get a security group

	Retrieves a security group by its GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The security group GUID
	@return ApiV3SecurityGroupsGuidGetRequest
	*/
	V3SecurityGroupsGuidGet(ctx context.Context, guid string) ApiV3SecurityGroupsGuidGetRequest

	// V3SecurityGroupsGuidGetExecute executes the request
	//  @return SecurityGroup
	V3SecurityGroupsGuidGetExecute(r ApiV3SecurityGroupsGuidGetRequest) (*SecurityGroup, *http.Response, error)

	/*
	V3SecurityGroupsGuidPatch Update a security group

	Updates the specified attributes of the security group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The security group GUID
	@return ApiV3SecurityGroupsGuidPatchRequest
	*/
	V3SecurityGroupsGuidPatch(ctx context.Context, guid string) ApiV3SecurityGroupsGuidPatchRequest

	// V3SecurityGroupsGuidPatchExecute executes the request
	//  @return SecurityGroup
	V3SecurityGroupsGuidPatchExecute(r ApiV3SecurityGroupsGuidPatchRequest) (*SecurityGroup, *http.Response, error)

	/*
	V3SecurityGroupsPost Create a security group

	Creates a new security group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3SecurityGroupsPostRequest
	*/
	V3SecurityGroupsPost(ctx context.Context) ApiV3SecurityGroupsPostRequest

	// V3SecurityGroupsPostExecute executes the request
	//  @return SecurityGroup
	V3SecurityGroupsPostExecute(r ApiV3SecurityGroupsPostRequest) (*SecurityGroup, *http.Response, error)

	/*
	V3ServiceBrokersGet List service brokers

	Retrieves the service brokers the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceBrokersGetRequest
	*/
	V3ServiceBrokersGet(ctx context.Context) ApiV3ServiceBrokersGetRequest

	// V3ServiceBrokersGetExecute executes the request
	//  @return ServiceBrokerList
	V3ServiceBrokersGetExecute(r ApiV3ServiceBrokersGetRequest) (*ServiceBrokerList, *http.Response, error)

	/*
	V3ServiceBrokersGuidDelete Delete a service broker

	Creates a job to delete an existing service broker.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The service broker GUID
	@return ApiV3ServiceBrokersGuidDeleteRequest
	*/
	V3ServiceBrokersGuidDelete(ctx context.Context, guid string) ApiV3ServiceBrokersGuidDeleteRequest

	// V3ServiceBrokersGuidDeleteExecute executes the request
	V3ServiceBrokersGuidDeleteExecute(r ApiV3ServiceBrokersGuidDeleteRequest) (*http.Response, error)

	/*
	V3ServiceBrokersGuidGet Get a service broker

	Retrieves the service broker by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The service broker GUID
	@return ApiV3ServiceBrokersGuidGetRequest
	*/
	V3ServiceBrokersGuidGet(ctx context.Context, guid string) ApiV3ServiceBrokersGuidGetRequest

	// V3ServiceBrokersGuidGetExecute executes the request
	//  @return ServiceBroker
	V3ServiceBrokersGuidGetExecute(r ApiV3ServiceBrokersGuidGetRequest) (*ServiceBroker, *http.Response, error)

	/*
	V3ServiceBrokersGuidPatch Update a service broker

	Updates a service broker.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The service broker GUID
	@return ApiV3ServiceBrokersGuidPatchRequest
	*/
	V3ServiceBrokersGuidPatch(ctx context.Context, guid string) ApiV3ServiceBrokersGuidPatchRequest

	// V3ServiceBrokersGuidPatchExecute executes the request
	//  @return ServiceBroker
	V3ServiceBrokersGuidPatchExecute(r ApiV3ServiceBrokersGuidPatchRequest) (*ServiceBroker, *http.Response, error)

	/*
	V3ServiceBrokersPost Create a service broker

	Creates a new service broker and a job to synchronize the service offerings and service plans with those in the broker’s catalog.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceBrokersPostRequest
	*/
	V3ServiceBrokersPost(ctx context.Context) ApiV3ServiceBrokersPostRequest

	// V3ServiceBrokersPostExecute executes the request
	//  @return ServiceBroker
	V3ServiceBrokersPostExecute(r ApiV3ServiceBrokersPostRequest) (*ServiceBroker, *http.Response, error)

	/*
	V3ServiceCredentialBindingsGuidDelete Delete a service credential binding

	This endpoint deletes a service credential binding.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceCredentialBindingsGuidDeleteRequest
	*/
	V3ServiceCredentialBindingsGuidDelete(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidDeleteRequest

	// V3ServiceCredentialBindingsGuidDeleteExecute executes the request
	V3ServiceCredentialBindingsGuidDeleteExecute(r ApiV3ServiceCredentialBindingsGuidDeleteRequest) (*http.Response, error)

	/*
	V3ServiceCredentialBindingsGuidDetailsGet Get a service credential binding details

	This endpoint retrieves the service credential binding details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceCredentialBindingsGuidDetailsGetRequest
	*/
	V3ServiceCredentialBindingsGuidDetailsGet(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidDetailsGetRequest

	// V3ServiceCredentialBindingsGuidDetailsGetExecute executes the request
	//  @return V3ServiceCredentialBindingsGuidDetailsGet200Response
	V3ServiceCredentialBindingsGuidDetailsGetExecute(r ApiV3ServiceCredentialBindingsGuidDetailsGetRequest) (*V3ServiceCredentialBindingsGuidDetailsGet200Response, *http.Response, error)

	/*
	V3ServiceCredentialBindingsGuidGet Get a service credential binding

	This endpoint retrieves the service credential binding by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceCredentialBindingsGuidGetRequest
	*/
	V3ServiceCredentialBindingsGuidGet(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidGetRequest

	// V3ServiceCredentialBindingsGuidGetExecute executes the request
	//  @return ServiceCredentialBinding
	V3ServiceCredentialBindingsGuidGetExecute(r ApiV3ServiceCredentialBindingsGuidGetRequest) (*ServiceCredentialBinding, *http.Response, error)

	/*
	V3ServiceCredentialBindingsGuidParametersGet Get parameters for a service credential binding

	Queries the Service Broker for the parameters associated with this service credential binding.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceCredentialBindingsGuidParametersGetRequest
	*/
	V3ServiceCredentialBindingsGuidParametersGet(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidParametersGetRequest

	// V3ServiceCredentialBindingsGuidParametersGetExecute executes the request
	//  @return map[string]interface{}
	V3ServiceCredentialBindingsGuidParametersGetExecute(r ApiV3ServiceCredentialBindingsGuidParametersGetRequest) (map[string]interface{}, *http.Response, error)

	/*
	V3ServiceCredentialBindingsGuidPatch Update a service credential binding

	This endpoint updates a service credential binding with labels and annotations.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceCredentialBindingsGuidPatchRequest
	*/
	V3ServiceCredentialBindingsGuidPatch(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidPatchRequest

	// V3ServiceCredentialBindingsGuidPatchExecute executes the request
	//  @return ServiceCredentialBinding
	V3ServiceCredentialBindingsGuidPatchExecute(r ApiV3ServiceCredentialBindingsGuidPatchRequest) (*ServiceCredentialBinding, *http.Response, error)

	/*
	V3ServiceCredentialBindingsPost Create a service credential binding

	This endpoint creates a new service credential binding. Service credential bindings can be of type app or key; key is only valid for managed service instances.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceCredentialBindingsPostRequest
	*/
	V3ServiceCredentialBindingsPost(ctx context.Context) ApiV3ServiceCredentialBindingsPostRequest

	// V3ServiceCredentialBindingsPostExecute executes the request
	//  @return ServiceCredentialBinding
	V3ServiceCredentialBindingsPostExecute(r ApiV3ServiceCredentialBindingsPostRequest) (*ServiceCredentialBinding, *http.Response, error)

	/*
	V3ServiceInstancesGet Retrieve service instances

	Retrieves the service instances the user has access to, including access granted by service instance sharing.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceInstancesGetRequest
	*/
	V3ServiceInstancesGet(ctx context.Context) ApiV3ServiceInstancesGetRequest

	// V3ServiceInstancesGetExecute executes the request
	//  @return V3ServiceInstancesGet200Response
	V3ServiceInstancesGetExecute(r ApiV3ServiceInstancesGetRequest) (*V3ServiceInstancesGet200Response, *http.Response, error)

	/*
	V3ServiceInstancesGuidCredentialsGet Get credentials for a user-provided service instance

	Retrieves the credentials for a user-provided service instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid GUID of the service instance
	@return ApiV3ServiceInstancesGuidCredentialsGetRequest
	*/
	V3ServiceInstancesGuidCredentialsGet(ctx context.Context, guid string) ApiV3ServiceInstancesGuidCredentialsGetRequest

	// V3ServiceInstancesGuidCredentialsGetExecute executes the request
	//  @return map[string]string
	V3ServiceInstancesGuidCredentialsGetExecute(r ApiV3ServiceInstancesGuidCredentialsGetRequest) (map[string]string, *http.Response, error)

	/*
	V3ServiceInstancesGuidPatch Update a service instance

	Updates a service instance with the provided attributes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid GUID of the service instance
	@return ApiV3ServiceInstancesGuidPatchRequest
	*/
	V3ServiceInstancesGuidPatch(ctx context.Context, guid string) ApiV3ServiceInstancesGuidPatchRequest

	// V3ServiceInstancesGuidPatchExecute executes the request
	//  @return ServiceInstance
	V3ServiceInstancesGuidPatchExecute(r ApiV3ServiceInstancesGuidPatchRequest) (*ServiceInstance, *http.Response, error)

	/*
	V3ServiceInstancesGuidRelationshipsSharedSpacesPost Share a service instance to other spaces

	Shares the service instance with the specified spaces.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid GUID of the service instance
	@return ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest
	*/
	V3ServiceInstancesGuidRelationshipsSharedSpacesPost(ctx context.Context, guid string) ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest

	// V3ServiceInstancesGuidRelationshipsSharedSpacesPostExecute executes the request
	//  @return V3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest
	V3ServiceInstancesGuidRelationshipsSharedSpacesPostExecute(r ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest) (*V3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest, *http.Response, error)

	/*
	V3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDelete Unshare a service instance from another space

	Unshares the service instance from the specified space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid GUID of the service instance
	@param spaceGuid GUID of the space
	@return ApiV3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteRequest
	*/
	V3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDelete(ctx context.Context, guid string, spaceGuid string) ApiV3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteRequest

	// V3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteExecute executes the request
	V3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteExecute(r ApiV3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteRequest) (*http.Response, error)

	/*
	V3ServiceInstancesGuidRelationshipsSharedSpacesUsageSummaryGet Get usage summary in shared spaces

	Returns the number of bound apps in spaces where the service instance has been shared to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid GUID of the service instance
	@return ApiV3ServiceInstancesGuidRelationshipsSharedSpacesUsageSummaryGetRequest
	*/
	V3ServiceInstancesGuidRelationshipsSharedSpacesUsageSummaryGet(ctx context.Context, guid string) ApiV3ServiceInstancesGuidRelationshipsSharedSpacesUsageSummaryGetRequest

	// V3ServiceInstancesGuidRelationshipsSharedSpacesUsageSummaryGetExecute executes the request
	//  @return UsageSummary
	V3ServiceInstancesGuidRelationshipsSharedSpacesUsageSummaryGetExecute(r ApiV3ServiceInstancesGuidRelationshipsSharedSpacesUsageSummaryGetRequest) (*UsageSummary, *http.Response, error)

	/*
	V3ServiceOfferingsGet List service offerings

	Retrieves the service offerings the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceOfferingsGetRequest
	*/
	V3ServiceOfferingsGet(ctx context.Context) ApiV3ServiceOfferingsGetRequest

	// V3ServiceOfferingsGetExecute executes the request
	//  @return ServiceOfferingList
	V3ServiceOfferingsGetExecute(r ApiV3ServiceOfferingsGetRequest) (*ServiceOfferingList, *http.Response, error)

	/*
	V3ServiceOfferingsGuidDelete Delete a service offering

	Deletes a service offering.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The service offering GUID
	@return ApiV3ServiceOfferingsGuidDeleteRequest
	*/
	V3ServiceOfferingsGuidDelete(ctx context.Context, guid string) ApiV3ServiceOfferingsGuidDeleteRequest

	// V3ServiceOfferingsGuidDeleteExecute executes the request
	V3ServiceOfferingsGuidDeleteExecute(r ApiV3ServiceOfferingsGuidDeleteRequest) (*http.Response, error)

	/*
	V3ServiceOfferingsGuidGet Get a service offering

	Retrieves the service offering by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The service offering GUID
	@return ApiV3ServiceOfferingsGuidGetRequest
	*/
	V3ServiceOfferingsGuidGet(ctx context.Context, guid string) ApiV3ServiceOfferingsGuidGetRequest

	// V3ServiceOfferingsGuidGetExecute executes the request
	//  @return ServiceOffering
	V3ServiceOfferingsGuidGetExecute(r ApiV3ServiceOfferingsGuidGetRequest) (*ServiceOffering, *http.Response, error)

	/*
	V3ServiceOfferingsGuidPatch Update a service offering

	Updates a service offering.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The service offering GUID
	@return ApiV3ServiceOfferingsGuidPatchRequest
	*/
	V3ServiceOfferingsGuidPatch(ctx context.Context, guid string) ApiV3ServiceOfferingsGuidPatchRequest

	// V3ServiceOfferingsGuidPatchExecute executes the request
	//  @return ServiceOffering
	V3ServiceOfferingsGuidPatchExecute(r ApiV3ServiceOfferingsGuidPatchRequest) (*ServiceOffering, *http.Response, error)

	/*
	V3ServiceOfferingsPost Create a service offering

	Creates a new service offering.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceOfferingsPostRequest
	*/
	V3ServiceOfferingsPost(ctx context.Context) ApiV3ServiceOfferingsPostRequest

	// V3ServiceOfferingsPostExecute executes the request
	//  @return ServiceOffering
	V3ServiceOfferingsPostExecute(r ApiV3ServiceOfferingsPostRequest) (*ServiceOffering, *http.Response, error)

	/*
	V3ServicePlansGet List service plans

	Retrieves the service plans the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServicePlansGetRequest
	*/
	V3ServicePlansGet(ctx context.Context) ApiV3ServicePlansGetRequest

	// V3ServicePlansGetExecute executes the request
	//  @return ServicePlanList
	V3ServicePlansGetExecute(r ApiV3ServicePlansGetRequest) (*ServicePlanList, *http.Response, error)

	/*
	V3ServicePlansGuidDelete Delete a service plan

	Deletes a service plan.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The service plan GUID
	@return ApiV3ServicePlansGuidDeleteRequest
	*/
	V3ServicePlansGuidDelete(ctx context.Context, guid string) ApiV3ServicePlansGuidDeleteRequest

	// V3ServicePlansGuidDeleteExecute executes the request
	V3ServicePlansGuidDeleteExecute(r ApiV3ServicePlansGuidDeleteRequest) (*http.Response, error)

	/*
	V3ServicePlansGuidGet Get a service plan

	Retrieves the service plan by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The service plan GUID
	@return ApiV3ServicePlansGuidGetRequest
	*/
	V3ServicePlansGuidGet(ctx context.Context, guid string) ApiV3ServicePlansGuidGetRequest

	// V3ServicePlansGuidGetExecute executes the request
	//  @return ServicePlan
	V3ServicePlansGuidGetExecute(r ApiV3ServicePlansGuidGetRequest) (*ServicePlan, *http.Response, error)

	/*
	V3ServicePlansGuidPatch Update a service plan

	Updates a service plan.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The service plan GUID
	@return ApiV3ServicePlansGuidPatchRequest
	*/
	V3ServicePlansGuidPatch(ctx context.Context, guid string) ApiV3ServicePlansGuidPatchRequest

	// V3ServicePlansGuidPatchExecute executes the request
	//  @return ServicePlan
	V3ServicePlansGuidPatchExecute(r ApiV3ServicePlansGuidPatchRequest) (*ServicePlan, *http.Response, error)

	/*
	V3ServicePlansGuidVisibilityGet Get a service plan visibility

	Retrieves the service plan visibility for a given plan.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The service plan GUID
	@return ApiV3ServicePlansGuidVisibilityGetRequest
	*/
	V3ServicePlansGuidVisibilityGet(ctx context.Context, guid string) ApiV3ServicePlansGuidVisibilityGetRequest

	// V3ServicePlansGuidVisibilityGetExecute executes the request
	//  @return ServicePlanVisibility
	V3ServicePlansGuidVisibilityGetExecute(r ApiV3ServicePlansGuidVisibilityGetRequest) (*ServicePlanVisibility, *http.Response, error)

	/*
	V3ServicePlansGuidVisibilityOrganizationGuidDelete Remove organization from a service plan visibility

	Removes an organization from a service plan visibility list of organizations. Defined only for service plans which are organization-restricted.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The service plan GUID
	@param organizationGuid The organization GUID
	@return ApiV3ServicePlansGuidVisibilityOrganizationGuidDeleteRequest
	*/
	V3ServicePlansGuidVisibilityOrganizationGuidDelete(ctx context.Context, guid string, organizationGuid string) ApiV3ServicePlansGuidVisibilityOrganizationGuidDeleteRequest

	// V3ServicePlansGuidVisibilityOrganizationGuidDeleteExecute executes the request
	V3ServicePlansGuidVisibilityOrganizationGuidDeleteExecute(r ApiV3ServicePlansGuidVisibilityOrganizationGuidDeleteRequest) (*http.Response, error)

	/*
	V3ServicePlansGuidVisibilityPatch Update a service plan visibility

	Updates a service plan visibility. Replaces the existing list of organizations when the service plan is organization visible.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The service plan GUID
	@return ApiV3ServicePlansGuidVisibilityPatchRequest
	*/
	V3ServicePlansGuidVisibilityPatch(ctx context.Context, guid string) ApiV3ServicePlansGuidVisibilityPatchRequest

	// V3ServicePlansGuidVisibilityPatchExecute executes the request
	//  @return ServicePlanVisibility
	V3ServicePlansGuidVisibilityPatchExecute(r ApiV3ServicePlansGuidVisibilityPatchRequest) (*ServicePlanVisibility, *http.Response, error)

	/*
	V3ServicePlansGuidVisibilityPost Apply a service plan visibility

	Applies a service plan visibility. Appends to the existing list of organizations when the service plan is organization visible.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The service plan GUID
	@return ApiV3ServicePlansGuidVisibilityPostRequest
	*/
	V3ServicePlansGuidVisibilityPost(ctx context.Context, guid string) ApiV3ServicePlansGuidVisibilityPostRequest

	// V3ServicePlansGuidVisibilityPostExecute executes the request
	//  @return ServicePlanVisibility
	V3ServicePlansGuidVisibilityPostExecute(r ApiV3ServicePlansGuidVisibilityPostRequest) (*ServicePlanVisibility, *http.Response, error)

	/*
	V3ServicePlansPost Create a service plan

	Creates a new service plan.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServicePlansPostRequest
	*/
	V3ServicePlansPost(ctx context.Context) ApiV3ServicePlansPostRequest

	// V3ServicePlansPostExecute executes the request
	//  @return ServicePlan
	V3ServicePlansPostExecute(r ApiV3ServicePlansPostRequest) (*ServicePlan, *http.Response, error)

	/*
	V3ServiceRouteBindingsGet List service route bindings

	Retrieves the service route bindings the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceRouteBindingsGetRequest
	*/
	V3ServiceRouteBindingsGet(ctx context.Context) ApiV3ServiceRouteBindingsGetRequest

	// V3ServiceRouteBindingsGetExecute executes the request
	//  @return V3ServiceRouteBindingsGet200Response
	V3ServiceRouteBindingsGetExecute(r ApiV3ServiceRouteBindingsGetRequest) (*V3ServiceRouteBindingsGet200Response, *http.Response, error)

	/*
	V3ServiceRouteBindingsGuidDelete Delete a service route binding

	Deletes a service route binding. When deleting route bindings originating from user-provided service instances, the delete operation does not require interactions with service brokers, therefore the API will respond synchronously to the delete request.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceRouteBindingsGuidDeleteRequest
	*/
	V3ServiceRouteBindingsGuidDelete(ctx context.Context, guid string) ApiV3ServiceRouteBindingsGuidDeleteRequest

	// V3ServiceRouteBindingsGuidDeleteExecute executes the request
	V3ServiceRouteBindingsGuidDeleteExecute(r ApiV3ServiceRouteBindingsGuidDeleteRequest) (*http.Response, error)

	/*
	V3ServiceRouteBindingsGuidGet Get a service route binding

	Retrieves the service route binding by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceRouteBindingsGuidGetRequest
	*/
	V3ServiceRouteBindingsGuidGet(ctx context.Context, guid string) ApiV3ServiceRouteBindingsGuidGetRequest

	// V3ServiceRouteBindingsGuidGetExecute executes the request
	//  @return ServiceRouteBinding
	V3ServiceRouteBindingsGuidGetExecute(r ApiV3ServiceRouteBindingsGuidGetRequest) (*ServiceRouteBinding, *http.Response, error)

	/*
	V3ServiceRouteBindingsGuidParametersGet Get parameters for a route binding

	Queries the Service Broker for the parameters associated with this service route binding. This endpoint is not available for User-Provided Service Instances.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceRouteBindingsGuidParametersGetRequest
	*/
	V3ServiceRouteBindingsGuidParametersGet(ctx context.Context, guid string) ApiV3ServiceRouteBindingsGuidParametersGetRequest

	// V3ServiceRouteBindingsGuidParametersGetExecute executes the request
	//  @return map[string]string
	V3ServiceRouteBindingsGuidParametersGetExecute(r ApiV3ServiceRouteBindingsGuidParametersGetRequest) (map[string]string, *http.Response, error)

	/*
	V3ServiceRouteBindingsGuidPatch Update a service route binding

	Updates a service route binding with labels and annotations.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceRouteBindingsGuidPatchRequest
	*/
	V3ServiceRouteBindingsGuidPatch(ctx context.Context, guid string) ApiV3ServiceRouteBindingsGuidPatchRequest

	// V3ServiceRouteBindingsGuidPatchExecute executes the request
	//  @return ServiceRouteBinding
	V3ServiceRouteBindingsGuidPatchExecute(r ApiV3ServiceRouteBindingsGuidPatchRequest) (*ServiceRouteBinding, *http.Response, error)

	/*
	V3ServiceRouteBindingsPost Create a service route binding

	Creates a new route service binding. The service instance and the route must be in the same space.
To bind a route to a user-provided service instance, the service instance must have the route_service_url property set.
To bind a route to a managed service instance, the service offering must be bindable, and the service offering must have route_forwarding set in the requires property.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceRouteBindingsPostRequest
	*/
	V3ServiceRouteBindingsPost(ctx context.Context) ApiV3ServiceRouteBindingsPostRequest

	// V3ServiceRouteBindingsPostExecute executes the request
	//  @return ServiceRouteBinding
	V3ServiceRouteBindingsPostExecute(r ApiV3ServiceRouteBindingsPostRequest) (*ServiceRouteBinding, *http.Response, error)

	/*
	V3ServiceUsageEventsGet List service usage events

	Retrieve all service usage events the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceUsageEventsGetRequest
	*/
	V3ServiceUsageEventsGet(ctx context.Context) ApiV3ServiceUsageEventsGetRequest

	// V3ServiceUsageEventsGetExecute executes the request
	//  @return V3ServiceUsageEventsGet200Response
	V3ServiceUsageEventsGetExecute(r ApiV3ServiceUsageEventsGetRequest) (*V3ServiceUsageEventsGet200Response, *http.Response, error)

	/*
	V3ServiceUsageEventsGuidGet Get a service usage event

	Retrieve a service usage event by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceUsageEventsGuidGetRequest
	*/
	V3ServiceUsageEventsGuidGet(ctx context.Context, guid string) ApiV3ServiceUsageEventsGuidGetRequest

	// V3ServiceUsageEventsGuidGetExecute executes the request
	//  @return ServiceUsageEvent
	V3ServiceUsageEventsGuidGetExecute(r ApiV3ServiceUsageEventsGuidGetRequest) (*ServiceUsageEvent, *http.Response, error)

	/*
	V3ServiceUsageEventsPost Purge and seed service usage events

	Destroys all existing events. Populates new usage events, one for each existing service instance.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceUsageEventsPostRequest
	*/
	V3ServiceUsageEventsPost(ctx context.Context) ApiV3ServiceUsageEventsPostRequest

	// V3ServiceUsageEventsPostExecute executes the request
	V3ServiceUsageEventsPostExecute(r ApiV3ServiceUsageEventsPostRequest) (*http.Response, error)

	/*
	V3SidecarsGuidDelete Delete a sidecar

	Deletes a sidecar by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3SidecarsGuidDeleteRequest
	*/
	V3SidecarsGuidDelete(ctx context.Context, guid string) ApiV3SidecarsGuidDeleteRequest

	// V3SidecarsGuidDeleteExecute executes the request
	V3SidecarsGuidDeleteExecute(r ApiV3SidecarsGuidDeleteRequest) (*http.Response, error)

	/*
	V3SidecarsGuidGet Get a sidecar

	Retrieve a sidecar by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3SidecarsGuidGetRequest
	*/
	V3SidecarsGuidGet(ctx context.Context, guid string) ApiV3SidecarsGuidGetRequest

	// V3SidecarsGuidGetExecute executes the request
	//  @return Sidecar
	V3SidecarsGuidGetExecute(r ApiV3SidecarsGuidGetRequest) (*Sidecar, *http.Response, error)

	/*
	V3SidecarsGuidPatch Update a sidecar

	Updates the attributes of a sidecar.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3SidecarsGuidPatchRequest
	*/
	V3SidecarsGuidPatch(ctx context.Context, guid string) ApiV3SidecarsGuidPatchRequest

	// V3SidecarsGuidPatchExecute executes the request
	//  @return Sidecar
	V3SidecarsGuidPatchExecute(r ApiV3SidecarsGuidPatchRequest) (*Sidecar, *http.Response, error)

	/*
	V3SpaceQuotasGet List space quotas

	List all space quota resources that the user has permission to view.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3SpaceQuotasGetRequest
	*/
	V3SpaceQuotasGet(ctx context.Context) ApiV3SpaceQuotasGetRequest

	// V3SpaceQuotasGetExecute executes the request
	//  @return V3SpaceQuotasGet200Response
	V3SpaceQuotasGetExecute(r ApiV3SpaceQuotasGetRequest) (*V3SpaceQuotasGet200Response, *http.Response, error)

	/*
	V3SpaceQuotasGuidDelete Delete a space quota

	Delete a space quota by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3SpaceQuotasGuidDeleteRequest
	*/
	V3SpaceQuotasGuidDelete(ctx context.Context, guid string) ApiV3SpaceQuotasGuidDeleteRequest

	// V3SpaceQuotasGuidDeleteExecute executes the request
	V3SpaceQuotasGuidDeleteExecute(r ApiV3SpaceQuotasGuidDeleteRequest) (*http.Response, error)

	/*
	V3SpaceQuotasGuidGet Get a space quota

	Retrieve a space quota by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3SpaceQuotasGuidGetRequest
	*/
	V3SpaceQuotasGuidGet(ctx context.Context, guid string) ApiV3SpaceQuotasGuidGetRequest

	// V3SpaceQuotasGuidGetExecute executes the request
	//  @return SpaceQuota
	V3SpaceQuotasGuidGetExecute(r ApiV3SpaceQuotasGuidGetRequest) (*SpaceQuota, *http.Response, error)

	/*
	V3SpaceQuotasGuidPatch Update a space quota

	Update the specified parameters of a space quota.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3SpaceQuotasGuidPatchRequest
	*/
	V3SpaceQuotasGuidPatch(ctx context.Context, guid string) ApiV3SpaceQuotasGuidPatchRequest

	// V3SpaceQuotasGuidPatchExecute executes the request
	//  @return SpaceQuota
	V3SpaceQuotasGuidPatchExecute(r ApiV3SpaceQuotasGuidPatchRequest) (*SpaceQuota, *http.Response, error)

	/*
	V3SpaceQuotasPost Create a space quota

	Create a new space quota scoped to a specific organization.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3SpaceQuotasPostRequest
	*/
	V3SpaceQuotasPost(ctx context.Context) ApiV3SpaceQuotasPostRequest

	// V3SpaceQuotasPostExecute executes the request
	//  @return SpaceQuota
	V3SpaceQuotasPostExecute(r ApiV3SpaceQuotasPostRequest) (*SpaceQuota, *http.Response, error)

	/*
	V3SpaceQuotasQuotaGuidRelationshipsSpacesPost Apply a space quota to spaces

	Apply a space quota to one or more spaces.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param quotaGuid
	@return ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesPostRequest
	*/
	V3SpaceQuotasQuotaGuidRelationshipsSpacesPost(ctx context.Context, quotaGuid string) ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesPostRequest

	// V3SpaceQuotasQuotaGuidRelationshipsSpacesPostExecute executes the request
	//  @return V3SpaceQuotasQuotaGuidRelationshipsSpacesPost200Response
	V3SpaceQuotasQuotaGuidRelationshipsSpacesPostExecute(r ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesPostRequest) (*V3SpaceQuotasQuotaGuidRelationshipsSpacesPost200Response, *http.Response, error)

	/*
	V3SpaceQuotasQuotaGuidRelationshipsSpacesSpaceGuidDelete Remove a space quota from a space

	Remove a space quota from a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param quotaGuid
	@param spaceGuid
	@return ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesSpaceGuidDeleteRequest
	*/
	V3SpaceQuotasQuotaGuidRelationshipsSpacesSpaceGuidDelete(ctx context.Context, quotaGuid string, spaceGuid string) ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesSpaceGuidDeleteRequest

	// V3SpaceQuotasQuotaGuidRelationshipsSpacesSpaceGuidDeleteExecute executes the request
	V3SpaceQuotasQuotaGuidRelationshipsSpacesSpaceGuidDeleteExecute(r ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesSpaceGuidDeleteRequest) (*http.Response, error)

	/*
	V3SpacesGet List spaces

	Retrieve all spaces the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3SpacesGetRequest
	*/
	V3SpacesGet(ctx context.Context) ApiV3SpacesGetRequest

	// V3SpacesGetExecute executes the request
	//  @return V3SpacesGet200Response
	V3SpacesGetExecute(r ApiV3SpacesGetRequest) (*V3SpacesGet200Response, *http.Response, error)

	/*
	V3SpacesGuidDelete Delete a space

	Delete a space by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3SpacesGuidDeleteRequest
	*/
	V3SpacesGuidDelete(ctx context.Context, guid string) ApiV3SpacesGuidDeleteRequest

	// V3SpacesGuidDeleteExecute executes the request
	V3SpacesGuidDeleteExecute(r ApiV3SpacesGuidDeleteRequest) (*http.Response, error)

	/*
	V3SpacesGuidFeaturesGet List space features

	Retrieve the list of features for the specified space. Currently, the only feature on spaces is the SSH feature.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3SpacesGuidFeaturesGetRequest
	*/
	V3SpacesGuidFeaturesGet(ctx context.Context, guid string) ApiV3SpacesGuidFeaturesGetRequest

	// V3SpacesGuidFeaturesGetExecute executes the request
	//  @return V3SpacesGuidFeaturesGet200Response
	V3SpacesGuidFeaturesGetExecute(r ApiV3SpacesGuidFeaturesGetRequest) (*V3SpacesGuidFeaturesGet200Response, *http.Response, error)

	/*
	V3SpacesGuidFeaturesNameGet Get a space feature

	Retrieve a space feature by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@param name
	@return ApiV3SpacesGuidFeaturesNameGetRequest
	*/
	V3SpacesGuidFeaturesNameGet(ctx context.Context, guid string, name string) ApiV3SpacesGuidFeaturesNameGetRequest

	// V3SpacesGuidFeaturesNameGetExecute executes the request
	//  @return SpaceFeature
	V3SpacesGuidFeaturesNameGetExecute(r ApiV3SpacesGuidFeaturesNameGetRequest) (*SpaceFeature, *http.Response, error)

	/*
	V3SpacesGuidFeaturesPatch Update space features

	Update a space feature.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@param name
	@return ApiV3SpacesGuidFeaturesPatchRequest
	*/
	V3SpacesGuidFeaturesPatch(ctx context.Context, guid string, name string) ApiV3SpacesGuidFeaturesPatchRequest

	// V3SpacesGuidFeaturesPatchExecute executes the request
	//  @return SpaceFeature
	V3SpacesGuidFeaturesPatchExecute(r ApiV3SpacesGuidFeaturesPatchRequest) (*SpaceFeature, *http.Response, error)

	/*
	V3SpacesGuidGet Get a space

	Retrieve a space by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3SpacesGuidGetRequest
	*/
	V3SpacesGuidGet(ctx context.Context, guid string) ApiV3SpacesGuidGetRequest

	// V3SpacesGuidGetExecute executes the request
	//  @return Space
	V3SpacesGuidGetExecute(r ApiV3SpacesGuidGetRequest) (*Space, *http.Response, error)

	/*
	V3SpacesGuidPatch Update a space

	Update a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3SpacesGuidPatchRequest
	*/
	V3SpacesGuidPatch(ctx context.Context, guid string) ApiV3SpacesGuidPatchRequest

	// V3SpacesGuidPatchExecute executes the request
	//  @return Space
	V3SpacesGuidPatchExecute(r ApiV3SpacesGuidPatchRequest) (*Space, *http.Response, error)

	/*
	V3SpacesGuidRelationshipsIsolationSegmentGet Get assigned isolation segment

	Retrieve the isolation segment assigned to the space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3SpacesGuidRelationshipsIsolationSegmentGetRequest
	*/
	V3SpacesGuidRelationshipsIsolationSegmentGet(ctx context.Context, guid string) ApiV3SpacesGuidRelationshipsIsolationSegmentGetRequest

	// V3SpacesGuidRelationshipsIsolationSegmentGetExecute executes the request
	//  @return V3AppsPostRequestRelationshipsSpace
	V3SpacesGuidRelationshipsIsolationSegmentGetExecute(r ApiV3SpacesGuidRelationshipsIsolationSegmentGetRequest) (*V3AppsPostRequestRelationshipsSpace, *http.Response, error)

	/*
	V3SpacesGuidRelationshipsIsolationSegmentPatch Manage isolation segment

	Assign or unassign an isolation segment to a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest
	*/
	V3SpacesGuidRelationshipsIsolationSegmentPatch(ctx context.Context, guid string) ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest

	// V3SpacesGuidRelationshipsIsolationSegmentPatchExecute executes the request
	//  @return V3AppsPostRequestRelationshipsSpace
	V3SpacesGuidRelationshipsIsolationSegmentPatchExecute(r ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest) (*V3AppsPostRequestRelationshipsSpace, *http.Response, error)

	/*
	V3SpacesGuidUsersGet List users for a space

	Retrieve all users with a role in the specified space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3SpacesGuidUsersGetRequest
	*/
	V3SpacesGuidUsersGet(ctx context.Context, guid string) ApiV3SpacesGuidUsersGetRequest

	// V3SpacesGuidUsersGetExecute executes the request
	//  @return V3SpacesGuidUsersGet200Response
	V3SpacesGuidUsersGetExecute(r ApiV3SpacesGuidUsersGetRequest) (*V3SpacesGuidUsersGet200Response, *http.Response, error)

	/*
	V3SpacesPost Create a space

	Create a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3SpacesPostRequest
	*/
	V3SpacesPost(ctx context.Context) ApiV3SpacesPostRequest

	// V3SpacesPostExecute executes the request
	//  @return Space
	V3SpacesPostExecute(r ApiV3SpacesPostRequest) (*Space, *http.Response, error)

	/*
	V3StacksGet List all stacks

	Retrieve all stacks.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3StacksGetRequest
	*/
	V3StacksGet(ctx context.Context) ApiV3StacksGetRequest

	// V3StacksGetExecute executes the request
	//  @return V3StacksGet200Response
	V3StacksGetExecute(r ApiV3StacksGetRequest) (*V3StacksGet200Response, *http.Response, error)

	/*
	V3StacksGuidAppsGet List apps on a stack

	Retrieve all apps using a given stack.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3StacksGuidAppsGetRequest
	*/
	V3StacksGuidAppsGet(ctx context.Context, guid string) ApiV3StacksGuidAppsGetRequest

	// V3StacksGuidAppsGetExecute executes the request
	//  @return V3StacksGuidAppsGet200Response
	V3StacksGuidAppsGetExecute(r ApiV3StacksGuidAppsGetRequest) (*V3StacksGuidAppsGet200Response, *http.Response, error)

	/*
	V3StacksGuidDelete Delete a stack

	Delete a stack by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3StacksGuidDeleteRequest
	*/
	V3StacksGuidDelete(ctx context.Context, guid string) ApiV3StacksGuidDeleteRequest

	// V3StacksGuidDeleteExecute executes the request
	V3StacksGuidDeleteExecute(r ApiV3StacksGuidDeleteRequest) (*http.Response, error)

	/*
	V3StacksGuidGet Get a stack by GUID

	Retrieve a stack by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3StacksGuidGetRequest
	*/
	V3StacksGuidGet(ctx context.Context, guid string) ApiV3StacksGuidGetRequest

	// V3StacksGuidGetExecute executes the request
	//  @return Stack
	V3StacksGuidGetExecute(r ApiV3StacksGuidGetRequest) (*Stack, *http.Response, error)

	/*
	V3StacksGuidPatch Update a stack

	Update the specified parameters of a stack.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3StacksGuidPatchRequest
	*/
	V3StacksGuidPatch(ctx context.Context, guid string) ApiV3StacksGuidPatchRequest

	// V3StacksGuidPatchExecute executes the request
	//  @return Stack
	V3StacksGuidPatchExecute(r ApiV3StacksGuidPatchRequest) (*Stack, *http.Response, error)

	/*
	V3StacksPost Create a stack

	Create a new stack.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3StacksPostRequest
	*/
	V3StacksPost(ctx context.Context) ApiV3StacksPostRequest

	// V3StacksPostExecute executes the request
	//  @return Stack
	V3StacksPostExecute(r ApiV3StacksPostRequest) (*Stack, *http.Response, error)

	/*
	V3TasksGet List all tasks

	Retrieve all tasks the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3TasksGetRequest
	*/
	V3TasksGet(ctx context.Context) ApiV3TasksGetRequest

	// V3TasksGetExecute executes the request
	//  @return V3TasksGet200Response
	V3TasksGetExecute(r ApiV3TasksGetRequest) (*V3TasksGet200Response, *http.Response, error)

	/*
	V3TasksGuidGet Get a task

	Retrieve a specific task by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3TasksGuidGetRequest
	*/
	V3TasksGuidGet(ctx context.Context, guid string) ApiV3TasksGuidGetRequest

	// V3TasksGuidGetExecute executes the request
	//  @return Task
	V3TasksGuidGetExecute(r ApiV3TasksGuidGetRequest) (*Task, *http.Response, error)

	/*
	V3TasksGuidPatch Update a task

	Update the specified parameters of a task.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3TasksGuidPatchRequest
	*/
	V3TasksGuidPatch(ctx context.Context, guid string) ApiV3TasksGuidPatchRequest

	// V3TasksGuidPatchExecute executes the request
	//  @return Task
	V3TasksGuidPatchExecute(r ApiV3TasksGuidPatchRequest) (*Task, *http.Response, error)

	/*
	V3TasksGuidPost Cancel a task

	Cancels a running task.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3TasksGuidPostRequest
	*/
	V3TasksGuidPost(ctx context.Context, guid string) ApiV3TasksGuidPostRequest

	// V3TasksGuidPostExecute executes the request
	//  @return Task
	V3TasksGuidPostExecute(r ApiV3TasksGuidPostRequest) (*Task, *http.Response, error)

	/*
	V3UsersGet List users

	Retrieve all users that the current user can see.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3UsersGetRequest
	*/
	V3UsersGet(ctx context.Context) ApiV3UsersGetRequest

	// V3UsersGetExecute executes the request
	//  @return V3UsersGet200Response
	V3UsersGetExecute(r ApiV3UsersGetRequest) (*V3UsersGet200Response, *http.Response, error)

	/*
	V3UsersGuidDelete Delete a user

	Delete a user by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid Unique identifier for the user
	@return ApiV3UsersGuidDeleteRequest
	*/
	V3UsersGuidDelete(ctx context.Context, guid string) ApiV3UsersGuidDeleteRequest

	// V3UsersGuidDeleteExecute executes the request
	V3UsersGuidDeleteExecute(r ApiV3UsersGuidDeleteRequest) (*http.Response, error)

	/*
	V3UsersGuidGet Get a user

	Retrieve a user by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid Unique identifier for the user
	@return ApiV3UsersGuidGetRequest
	*/
	V3UsersGuidGet(ctx context.Context, guid string) ApiV3UsersGuidGetRequest

	// V3UsersGuidGetExecute executes the request
	//  @return User
	V3UsersGuidGetExecute(r ApiV3UsersGuidGetRequest) (*User, *http.Response, error)

	/*
	V3UsersGuidPatch Update a user

	Update a user’s metadata.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid Unique identifier for the user
	@return ApiV3UsersGuidPatchRequest
	*/
	V3UsersGuidPatch(ctx context.Context, guid string) ApiV3UsersGuidPatchRequest

	// V3UsersGuidPatchExecute executes the request
	//  @return User
	V3UsersGuidPatchExecute(r ApiV3UsersGuidPatchRequest) (*User, *http.Response, error)

	/*
	V3UsersPost Create a user

	Creates a user in the Cloud Controller database.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3UsersPostRequest
	*/
	V3UsersPost(ctx context.Context) ApiV3UsersPostRequest

	// V3UsersPostExecute executes the request
	//  @return User
	V3UsersPostExecute(r ApiV3UsersPostRequest) (*User, *http.Response, error)
}

// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiApplyOrganizationQuotaToOrganizationsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	quotaGuid string
	applyOrganizationQuotaToOrganizationsRequest *ApplyOrganizationQuotaToOrganizationsRequest
}

func (r ApiApplyOrganizationQuotaToOrganizationsRequest) ApplyOrganizationQuotaToOrganizationsRequest(applyOrganizationQuotaToOrganizationsRequest ApplyOrganizationQuotaToOrganizationsRequest) ApiApplyOrganizationQuotaToOrganizationsRequest {
	r.applyOrganizationQuotaToOrganizationsRequest = &applyOrganizationQuotaToOrganizationsRequest
	return r
}

func (r ApiApplyOrganizationQuotaToOrganizationsRequest) Execute() (*ApplyOrganizationQuotaToOrganizations201Response, *http.Response, error) {
	return r.ApiService.ApplyOrganizationQuotaToOrganizationsExecute(r)
}

/*
ApplyOrganizationQuotaToOrganizations Apply an organization quota to organizations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param quotaGuid
 @return ApiApplyOrganizationQuotaToOrganizationsRequest
*/
func (a *DefaultAPIService) ApplyOrganizationQuotaToOrganizations(ctx context.Context, quotaGuid string) ApiApplyOrganizationQuotaToOrganizationsRequest {
	return ApiApplyOrganizationQuotaToOrganizationsRequest{
		ApiService: a,
		ctx: ctx,
		quotaGuid: quotaGuid,
	}
}

// Execute executes the request
//  @return ApplyOrganizationQuotaToOrganizations201Response
func (a *DefaultAPIService) ApplyOrganizationQuotaToOrganizationsExecute(r ApiApplyOrganizationQuotaToOrganizationsRequest) (*ApplyOrganizationQuotaToOrganizations201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApplyOrganizationQuotaToOrganizations201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApplyOrganizationQuotaToOrganizations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organization_quotas/{quota_guid}/relationships/organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"quota_guid"+"}", url.PathEscape(parameterValueToString(r.quotaGuid, "quotaGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.applyOrganizationQuotaToOrganizationsRequest == nil {
		return localVarReturnValue, nil, reportError("applyOrganizationQuotaToOrganizationsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.applyOrganizationQuotaToOrganizationsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAssignDefaultIsolationSegmentRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3AppsPostRequestRelationshipsSpace *V3AppsPostRequestRelationshipsSpace
}

func (r ApiAssignDefaultIsolationSegmentRequest) V3AppsPostRequestRelationshipsSpace(v3AppsPostRequestRelationshipsSpace V3AppsPostRequestRelationshipsSpace) ApiAssignDefaultIsolationSegmentRequest {
	r.v3AppsPostRequestRelationshipsSpace = &v3AppsPostRequestRelationshipsSpace
	return r
}

func (r ApiAssignDefaultIsolationSegmentRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AssignDefaultIsolationSegmentExecute(r)
}

/*
AssignDefaultIsolationSegment Assign Default Isolation Segment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiAssignDefaultIsolationSegmentRequest
*/
func (a *DefaultAPIService) AssignDefaultIsolationSegment(ctx context.Context, guid string) ApiAssignDefaultIsolationSegmentRequest {
	return ApiAssignDefaultIsolationSegmentRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) AssignDefaultIsolationSegmentExecute(r ApiAssignDefaultIsolationSegmentRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.AssignDefaultIsolationSegment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations/{guid}/relationships/default_isolation_segment"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3AppsPostRequestRelationshipsSpace
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrganizationRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	createOrganizationRequest *CreateOrganizationRequest
}

func (r ApiCreateOrganizationRequest) CreateOrganizationRequest(createOrganizationRequest CreateOrganizationRequest) ApiCreateOrganizationRequest {
	r.createOrganizationRequest = &createOrganizationRequest
	return r
}

func (r ApiCreateOrganizationRequest) Execute() (*Organization, *http.Response, error) {
	return r.ApiService.CreateOrganizationExecute(r)
}

/*
CreateOrganization Create an Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrganizationRequest
*/
func (a *DefaultAPIService) CreateOrganization(ctx context.Context) ApiCreateOrganizationRequest {
	return ApiCreateOrganizationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Organization
func (a *DefaultAPIService) CreateOrganizationExecute(r ApiCreateOrganizationRequest) (*Organization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrganizationRequest == nil {
		return localVarReturnValue, nil, reportError("createOrganizationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrganizationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrganizationQuotaRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	createOrganizationQuotaRequest *CreateOrganizationQuotaRequest
}

func (r ApiCreateOrganizationQuotaRequest) CreateOrganizationQuotaRequest(createOrganizationQuotaRequest CreateOrganizationQuotaRequest) ApiCreateOrganizationQuotaRequest {
	r.createOrganizationQuotaRequest = &createOrganizationQuotaRequest
	return r
}

func (r ApiCreateOrganizationQuotaRequest) Execute() (*OrganizationQuota, *http.Response, error) {
	return r.ApiService.CreateOrganizationQuotaExecute(r)
}

/*
CreateOrganizationQuota Create an organization quota

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrganizationQuotaRequest
*/
func (a *DefaultAPIService) CreateOrganizationQuota(ctx context.Context) ApiCreateOrganizationQuotaRequest {
	return ApiCreateOrganizationQuotaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OrganizationQuota
func (a *DefaultAPIService) CreateOrganizationQuotaExecute(r ApiCreateOrganizationQuotaRequest) (*OrganizationQuota, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationQuota
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateOrganizationQuota")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organization_quotas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrganizationQuotaRequest == nil {
		return localVarReturnValue, nil, reportError("createOrganizationQuotaRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrganizationQuotaRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOrganizationRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiDeleteOrganizationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteOrganizationExecute(r)
}

/*
DeleteOrganization Delete an Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiDeleteOrganizationRequest
*/
func (a *DefaultAPIService) DeleteOrganization(ctx context.Context, guid string) ApiDeleteOrganizationRequest {
	return ApiDeleteOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) DeleteOrganizationExecute(r ApiDeleteOrganizationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOrganizationQuotaRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiDeleteOrganizationQuotaRequest) Execute() (*DeleteOrganizationQuota202Response, *http.Response, error) {
	return r.ApiService.DeleteOrganizationQuotaExecute(r)
}

/*
DeleteOrganizationQuota Delete an organization quota

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiDeleteOrganizationQuotaRequest
*/
func (a *DefaultAPIService) DeleteOrganizationQuota(ctx context.Context, guid string) ApiDeleteOrganizationQuotaRequest {
	return ApiDeleteOrganizationQuotaRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return DeleteOrganizationQuota202Response
func (a *DefaultAPIService) DeleteOrganizationQuotaExecute(r ApiDeleteOrganizationQuotaRequest) (*DeleteOrganizationQuota202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteOrganizationQuota202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteOrganizationQuota")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organization_quotas/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDefaultDomainRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiGetDefaultDomainRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDefaultDomainExecute(r)
}

/*
GetDefaultDomain Get Default Domain

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiGetDefaultDomainRequest
*/
func (a *DefaultAPIService) GetDefaultDomain(ctx context.Context, guid string) ApiGetDefaultDomainRequest {
	return ApiGetDefaultDomainRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) GetDefaultDomainExecute(r ApiGetDefaultDomainRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetDefaultDomain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations/{guid}/domains/default"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDefaultIsolationSegmentRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiGetDefaultIsolationSegmentRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDefaultIsolationSegmentExecute(r)
}

/*
GetDefaultIsolationSegment Get Default Isolation Segment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiGetDefaultIsolationSegmentRequest
*/
func (a *DefaultAPIService) GetDefaultIsolationSegment(ctx context.Context, guid string) ApiGetDefaultIsolationSegmentRequest {
	return ApiGetDefaultIsolationSegmentRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) GetDefaultIsolationSegmentExecute(r ApiGetDefaultIsolationSegmentRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetDefaultIsolationSegment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations/{guid}/relationships/default_isolation_segment"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrganizationRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiGetOrganizationRequest) Execute() (*Organization, *http.Response, error) {
	return r.ApiService.GetOrganizationExecute(r)
}

/*
GetOrganization Get an Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiGetOrganizationRequest
*/
func (a *DefaultAPIService) GetOrganization(ctx context.Context, guid string) ApiGetOrganizationRequest {
	return ApiGetOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Organization
func (a *DefaultAPIService) GetOrganizationExecute(r ApiGetOrganizationRequest) (*Organization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrganizationQuotaRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiGetOrganizationQuotaRequest) Execute() (*OrganizationQuota, *http.Response, error) {
	return r.ApiService.GetOrganizationQuotaExecute(r)
}

/*
GetOrganizationQuota Get an organization quota

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiGetOrganizationQuotaRequest
*/
func (a *DefaultAPIService) GetOrganizationQuota(ctx context.Context, guid string) ApiGetOrganizationQuotaRequest {
	return ApiGetOrganizationQuotaRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return OrganizationQuota
func (a *DefaultAPIService) GetOrganizationQuotaExecute(r ApiGetOrganizationQuotaRequest) (*OrganizationQuota, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationQuota
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetOrganizationQuota")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organization_quotas/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsageSummaryRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiGetUsageSummaryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUsageSummaryExecute(r)
}

/*
GetUsageSummary Get Usage Summary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiGetUsageSummaryRequest
*/
func (a *DefaultAPIService) GetUsageSummary(ctx context.Context, guid string) ApiGetUsageSummaryRequest {
	return ApiGetUsageSummaryRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) GetUsageSummaryExecute(r ApiGetUsageSummaryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetUsageSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations/{guid}/usage_summary"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOrganizationQuotasRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guids *[]string
	names *[]string
	organizationGuids *[]string
	page *int32
	perPage *int32
	orderBy *string
	createdAts *time.Time
	updatedAts *time.Time
}

func (r ApiListOrganizationQuotasRequest) Guids(guids []string) ApiListOrganizationQuotasRequest {
	r.guids = &guids
	return r
}

func (r ApiListOrganizationQuotasRequest) Names(names []string) ApiListOrganizationQuotasRequest {
	r.names = &names
	return r
}

func (r ApiListOrganizationQuotasRequest) OrganizationGuids(organizationGuids []string) ApiListOrganizationQuotasRequest {
	r.organizationGuids = &organizationGuids
	return r
}

func (r ApiListOrganizationQuotasRequest) Page(page int32) ApiListOrganizationQuotasRequest {
	r.page = &page
	return r
}

func (r ApiListOrganizationQuotasRequest) PerPage(perPage int32) ApiListOrganizationQuotasRequest {
	r.perPage = &perPage
	return r
}

func (r ApiListOrganizationQuotasRequest) OrderBy(orderBy string) ApiListOrganizationQuotasRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiListOrganizationQuotasRequest) CreatedAts(createdAts time.Time) ApiListOrganizationQuotasRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiListOrganizationQuotasRequest) UpdatedAts(updatedAts time.Time) ApiListOrganizationQuotasRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiListOrganizationQuotasRequest) Execute() (*ListOrganizationQuotas200Response, *http.Response, error) {
	return r.ApiService.ListOrganizationQuotasExecute(r)
}

/*
ListOrganizationQuotas List organization quotas

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListOrganizationQuotasRequest
*/
func (a *DefaultAPIService) ListOrganizationQuotas(ctx context.Context) ApiListOrganizationQuotasRequest {
	return ApiListOrganizationQuotasRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListOrganizationQuotas200Response
func (a *DefaultAPIService) ListOrganizationQuotasExecute(r ApiListOrganizationQuotasRequest) (*ListOrganizationQuotas200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOrganizationQuotas200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListOrganizationQuotas")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organization_quotas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		t := *r.guids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guids", t, "form", "multi")
		}
	}
	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.organizationGuids != nil {
		t := *r.organizationGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", t, "form", "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOrganizationsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	names *string
	guids *string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

func (r ApiListOrganizationsRequest) Names(names string) ApiListOrganizationsRequest {
	r.names = &names
	return r
}

func (r ApiListOrganizationsRequest) Guids(guids string) ApiListOrganizationsRequest {
	r.guids = &guids
	return r
}

func (r ApiListOrganizationsRequest) Page(page int32) ApiListOrganizationsRequest {
	r.page = &page
	return r
}

func (r ApiListOrganizationsRequest) PerPage(perPage int32) ApiListOrganizationsRequest {
	r.perPage = &perPage
	return r
}

func (r ApiListOrganizationsRequest) OrderBy(orderBy string) ApiListOrganizationsRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiListOrganizationsRequest) LabelSelector(labelSelector string) ApiListOrganizationsRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiListOrganizationsRequest) CreatedAts(createdAts string) ApiListOrganizationsRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiListOrganizationsRequest) UpdatedAts(updatedAts string) ApiListOrganizationsRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiListOrganizationsRequest) Execute() ([]Organization, *http.Response, error) {
	return r.ApiService.ListOrganizationsExecute(r)
}

/*
ListOrganizations List Organizations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListOrganizationsRequest
*/
func (a *DefaultAPIService) ListOrganizations(ctx context.Context) ApiListOrganizationsRequest {
	return ApiListOrganizationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Organization
func (a *DefaultAPIService) ListOrganizationsExecute(r ApiListOrganizationsRequest) ([]Organization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListOrganizations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.names != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "names", r.names, "form", "")
	}
	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUsersForOrganizationRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	guids *string
	usernames *string
	partialUsernames *string
	origins *string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

func (r ApiListUsersForOrganizationRequest) Guids(guids string) ApiListUsersForOrganizationRequest {
	r.guids = &guids
	return r
}

func (r ApiListUsersForOrganizationRequest) Usernames(usernames string) ApiListUsersForOrganizationRequest {
	r.usernames = &usernames
	return r
}

func (r ApiListUsersForOrganizationRequest) PartialUsernames(partialUsernames string) ApiListUsersForOrganizationRequest {
	r.partialUsernames = &partialUsernames
	return r
}

func (r ApiListUsersForOrganizationRequest) Origins(origins string) ApiListUsersForOrganizationRequest {
	r.origins = &origins
	return r
}

func (r ApiListUsersForOrganizationRequest) Page(page int32) ApiListUsersForOrganizationRequest {
	r.page = &page
	return r
}

func (r ApiListUsersForOrganizationRequest) PerPage(perPage int32) ApiListUsersForOrganizationRequest {
	r.perPage = &perPage
	return r
}

func (r ApiListUsersForOrganizationRequest) OrderBy(orderBy string) ApiListUsersForOrganizationRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiListUsersForOrganizationRequest) LabelSelector(labelSelector string) ApiListUsersForOrganizationRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiListUsersForOrganizationRequest) CreatedAts(createdAts string) ApiListUsersForOrganizationRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiListUsersForOrganizationRequest) UpdatedAts(updatedAts string) ApiListUsersForOrganizationRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiListUsersForOrganizationRequest) Execute() ([]User, *http.Response, error) {
	return r.ApiService.ListUsersForOrganizationExecute(r)
}

/*
ListUsersForOrganization List Users for an Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiListUsersForOrganizationRequest
*/
func (a *DefaultAPIService) ListUsersForOrganization(ctx context.Context, guid string) ApiListUsersForOrganizationRequest {
	return ApiListUsersForOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return []User
func (a *DefaultAPIService) ListUsersForOrganizationExecute(r ApiListUsersForOrganizationRequest) ([]User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListUsersForOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations/{guid}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "")
	}
	if r.usernames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usernames", r.usernames, "form", "")
	}
	if r.partialUsernames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partial_usernames", r.partialUsernames, "form", "")
	}
	if r.origins != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origins", r.origins, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRootGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiRootGetRequest) Execute() (*Get200Response, *http.Response, error) {
	return r.ApiService.RootGetExecute(r)
}

/*
RootGet Global API Root

Returns links to the APIs available on a given Cloud Foundry deployment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRootGetRequest
*/
func (a *DefaultAPIService) RootGet(ctx context.Context) ApiRootGetRequest {
	return ApiRootGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Get200Response
func (a *DefaultAPIService) RootGetExecute(r ApiRootGetRequest) (*Get200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Get200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RootGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOrganizationRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	updateOrganizationRequest *UpdateOrganizationRequest
}

func (r ApiUpdateOrganizationRequest) UpdateOrganizationRequest(updateOrganizationRequest UpdateOrganizationRequest) ApiUpdateOrganizationRequest {
	r.updateOrganizationRequest = &updateOrganizationRequest
	return r
}

func (r ApiUpdateOrganizationRequest) Execute() (*Organization, *http.Response, error) {
	return r.ApiService.UpdateOrganizationExecute(r)
}

/*
UpdateOrganization Update an Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiUpdateOrganizationRequest
*/
func (a *DefaultAPIService) UpdateOrganization(ctx context.Context, guid string) ApiUpdateOrganizationRequest {
	return ApiUpdateOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Organization
func (a *DefaultAPIService) UpdateOrganizationExecute(r ApiUpdateOrganizationRequest) (*Organization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UpdateOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateOrganizationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOrganizationQuotaRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	updateOrganizationQuotaRequest *UpdateOrganizationQuotaRequest
}

func (r ApiUpdateOrganizationQuotaRequest) UpdateOrganizationQuotaRequest(updateOrganizationQuotaRequest UpdateOrganizationQuotaRequest) ApiUpdateOrganizationQuotaRequest {
	r.updateOrganizationQuotaRequest = &updateOrganizationQuotaRequest
	return r
}

func (r ApiUpdateOrganizationQuotaRequest) Execute() (*OrganizationQuota, *http.Response, error) {
	return r.ApiService.UpdateOrganizationQuotaExecute(r)
}

/*
UpdateOrganizationQuota Update an organization quota

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiUpdateOrganizationQuotaRequest
*/
func (a *DefaultAPIService) UpdateOrganizationQuota(ctx context.Context, guid string) ApiUpdateOrganizationQuotaRequest {
	return ApiUpdateOrganizationQuotaRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return OrganizationQuota
func (a *DefaultAPIService) UpdateOrganizationQuotaExecute(r ApiUpdateOrganizationQuotaRequest) (*OrganizationQuota, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationQuota
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UpdateOrganizationQuota")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organization_quotas/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateOrganizationQuotaRequest == nil {
		return localVarReturnValue, nil, reportError("updateOrganizationQuotaRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateOrganizationQuotaRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AdminActionsClearBuildpackCachePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiV3AdminActionsClearBuildpackCachePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3AdminActionsClearBuildpackCachePostExecute(r)
}

/*
V3AdminActionsClearBuildpackCachePost Clear buildpack cache

This endpoint will delete all of the existing buildpack caches in the blobstore.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3AdminActionsClearBuildpackCachePostRequest
*/
func (a *DefaultAPIService) V3AdminActionsClearBuildpackCachePost(ctx context.Context) ApiV3AdminActionsClearBuildpackCachePostRequest {
	return ApiV3AdminActionsClearBuildpackCachePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3AdminActionsClearBuildpackCachePostExecute(r ApiV3AdminActionsClearBuildpackCachePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AdminActionsClearBuildpackCachePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/admin/actions/clear_buildpack_cache"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3AppsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	page *int32
	perPage *int32
	orderBy *string
	names *string
	guids *string
	organizationGuids *string
	spaceGuids *string
	stacks *string
	include *string
	lifecycleType *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

// Page number for pagination.
func (r ApiV3AppsGetRequest) Page(page int32) ApiV3AppsGetRequest {
	r.page = &page
	return r
}

// Number of results per page.
func (r ApiV3AppsGetRequest) PerPage(perPage int32) ApiV3AppsGetRequest {
	r.perPage = &perPage
	return r
}

// Field by which to order results.
func (r ApiV3AppsGetRequest) OrderBy(orderBy string) ApiV3AppsGetRequest {
	r.orderBy = &orderBy
	return r
}

// Filter results by app names.
func (r ApiV3AppsGetRequest) Names(names string) ApiV3AppsGetRequest {
	r.names = &names
	return r
}

// Filter results by app GUIDs.
func (r ApiV3AppsGetRequest) Guids(guids string) ApiV3AppsGetRequest {
	r.guids = &guids
	return r
}

// Filter results by organization GUIDs.
func (r ApiV3AppsGetRequest) OrganizationGuids(organizationGuids string) ApiV3AppsGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

// Filter results by space GUIDs.
func (r ApiV3AppsGetRequest) SpaceGuids(spaceGuids string) ApiV3AppsGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

// Filter results by stack names.
func (r ApiV3AppsGetRequest) Stacks(stacks string) ApiV3AppsGetRequest {
	r.stacks = &stacks
	return r
}

// Include related resources in the response.
func (r ApiV3AppsGetRequest) Include(include string) ApiV3AppsGetRequest {
	r.include = &include
	return r
}

// Filter results by lifecycle type.
func (r ApiV3AppsGetRequest) LifecycleType(lifecycleType string) ApiV3AppsGetRequest {
	r.lifecycleType = &lifecycleType
	return r
}

// Filter results by label selector.
func (r ApiV3AppsGetRequest) LabelSelector(labelSelector string) ApiV3AppsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Filter results by creation timestamps.
func (r ApiV3AppsGetRequest) CreatedAts(createdAts string) ApiV3AppsGetRequest {
	r.createdAts = &createdAts
	return r
}

// Filter results by update timestamps.
func (r ApiV3AppsGetRequest) UpdatedAts(updatedAts string) ApiV3AppsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3AppsGetRequest) Execute() (*App, *http.Response, error) {
	return r.ApiService.V3AppsGetExecute(r)
}

/*
V3AppsGet List apps

Retrieve a list of all apps.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3AppsGetRequest
*/
func (a *DefaultAPIService) V3AppsGet(ctx context.Context) ApiV3AppsGetRequest {
	return ApiV3AppsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return App
func (a *DefaultAPIService) V3AppsGetExecute(r ApiV3AppsGetRequest) (*App, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *App
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.names != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "names", r.names, "form", "")
	}
	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "")
	}
	if r.organizationGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", r.organizationGuids, "form", "")
	}
	if r.spaceGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", r.spaceGuids, "form", "")
	}
	if r.stacks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stacks", r.stacks, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "")
	}
	if r.lifecycleType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lifecycle_type", r.lifecycleType, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidActionsClearBuildpackCachePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3AppsGuidActionsClearBuildpackCachePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3AppsGuidActionsClearBuildpackCachePostExecute(r)
}

/*
V3AppsGuidActionsClearBuildpackCachePost Clear buildpack cache for application

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3AppsGuidActionsClearBuildpackCachePostRequest
*/
func (a *DefaultAPIService) V3AppsGuidActionsClearBuildpackCachePost(ctx context.Context, guid string) ApiV3AppsGuidActionsClearBuildpackCachePostRequest {
	return ApiV3AppsGuidActionsClearBuildpackCachePostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3AppsGuidActionsClearBuildpackCachePostExecute(r ApiV3AppsGuidActionsClearBuildpackCachePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidActionsClearBuildpackCachePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/actions/clear_buildpack_cache"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3AppsGuidActionsRestartPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3AppsGuidActionsRestartPostRequest) Execute() (*V3AppsGuidActionsRestartPost200Response, *http.Response, error) {
	return r.ApiService.V3AppsGuidActionsRestartPostExecute(r)
}

/*
V3AppsGuidActionsRestartPost Restart an app

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3AppsGuidActionsRestartPostRequest
*/
func (a *DefaultAPIService) V3AppsGuidActionsRestartPost(ctx context.Context, guid string) ApiV3AppsGuidActionsRestartPostRequest {
	return ApiV3AppsGuidActionsRestartPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidActionsRestartPost200Response
func (a *DefaultAPIService) V3AppsGuidActionsRestartPostExecute(r ApiV3AppsGuidActionsRestartPostRequest) (*V3AppsGuidActionsRestartPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidActionsRestartPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidActionsRestartPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/actions/restart"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidActionsStartPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3AppsGuidActionsStartPostRequest) Execute() (*V3AppsGuidActionsRestartPost200Response, *http.Response, error) {
	return r.ApiService.V3AppsGuidActionsStartPostExecute(r)
}

/*
V3AppsGuidActionsStartPost Start an app

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3AppsGuidActionsStartPostRequest
*/
func (a *DefaultAPIService) V3AppsGuidActionsStartPost(ctx context.Context, guid string) ApiV3AppsGuidActionsStartPostRequest {
	return ApiV3AppsGuidActionsStartPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidActionsRestartPost200Response
func (a *DefaultAPIService) V3AppsGuidActionsStartPostExecute(r ApiV3AppsGuidActionsStartPostRequest) (*V3AppsGuidActionsRestartPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidActionsRestartPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidActionsStartPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/actions/start"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidActionsStopPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3AppsGuidActionsStopPostRequest) Execute() (*V3AppsGuidActionsRestartPost200Response, *http.Response, error) {
	return r.ApiService.V3AppsGuidActionsStopPostExecute(r)
}

/*
V3AppsGuidActionsStopPost Stop an app

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3AppsGuidActionsStopPostRequest
*/
func (a *DefaultAPIService) V3AppsGuidActionsStopPost(ctx context.Context, guid string) ApiV3AppsGuidActionsStopPostRequest {
	return ApiV3AppsGuidActionsStopPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidActionsRestartPost200Response
func (a *DefaultAPIService) V3AppsGuidActionsStopPostExecute(r ApiV3AppsGuidActionsStopPostRequest) (*V3AppsGuidActionsRestartPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidActionsRestartPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidActionsStopPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/actions/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidBuildsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3AppsGuidBuildsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3AppsGuidBuildsGetExecute(r)
}

/*
V3AppsGuidBuildsGet List builds for an app

Retrieve all builds for the app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the app.
 @return ApiV3AppsGuidBuildsGetRequest
*/
func (a *DefaultAPIService) V3AppsGuidBuildsGet(ctx context.Context, guid string) ApiV3AppsGuidBuildsGetRequest {
	return ApiV3AppsGuidBuildsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3AppsGuidBuildsGetExecute(r ApiV3AppsGuidBuildsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidBuildsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3AppsGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3AppsGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3AppsGuidDeleteExecute(r)
}

/*
V3AppsGuidDelete Delete an app

Delete the specified app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the app.
 @return ApiV3AppsGuidDeleteRequest
*/
func (a *DefaultAPIService) V3AppsGuidDelete(ctx context.Context, guid string) ApiV3AppsGuidDeleteRequest {
	return ApiV3AppsGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3AppsGuidDeleteExecute(r ApiV3AppsGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3AppsGuidDropletsCurrentGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3AppsGuidDropletsCurrentGetRequest) Execute() (*V3AppsGuidDropletsCurrentGet200Response, *http.Response, error) {
	return r.ApiService.V3AppsGuidDropletsCurrentGetExecute(r)
}

/*
V3AppsGuidDropletsCurrentGet Get current droplet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3AppsGuidDropletsCurrentGetRequest
*/
func (a *DefaultAPIService) V3AppsGuidDropletsCurrentGet(ctx context.Context, guid string) ApiV3AppsGuidDropletsCurrentGetRequest {
	return ApiV3AppsGuidDropletsCurrentGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidDropletsCurrentGet200Response
func (a *DefaultAPIService) V3AppsGuidDropletsCurrentGetExecute(r ApiV3AppsGuidDropletsCurrentGetRequest) (*V3AppsGuidDropletsCurrentGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidDropletsCurrentGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidDropletsCurrentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/droplets/current"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidDropletsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	guids *[]string
	states *[]string
	current *bool
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
}

// Comma-delimited list of droplet guids to filter by
func (r ApiV3AppsGuidDropletsGetRequest) Guids(guids []string) ApiV3AppsGuidDropletsGetRequest {
	r.guids = &guids
	return r
}

// Comma-delimited list of droplet states to filter by
func (r ApiV3AppsGuidDropletsGetRequest) States(states []string) ApiV3AppsGuidDropletsGetRequest {
	r.states = &states
	return r
}

// If true, only include the droplet currently assigned to the app
func (r ApiV3AppsGuidDropletsGetRequest) Current(current bool) ApiV3AppsGuidDropletsGetRequest {
	r.current = &current
	return r
}

// Page to display
func (r ApiV3AppsGuidDropletsGetRequest) Page(page int32) ApiV3AppsGuidDropletsGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3AppsGuidDropletsGetRequest) PerPage(perPage int32) ApiV3AppsGuidDropletsGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by
func (r ApiV3AppsGuidDropletsGetRequest) OrderBy(orderBy string) ApiV3AppsGuidDropletsGetRequest {
	r.orderBy = &orderBy
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3AppsGuidDropletsGetRequest) LabelSelector(labelSelector string) ApiV3AppsGuidDropletsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3AppsGuidDropletsGetRequest) Execute() (*V3AppsGuidDropletsGet200Response, *http.Response, error) {
	return r.ApiService.V3AppsGuidDropletsGetExecute(r)
}

/*
V3AppsGuidDropletsGet List droplets for an app

Retrieve a list of droplets belonging to an app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the app
 @return ApiV3AppsGuidDropletsGetRequest
*/
func (a *DefaultAPIService) V3AppsGuidDropletsGet(ctx context.Context, guid string) ApiV3AppsGuidDropletsGetRequest {
	return ApiV3AppsGuidDropletsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidDropletsGet200Response
func (a *DefaultAPIService) V3AppsGuidDropletsGetExecute(r ApiV3AppsGuidDropletsGetRequest) (*V3AppsGuidDropletsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidDropletsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidDropletsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/droplets"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		t := *r.guids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guids", t, "form", "multi")
		}
	}
	if r.states != nil {
		t := *r.states
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "states", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "states", t, "form", "multi")
		}
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidEnvGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3AppsGuidEnvGetRequest) Execute() (*V3AppsGuidEnvGet200Response, *http.Response, error) {
	return r.ApiService.V3AppsGuidEnvGetExecute(r)
}

/*
V3AppsGuidEnvGet Get environment for an app

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3AppsGuidEnvGetRequest
*/
func (a *DefaultAPIService) V3AppsGuidEnvGet(ctx context.Context, guid string) ApiV3AppsGuidEnvGetRequest {
	return ApiV3AppsGuidEnvGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidEnvGet200Response
func (a *DefaultAPIService) V3AppsGuidEnvGetExecute(r ApiV3AppsGuidEnvGetRequest) (*V3AppsGuidEnvGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidEnvGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidEnvGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/env"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidEnvironmentVariablesGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3AppsGuidEnvironmentVariablesGetRequest) Execute() (*V3AppsGuidEnvironmentVariablesGet200Response, *http.Response, error) {
	return r.ApiService.V3AppsGuidEnvironmentVariablesGetExecute(r)
}

/*
V3AppsGuidEnvironmentVariablesGet Get environment variables for an app

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3AppsGuidEnvironmentVariablesGetRequest
*/
func (a *DefaultAPIService) V3AppsGuidEnvironmentVariablesGet(ctx context.Context, guid string) ApiV3AppsGuidEnvironmentVariablesGetRequest {
	return ApiV3AppsGuidEnvironmentVariablesGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidEnvironmentVariablesGet200Response
func (a *DefaultAPIService) V3AppsGuidEnvironmentVariablesGetExecute(r ApiV3AppsGuidEnvironmentVariablesGetRequest) (*V3AppsGuidEnvironmentVariablesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidEnvironmentVariablesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidEnvironmentVariablesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/environment_variables"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidEnvironmentVariablesPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3AppsGuidEnvironmentVariablesPatchRequest *V3AppsGuidEnvironmentVariablesPatchRequest
}

func (r ApiV3AppsGuidEnvironmentVariablesPatchRequest) V3AppsGuidEnvironmentVariablesPatchRequest(v3AppsGuidEnvironmentVariablesPatchRequest V3AppsGuidEnvironmentVariablesPatchRequest) ApiV3AppsGuidEnvironmentVariablesPatchRequest {
	r.v3AppsGuidEnvironmentVariablesPatchRequest = &v3AppsGuidEnvironmentVariablesPatchRequest
	return r
}

func (r ApiV3AppsGuidEnvironmentVariablesPatchRequest) Execute() (*V3AppsGuidEnvironmentVariablesGet200Response, *http.Response, error) {
	return r.ApiService.V3AppsGuidEnvironmentVariablesPatchExecute(r)
}

/*
V3AppsGuidEnvironmentVariablesPatch Update environment variables for an app

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3AppsGuidEnvironmentVariablesPatchRequest
*/
func (a *DefaultAPIService) V3AppsGuidEnvironmentVariablesPatch(ctx context.Context, guid string) ApiV3AppsGuidEnvironmentVariablesPatchRequest {
	return ApiV3AppsGuidEnvironmentVariablesPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidEnvironmentVariablesGet200Response
func (a *DefaultAPIService) V3AppsGuidEnvironmentVariablesPatchExecute(r ApiV3AppsGuidEnvironmentVariablesPatchRequest) (*V3AppsGuidEnvironmentVariablesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidEnvironmentVariablesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidEnvironmentVariablesPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/environment_variables"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3AppsGuidEnvironmentVariablesPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3AppsGuidEnvironmentVariablesPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3AppsGuidEnvironmentVariablesPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidFeaturesGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3AppsGuidFeaturesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3AppsGuidFeaturesGetExecute(r)
}

/*
V3AppsGuidFeaturesGet List app features

Retrieves the list of features for the specified app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the app.
 @return ApiV3AppsGuidFeaturesGetRequest
*/
func (a *DefaultAPIService) V3AppsGuidFeaturesGet(ctx context.Context, guid string) ApiV3AppsGuidFeaturesGetRequest {
	return ApiV3AppsGuidFeaturesGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3AppsGuidFeaturesGetExecute(r ApiV3AppsGuidFeaturesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidFeaturesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3AppsGuidFeaturesNameGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	name string
}

func (r ApiV3AppsGuidFeaturesNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3AppsGuidFeaturesNameGetExecute(r)
}

/*
V3AppsGuidFeaturesNameGet Get an app feature

Retrieves a specific feature for the specified app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the app.
 @param name The name of the feature.
 @return ApiV3AppsGuidFeaturesNameGetRequest
*/
func (a *DefaultAPIService) V3AppsGuidFeaturesNameGet(ctx context.Context, guid string, name string) ApiV3AppsGuidFeaturesNameGetRequest {
	return ApiV3AppsGuidFeaturesNameGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3AppsGuidFeaturesNameGetExecute(r ApiV3AppsGuidFeaturesNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidFeaturesNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/features/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3AppsGuidFeaturesNamePatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	name string
	v3AppsGuidFeaturesNamePatchRequest *V3AppsGuidFeaturesNamePatchRequest
}

func (r ApiV3AppsGuidFeaturesNamePatchRequest) V3AppsGuidFeaturesNamePatchRequest(v3AppsGuidFeaturesNamePatchRequest V3AppsGuidFeaturesNamePatchRequest) ApiV3AppsGuidFeaturesNamePatchRequest {
	r.v3AppsGuidFeaturesNamePatchRequest = &v3AppsGuidFeaturesNamePatchRequest
	return r
}

func (r ApiV3AppsGuidFeaturesNamePatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3AppsGuidFeaturesNamePatchExecute(r)
}

/*
V3AppsGuidFeaturesNamePatch Update an app feature

Updates a specific feature for the specified app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the app.
 @param name The name of the feature.
 @return ApiV3AppsGuidFeaturesNamePatchRequest
*/
func (a *DefaultAPIService) V3AppsGuidFeaturesNamePatch(ctx context.Context, guid string, name string) ApiV3AppsGuidFeaturesNamePatchRequest {
	return ApiV3AppsGuidFeaturesNamePatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3AppsGuidFeaturesNamePatchExecute(r ApiV3AppsGuidFeaturesNamePatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidFeaturesNamePatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/features/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3AppsGuidFeaturesNamePatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3AppsGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	include *[]string
}

// Include related resources in the response; valid values are space and space.organization.
func (r ApiV3AppsGuidGetRequest) Include(include []string) ApiV3AppsGuidGetRequest {
	r.include = &include
	return r
}

func (r ApiV3AppsGuidGetRequest) Execute() (*App, *http.Response, error) {
	return r.ApiService.V3AppsGuidGetExecute(r)
}

/*
V3AppsGuidGet Retrieve a specific app

Retrieve a specific app by its GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the app.
 @return ApiV3AppsGuidGetRequest
*/
func (a *DefaultAPIService) V3AppsGuidGet(ctx context.Context, guid string) ApiV3AppsGuidGetRequest {
	return ApiV3AppsGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return App
func (a *DefaultAPIService) V3AppsGuidGetExecute(r ApiV3AppsGuidGetRequest) (*App, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *App
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		t := *r.include
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "include", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "include", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3AppsGuidPatchRequest *V3AppsGuidPatchRequest
}

func (r ApiV3AppsGuidPatchRequest) V3AppsGuidPatchRequest(v3AppsGuidPatchRequest V3AppsGuidPatchRequest) ApiV3AppsGuidPatchRequest {
	r.v3AppsGuidPatchRequest = &v3AppsGuidPatchRequest
	return r
}

func (r ApiV3AppsGuidPatchRequest) Execute() (*App, *http.Response, error) {
	return r.ApiService.V3AppsGuidPatchExecute(r)
}

/*
V3AppsGuidPatch Update an app

Update an existing app by its GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the app.
 @return ApiV3AppsGuidPatchRequest
*/
func (a *DefaultAPIService) V3AppsGuidPatch(ctx context.Context, guid string) ApiV3AppsGuidPatchRequest {
	return ApiV3AppsGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return App
func (a *DefaultAPIService) V3AppsGuidPatchExecute(r ApiV3AppsGuidPatchRequest) (*App, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *App
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3AppsGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidPermissionsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3AppsGuidPermissionsGetRequest) Execute() (*V3AppsGuidPermissionsGet200Response, *http.Response, error) {
	return r.ApiService.V3AppsGuidPermissionsGetExecute(r)
}

/*
V3AppsGuidPermissionsGet Get permissions for an app

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3AppsGuidPermissionsGetRequest
*/
func (a *DefaultAPIService) V3AppsGuidPermissionsGet(ctx context.Context, guid string) ApiV3AppsGuidPermissionsGetRequest {
	return ApiV3AppsGuidPermissionsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidPermissionsGet200Response
func (a *DefaultAPIService) V3AppsGuidPermissionsGetExecute(r ApiV3AppsGuidPermissionsGetRequest) (*V3AppsGuidPermissionsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidPermissionsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidPermissionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidProcessesGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	guids *string
	types *string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

func (r ApiV3AppsGuidProcessesGetRequest) Guids(guids string) ApiV3AppsGuidProcessesGetRequest {
	r.guids = &guids
	return r
}

func (r ApiV3AppsGuidProcessesGetRequest) Types(types string) ApiV3AppsGuidProcessesGetRequest {
	r.types = &types
	return r
}

func (r ApiV3AppsGuidProcessesGetRequest) Page(page int32) ApiV3AppsGuidProcessesGetRequest {
	r.page = &page
	return r
}

func (r ApiV3AppsGuidProcessesGetRequest) PerPage(perPage int32) ApiV3AppsGuidProcessesGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3AppsGuidProcessesGetRequest) OrderBy(orderBy string) ApiV3AppsGuidProcessesGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3AppsGuidProcessesGetRequest) LabelSelector(labelSelector string) ApiV3AppsGuidProcessesGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3AppsGuidProcessesGetRequest) CreatedAts(createdAts string) ApiV3AppsGuidProcessesGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3AppsGuidProcessesGetRequest) UpdatedAts(updatedAts string) ApiV3AppsGuidProcessesGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3AppsGuidProcessesGetRequest) Execute() (*ProcessList, *http.Response, error) {
	return r.ApiService.V3AppsGuidProcessesGetExecute(r)
}

/*
V3AppsGuidProcessesGet List processes for app

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3AppsGuidProcessesGetRequest
*/
func (a *DefaultAPIService) V3AppsGuidProcessesGet(ctx context.Context, guid string) ApiV3AppsGuidProcessesGetRequest {
	return ApiV3AppsGuidProcessesGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ProcessList
func (a *DefaultAPIService) V3AppsGuidProcessesGetExecute(r ApiV3AppsGuidProcessesGetRequest) (*ProcessList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidProcessesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/processes"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "")
	}
	if r.types != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "types", r.types, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidRelationshipsCurrentDropletGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3AppsGuidRelationshipsCurrentDropletGetRequest) Execute() (*V3AppsGuidRelationshipsCurrentDropletGet200Response, *http.Response, error) {
	return r.ApiService.V3AppsGuidRelationshipsCurrentDropletGetExecute(r)
}

/*
V3AppsGuidRelationshipsCurrentDropletGet Get current droplet association for an app

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3AppsGuidRelationshipsCurrentDropletGetRequest
*/
func (a *DefaultAPIService) V3AppsGuidRelationshipsCurrentDropletGet(ctx context.Context, guid string) ApiV3AppsGuidRelationshipsCurrentDropletGetRequest {
	return ApiV3AppsGuidRelationshipsCurrentDropletGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidRelationshipsCurrentDropletGet200Response
func (a *DefaultAPIService) V3AppsGuidRelationshipsCurrentDropletGetExecute(r ApiV3AppsGuidRelationshipsCurrentDropletGetRequest) (*V3AppsGuidRelationshipsCurrentDropletGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidRelationshipsCurrentDropletGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidRelationshipsCurrentDropletGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/relationships/current_droplet"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidRevisionsDeployedGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	page *int32
	perPage *int32
	orderBy *string
}

// Page to display; valid values are integers &gt;&#x3D; 1
func (r ApiV3AppsGuidRevisionsDeployedGetRequest) Page(page int32) ApiV3AppsGuidRevisionsDeployedGetRequest {
	r.page = &page
	return r
}

// Number of results per page; valid values are 1 through 5000
func (r ApiV3AppsGuidRevisionsDeployedGetRequest) PerPage(perPage int32) ApiV3AppsGuidRevisionsDeployedGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by. Defaults to ascending; prepend with - to sort descending.
func (r ApiV3AppsGuidRevisionsDeployedGetRequest) OrderBy(orderBy string) ApiV3AppsGuidRevisionsDeployedGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3AppsGuidRevisionsDeployedGetRequest) Execute() (*RevisionsList, *http.Response, error) {
	return r.ApiService.V3AppsGuidRevisionsDeployedGetExecute(r)
}

/*
V3AppsGuidRevisionsDeployedGet List deployed revisions for an app

Retrieve deployed revisions for an app the user has access to. Deployed revisions are revisions that are linked to started processes in the app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid Unique identifier for the app
 @return ApiV3AppsGuidRevisionsDeployedGetRequest
*/
func (a *DefaultAPIService) V3AppsGuidRevisionsDeployedGet(ctx context.Context, guid string) ApiV3AppsGuidRevisionsDeployedGetRequest {
	return ApiV3AppsGuidRevisionsDeployedGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return RevisionsList
func (a *DefaultAPIService) V3AppsGuidRevisionsDeployedGetExecute(r ApiV3AppsGuidRevisionsDeployedGetRequest) (*RevisionsList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RevisionsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidRevisionsDeployedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/revisions/deployed"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidRevisionsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	versions *[]string
	labelSelector *string
	page *int32
	perPage *int32
	orderBy *string
	createdAts *string
	updatedAts *string
}

// Comma-delimited list of revision versions to filter by
func (r ApiV3AppsGuidRevisionsGetRequest) Versions(versions []string) ApiV3AppsGuidRevisionsGetRequest {
	r.versions = &versions
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3AppsGuidRevisionsGetRequest) LabelSelector(labelSelector string) ApiV3AppsGuidRevisionsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Page to display; valid values are integers &gt;&#x3D; 1
func (r ApiV3AppsGuidRevisionsGetRequest) Page(page int32) ApiV3AppsGuidRevisionsGetRequest {
	r.page = &page
	return r
}

// Number of results per page; valid values are 1 through 5000
func (r ApiV3AppsGuidRevisionsGetRequest) PerPage(perPage int32) ApiV3AppsGuidRevisionsGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by. Defaults to ascending; prepend with - to sort descending.
func (r ApiV3AppsGuidRevisionsGetRequest) OrderBy(orderBy string) ApiV3AppsGuidRevisionsGetRequest {
	r.orderBy = &orderBy
	return r
}

// Timestamp to filter by; supports filtering with relational operators
func (r ApiV3AppsGuidRevisionsGetRequest) CreatedAts(createdAts string) ApiV3AppsGuidRevisionsGetRequest {
	r.createdAts = &createdAts
	return r
}

// Timestamp to filter by; supports filtering with relational operators
func (r ApiV3AppsGuidRevisionsGetRequest) UpdatedAts(updatedAts string) ApiV3AppsGuidRevisionsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3AppsGuidRevisionsGetRequest) Execute() (*RevisionsList, *http.Response, error) {
	return r.ApiService.V3AppsGuidRevisionsGetExecute(r)
}

/*
V3AppsGuidRevisionsGet List revisions for an app

Retrieve revisions for an app the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid Unique identifier for the app
 @return ApiV3AppsGuidRevisionsGetRequest
*/
func (a *DefaultAPIService) V3AppsGuidRevisionsGet(ctx context.Context, guid string) ApiV3AppsGuidRevisionsGetRequest {
	return ApiV3AppsGuidRevisionsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return RevisionsList
func (a *DefaultAPIService) V3AppsGuidRevisionsGetExecute(r ApiV3AppsGuidRevisionsGetRequest) (*RevisionsList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RevisionsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidRevisionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/revisions"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.versions != nil {
		t := *r.versions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "versions", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "versions", t, "form", "multi")
		}
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidRoutesGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	domainGuids *[]string
	hosts *[]string
	organizationGuids *[]string
	paths *[]string
	ports *[]int32
	spaceGuids *[]string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
}

// Comma-delimited list of domain guids to filter by
func (r ApiV3AppsGuidRoutesGetRequest) DomainGuids(domainGuids []string) ApiV3AppsGuidRoutesGetRequest {
	r.domainGuids = &domainGuids
	return r
}

// Comma-delimited list of hostnames to filter by
func (r ApiV3AppsGuidRoutesGetRequest) Hosts(hosts []string) ApiV3AppsGuidRoutesGetRequest {
	r.hosts = &hosts
	return r
}

// Comma-delimited list of organization guids to filter by
func (r ApiV3AppsGuidRoutesGetRequest) OrganizationGuids(organizationGuids []string) ApiV3AppsGuidRoutesGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

// Comma-delimited list of paths to filter by (e.g. /path1,/path2)
func (r ApiV3AppsGuidRoutesGetRequest) Paths(paths []string) ApiV3AppsGuidRoutesGetRequest {
	r.paths = &paths
	return r
}

// Comma-delimited list of ports to filter by (e.g. 3306,5432)
func (r ApiV3AppsGuidRoutesGetRequest) Ports(ports []int32) ApiV3AppsGuidRoutesGetRequest {
	r.ports = &ports
	return r
}

// Comma-delimited list of space guids to filter by
func (r ApiV3AppsGuidRoutesGetRequest) SpaceGuids(spaceGuids []string) ApiV3AppsGuidRoutesGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

// Page to display; valid values are integers &gt;&#x3D; 1
func (r ApiV3AppsGuidRoutesGetRequest) Page(page int32) ApiV3AppsGuidRoutesGetRequest {
	r.page = &page
	return r
}

// Number of results per page; valid values are 1 through 5000
func (r ApiV3AppsGuidRoutesGetRequest) PerPage(perPage int32) ApiV3AppsGuidRoutesGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by. Defaults to ascending; prepend with - to sort descending. Valid values are created_at, updated_at
func (r ApiV3AppsGuidRoutesGetRequest) OrderBy(orderBy string) ApiV3AppsGuidRoutesGetRequest {
	r.orderBy = &orderBy
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3AppsGuidRoutesGetRequest) LabelSelector(labelSelector string) ApiV3AppsGuidRoutesGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3AppsGuidRoutesGetRequest) Execute() (*RouteList, *http.Response, error) {
	return r.ApiService.V3AppsGuidRoutesGetExecute(r)
}

/*
V3AppsGuidRoutesGet Retrieve all routes for an app

Retrieve all routes that have destinations that point to the given app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The app GUID
 @return ApiV3AppsGuidRoutesGetRequest
*/
func (a *DefaultAPIService) V3AppsGuidRoutesGet(ctx context.Context, guid string) ApiV3AppsGuidRoutesGetRequest {
	return ApiV3AppsGuidRoutesGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return RouteList
func (a *DefaultAPIService) V3AppsGuidRoutesGetExecute(r ApiV3AppsGuidRoutesGetRequest) (*RouteList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidRoutesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/routes"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.domainGuids != nil {
		t := *r.domainGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "domain_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "domain_guids", t, "form", "multi")
		}
	}
	if r.hosts != nil {
		t := *r.hosts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hosts", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hosts", t, "form", "multi")
		}
	}
	if r.organizationGuids != nil {
		t := *r.organizationGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", t, "form", "multi")
		}
	}
	if r.paths != nil {
		t := *r.paths
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "paths", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "paths", t, "form", "multi")
		}
	}
	if r.ports != nil {
		t := *r.ports
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ports", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ports", t, "form", "multi")
		}
	}
	if r.spaceGuids != nil {
		t := *r.spaceGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", t, "form", "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidSidecarsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	page *int32
	perPage *int32
	orderBy *string
	createdAts *string
	updatedAts *string
}

func (r ApiV3AppsGuidSidecarsGetRequest) Page(page int32) ApiV3AppsGuidSidecarsGetRequest {
	r.page = &page
	return r
}

func (r ApiV3AppsGuidSidecarsGetRequest) PerPage(perPage int32) ApiV3AppsGuidSidecarsGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3AppsGuidSidecarsGetRequest) OrderBy(orderBy string) ApiV3AppsGuidSidecarsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3AppsGuidSidecarsGetRequest) CreatedAts(createdAts string) ApiV3AppsGuidSidecarsGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3AppsGuidSidecarsGetRequest) UpdatedAts(updatedAts string) ApiV3AppsGuidSidecarsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3AppsGuidSidecarsGetRequest) Execute() (*V3AppsGuidSidecarsGet200Response, *http.Response, error) {
	return r.ApiService.V3AppsGuidSidecarsGetExecute(r)
}

/*
V3AppsGuidSidecarsGet List sidecars for an app

Retrieves all sidecars associated with an app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3AppsGuidSidecarsGetRequest
*/
func (a *DefaultAPIService) V3AppsGuidSidecarsGet(ctx context.Context, guid string) ApiV3AppsGuidSidecarsGetRequest {
	return ApiV3AppsGuidSidecarsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidSidecarsGet200Response
func (a *DefaultAPIService) V3AppsGuidSidecarsGetExecute(r ApiV3AppsGuidSidecarsGetRequest) (*V3AppsGuidSidecarsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidSidecarsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidSidecarsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/sidecars"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidSidecarsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3AppsGuidSidecarsPostRequest *V3AppsGuidSidecarsPostRequest
}

func (r ApiV3AppsGuidSidecarsPostRequest) V3AppsGuidSidecarsPostRequest(v3AppsGuidSidecarsPostRequest V3AppsGuidSidecarsPostRequest) ApiV3AppsGuidSidecarsPostRequest {
	r.v3AppsGuidSidecarsPostRequest = &v3AppsGuidSidecarsPostRequest
	return r
}

func (r ApiV3AppsGuidSidecarsPostRequest) Execute() (*Sidecar, *http.Response, error) {
	return r.ApiService.V3AppsGuidSidecarsPostExecute(r)
}

/*
V3AppsGuidSidecarsPost Create a sidecar associated with an app

Creates a sidecar associated with an app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3AppsGuidSidecarsPostRequest
*/
func (a *DefaultAPIService) V3AppsGuidSidecarsPost(ctx context.Context, guid string) ApiV3AppsGuidSidecarsPostRequest {
	return ApiV3AppsGuidSidecarsPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Sidecar
func (a *DefaultAPIService) V3AppsGuidSidecarsPostExecute(r ApiV3AppsGuidSidecarsPostRequest) (*Sidecar, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Sidecar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidSidecarsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/sidecars"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3AppsGuidSidecarsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3AppsGuidSidecarsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3AppsGuidSidecarsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidSshEnabledGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3AppsGuidSshEnabledGetRequest) Execute() (*V3AppsGuidSshEnabledGet200Response, *http.Response, error) {
	return r.ApiService.V3AppsGuidSshEnabledGetExecute(r)
}

/*
V3AppsGuidSshEnabledGet Get SSH enabled for an app

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3AppsGuidSshEnabledGetRequest
*/
func (a *DefaultAPIService) V3AppsGuidSshEnabledGet(ctx context.Context, guid string) ApiV3AppsGuidSshEnabledGetRequest {
	return ApiV3AppsGuidSshEnabledGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidSshEnabledGet200Response
func (a *DefaultAPIService) V3AppsGuidSshEnabledGetExecute(r ApiV3AppsGuidSshEnabledGetRequest) (*V3AppsGuidSshEnabledGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidSshEnabledGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidSshEnabledGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/ssh_enabled"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidTasksPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3AppsGuidTasksPostRequest *V3AppsGuidTasksPostRequest
}

func (r ApiV3AppsGuidTasksPostRequest) V3AppsGuidTasksPostRequest(v3AppsGuidTasksPostRequest V3AppsGuidTasksPostRequest) ApiV3AppsGuidTasksPostRequest {
	r.v3AppsGuidTasksPostRequest = &v3AppsGuidTasksPostRequest
	return r
}

func (r ApiV3AppsGuidTasksPostRequest) Execute() (*Task, *http.Response, error) {
	return r.ApiService.V3AppsGuidTasksPostExecute(r)
}

/*
V3AppsGuidTasksPost Create a task

Create a new task for an app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3AppsGuidTasksPostRequest
*/
func (a *DefaultAPIService) V3AppsGuidTasksPost(ctx context.Context, guid string) ApiV3AppsGuidTasksPostRequest {
	return ApiV3AppsGuidTasksPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Task
func (a *DefaultAPIService) V3AppsGuidTasksPostExecute(r ApiV3AppsGuidTasksPostRequest) (*Task, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Task
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidTasksPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3AppsGuidTasksPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3AppsGuidTasksPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3AppsGuidTasksPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	v3AppsPostRequest *V3AppsPostRequest
}

func (r ApiV3AppsPostRequest) V3AppsPostRequest(v3AppsPostRequest V3AppsPostRequest) ApiV3AppsPostRequest {
	r.v3AppsPostRequest = &v3AppsPostRequest
	return r
}

func (r ApiV3AppsPostRequest) Execute() (*App, *http.Response, error) {
	return r.ApiService.V3AppsPostExecute(r)
}

/*
V3AppsPost Create an app

Create a new app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3AppsPostRequest
*/
func (a *DefaultAPIService) V3AppsPost(ctx context.Context) ApiV3AppsPostRequest {
	return ApiV3AppsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return App
func (a *DefaultAPIService) V3AppsPostExecute(r ApiV3AppsPostRequest) (*App, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *App
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3AppsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3AppsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3AppsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3BuildpacksGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiV3BuildpacksGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3BuildpacksGetExecute(r)
}

/*
V3BuildpacksGet List buildpacks

Retrieve a list of all buildpacks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3BuildpacksGetRequest
*/
func (a *DefaultAPIService) V3BuildpacksGet(ctx context.Context) ApiV3BuildpacksGetRequest {
	return ApiV3BuildpacksGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3BuildpacksGetExecute(r ApiV3BuildpacksGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3BuildpacksGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/buildpacks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3BuildpacksGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	body *map[string]interface{}
}

func (r ApiV3BuildpacksGuidPatchRequest) Body(body map[string]interface{}) ApiV3BuildpacksGuidPatchRequest {
	r.body = &body
	return r
}

func (r ApiV3BuildpacksGuidPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3BuildpacksGuidPatchExecute(r)
}

/*
V3BuildpacksGuidPatch Update a buildpack

Update an existing buildpack.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the buildpack.
 @return ApiV3BuildpacksGuidPatchRequest
*/
func (a *DefaultAPIService) V3BuildpacksGuidPatch(ctx context.Context, guid string) ApiV3BuildpacksGuidPatchRequest {
	return ApiV3BuildpacksGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3BuildpacksGuidPatchExecute(r ApiV3BuildpacksGuidPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3BuildpacksGuidPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/buildpacks/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3BuildpacksGuidUploadPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	bits *os.File
}

func (r ApiV3BuildpacksGuidUploadPostRequest) Bits(bits *os.File) ApiV3BuildpacksGuidUploadPostRequest {
	r.bits = bits
	return r
}

func (r ApiV3BuildpacksGuidUploadPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3BuildpacksGuidUploadPostExecute(r)
}

/*
V3BuildpacksGuidUploadPost Upload buildpack bits

Upload a zip file containing a Cloud Foundry compatible buildpack.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the buildpack.
 @return ApiV3BuildpacksGuidUploadPostRequest
*/
func (a *DefaultAPIService) V3BuildpacksGuidUploadPost(ctx context.Context, guid string) ApiV3BuildpacksGuidUploadPostRequest {
	return ApiV3BuildpacksGuidUploadPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3BuildpacksGuidUploadPostExecute(r ApiV3BuildpacksGuidUploadPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3BuildpacksGuidUploadPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/buildpacks/{guid}/upload"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var bitsLocalVarFormFileName string
	var bitsLocalVarFileName     string
	var bitsLocalVarFileBytes    []byte

	bitsLocalVarFormFileName = "bits"
	bitsLocalVarFile := r.bits

	if bitsLocalVarFile != nil {
		fbs, _ := io.ReadAll(bitsLocalVarFile)

		bitsLocalVarFileBytes = fbs
		bitsLocalVarFileName = bitsLocalVarFile.Name()
		bitsLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: bitsLocalVarFileBytes, fileName: bitsLocalVarFileName, formFileName: bitsLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3BuildpacksPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	body *map[string]interface{}
}

func (r ApiV3BuildpacksPostRequest) Body(body map[string]interface{}) ApiV3BuildpacksPostRequest {
	r.body = &body
	return r
}

func (r ApiV3BuildpacksPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3BuildpacksPostExecute(r)
}

/*
V3BuildpacksPost Create a buildpack

Create a new buildpack.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3BuildpacksPostRequest
*/
func (a *DefaultAPIService) V3BuildpacksPost(ctx context.Context) ApiV3BuildpacksPostRequest {
	return ApiV3BuildpacksPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3BuildpacksPostExecute(r ApiV3BuildpacksPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3BuildpacksPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/buildpacks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3BuildsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiV3BuildsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3BuildsGetExecute(r)
}

/*
V3BuildsGet List builds

Retrieve a list of all builds.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3BuildsGetRequest
*/
func (a *DefaultAPIService) V3BuildsGet(ctx context.Context) ApiV3BuildsGetRequest {
	return ApiV3BuildsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3BuildsGetExecute(r ApiV3BuildsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3BuildsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/builds"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3BuildsGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	body *map[string]interface{}
}

func (r ApiV3BuildsGuidPatchRequest) Body(body map[string]interface{}) ApiV3BuildsGuidPatchRequest {
	r.body = &body
	return r
}

func (r ApiV3BuildsGuidPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3BuildsGuidPatchExecute(r)
}

/*
V3BuildsGuidPatch Update a build

Update an existing build.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the build.
 @return ApiV3BuildsGuidPatchRequest
*/
func (a *DefaultAPIService) V3BuildsGuidPatch(ctx context.Context, guid string) ApiV3BuildsGuidPatchRequest {
	return ApiV3BuildsGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3BuildsGuidPatchExecute(r ApiV3BuildsGuidPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3BuildsGuidPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/builds/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3BuildsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	body *map[string]interface{}
}

func (r ApiV3BuildsPostRequest) Body(body map[string]interface{}) ApiV3BuildsPostRequest {
	r.body = &body
	return r
}

func (r ApiV3BuildsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3BuildsPostExecute(r)
}

/*
V3BuildsPost Create a build

Create a new build.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3BuildsPostRequest
*/
func (a *DefaultAPIService) V3BuildsPost(ctx context.Context) ApiV3BuildsPostRequest {
	return ApiV3BuildsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3BuildsPostExecute(r ApiV3BuildsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3BuildsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/builds"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3DeploymentsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiV3DeploymentsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3DeploymentsGetExecute(r)
}

/*
V3DeploymentsGet List deployments

Retrieve a list of all deployments.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3DeploymentsGetRequest
*/
func (a *DefaultAPIService) V3DeploymentsGet(ctx context.Context) ApiV3DeploymentsGetRequest {
	return ApiV3DeploymentsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3DeploymentsGetExecute(r ApiV3DeploymentsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3DeploymentsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/deployments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3DeploymentsGuidActionsCancelPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3DeploymentsGuidActionsCancelPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3DeploymentsGuidActionsCancelPostExecute(r)
}

/*
V3DeploymentsGuidActionsCancelPost Cancel a deployment

Cancel an ongoing deployment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the deployment.
 @return ApiV3DeploymentsGuidActionsCancelPostRequest
*/
func (a *DefaultAPIService) V3DeploymentsGuidActionsCancelPost(ctx context.Context, guid string) ApiV3DeploymentsGuidActionsCancelPostRequest {
	return ApiV3DeploymentsGuidActionsCancelPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3DeploymentsGuidActionsCancelPostExecute(r ApiV3DeploymentsGuidActionsCancelPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3DeploymentsGuidActionsCancelPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/deployments/{guid}/actions/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3DeploymentsGuidActionsContinuePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3DeploymentsGuidActionsContinuePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3DeploymentsGuidActionsContinuePostExecute(r)
}

/*
V3DeploymentsGuidActionsContinuePost Continue a deployment

Continue a paused deployment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the deployment.
 @return ApiV3DeploymentsGuidActionsContinuePostRequest
*/
func (a *DefaultAPIService) V3DeploymentsGuidActionsContinuePost(ctx context.Context, guid string) ApiV3DeploymentsGuidActionsContinuePostRequest {
	return ApiV3DeploymentsGuidActionsContinuePostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3DeploymentsGuidActionsContinuePostExecute(r ApiV3DeploymentsGuidActionsContinuePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3DeploymentsGuidActionsContinuePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/deployments/{guid}/actions/continue"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3DeploymentsGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3DeploymentsGuidGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3DeploymentsGuidGetExecute(r)
}

/*
V3DeploymentsGuidGet Get a deployment

Retrieve a deployment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the deployment.
 @return ApiV3DeploymentsGuidGetRequest
*/
func (a *DefaultAPIService) V3DeploymentsGuidGet(ctx context.Context, guid string) ApiV3DeploymentsGuidGetRequest {
	return ApiV3DeploymentsGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3DeploymentsGuidGetExecute(r ApiV3DeploymentsGuidGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3DeploymentsGuidGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/deployments/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3DeploymentsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	body *map[string]interface{}
}

func (r ApiV3DeploymentsPostRequest) Body(body map[string]interface{}) ApiV3DeploymentsPostRequest {
	r.body = &body
	return r
}

func (r ApiV3DeploymentsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3DeploymentsPostExecute(r)
}

/*
V3DeploymentsPost Create a deployment

Create a new deployment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3DeploymentsPostRequest
*/
func (a *DefaultAPIService) V3DeploymentsPost(ctx context.Context) ApiV3DeploymentsPostRequest {
	return ApiV3DeploymentsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3DeploymentsPostExecute(r ApiV3DeploymentsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3DeploymentsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/deployments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3DropletsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guids *[]string
	states *[]string
	appGuids *[]string
	spaceGuids *[]string
	organizationGuids *[]string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *time.Time
	updatedAts *time.Time
}

// Comma-delimited list of droplet guids to filter by
func (r ApiV3DropletsGetRequest) Guids(guids []string) ApiV3DropletsGetRequest {
	r.guids = &guids
	return r
}

// Comma-delimited list of droplet states to filter by
func (r ApiV3DropletsGetRequest) States(states []string) ApiV3DropletsGetRequest {
	r.states = &states
	return r
}

// Comma-delimited list of app guids to filter by
func (r ApiV3DropletsGetRequest) AppGuids(appGuids []string) ApiV3DropletsGetRequest {
	r.appGuids = &appGuids
	return r
}

// Comma-delimited list of space guids to filter by
func (r ApiV3DropletsGetRequest) SpaceGuids(spaceGuids []string) ApiV3DropletsGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

// Comma-delimited list of organization guids to filter by
func (r ApiV3DropletsGetRequest) OrganizationGuids(organizationGuids []string) ApiV3DropletsGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

// Page to display
func (r ApiV3DropletsGetRequest) Page(page int32) ApiV3DropletsGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3DropletsGetRequest) PerPage(perPage int32) ApiV3DropletsGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by
func (r ApiV3DropletsGetRequest) OrderBy(orderBy string) ApiV3DropletsGetRequest {
	r.orderBy = &orderBy
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3DropletsGetRequest) LabelSelector(labelSelector string) ApiV3DropletsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Timestamp to filter by
func (r ApiV3DropletsGetRequest) CreatedAts(createdAts time.Time) ApiV3DropletsGetRequest {
	r.createdAts = &createdAts
	return r
}

// Timestamp to filter by
func (r ApiV3DropletsGetRequest) UpdatedAts(updatedAts time.Time) ApiV3DropletsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3DropletsGetRequest) Execute() (*V3AppsGuidDropletsGet200Response, *http.Response, error) {
	return r.ApiService.V3DropletsGetExecute(r)
}

/*
V3DropletsGet List droplets

Retrieve all droplets the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3DropletsGetRequest
*/
func (a *DefaultAPIService) V3DropletsGet(ctx context.Context) ApiV3DropletsGetRequest {
	return ApiV3DropletsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3AppsGuidDropletsGet200Response
func (a *DefaultAPIService) V3DropletsGetExecute(r ApiV3DropletsGetRequest) (*V3AppsGuidDropletsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidDropletsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3DropletsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/droplets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		t := *r.guids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guids", t, "form", "multi")
		}
	}
	if r.states != nil {
		t := *r.states
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "states", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "states", t, "form", "multi")
		}
	}
	if r.appGuids != nil {
		t := *r.appGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "app_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "app_guids", t, "form", "multi")
		}
	}
	if r.spaceGuids != nil {
		t := *r.spaceGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", t, "form", "multi")
		}
	}
	if r.organizationGuids != nil {
		t := *r.organizationGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", t, "form", "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3DropletsGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3DropletsGuidGetRequest) Execute() (*Droplet, *http.Response, error) {
	return r.ApiService.V3DropletsGuidGetExecute(r)
}

/*
V3DropletsGuidGet Get a droplet

Retrieve a specific droplet.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the droplet
 @return ApiV3DropletsGuidGetRequest
*/
func (a *DefaultAPIService) V3DropletsGuidGet(ctx context.Context, guid string) ApiV3DropletsGuidGetRequest {
	return ApiV3DropletsGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Droplet
func (a *DefaultAPIService) V3DropletsGuidGetExecute(r ApiV3DropletsGuidGetRequest) (*Droplet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Droplet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3DropletsGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/droplets/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3DropletsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	v3DropletsPostRequest *V3DropletsPostRequest
}

func (r ApiV3DropletsPostRequest) V3DropletsPostRequest(v3DropletsPostRequest V3DropletsPostRequest) ApiV3DropletsPostRequest {
	r.v3DropletsPostRequest = &v3DropletsPostRequest
	return r
}

func (r ApiV3DropletsPostRequest) Execute() (*Droplet, *http.Response, error) {
	return r.ApiService.V3DropletsPostExecute(r)
}

/*
V3DropletsPost Create a droplet

Create a droplet without a package.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3DropletsPostRequest
*/
func (a *DefaultAPIService) V3DropletsPost(ctx context.Context) ApiV3DropletsPostRequest {
	return ApiV3DropletsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Droplet
func (a *DefaultAPIService) V3DropletsPostExecute(r ApiV3DropletsPostRequest) (*Droplet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Droplet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3DropletsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/droplets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3DropletsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3DropletsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3DropletsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3EnvironmentVariableGroupsNameGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	name string
}

func (r ApiV3EnvironmentVariableGroupsNameGetRequest) Execute() (*EnvironmentVariableGroup, *http.Response, error) {
	return r.ApiService.V3EnvironmentVariableGroupsNameGetExecute(r)
}

/*
V3EnvironmentVariableGroupsNameGet Get an environment variable group

Retrieve a specific environment variable group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the environment variable group (running or staging)
 @return ApiV3EnvironmentVariableGroupsNameGetRequest
*/
func (a *DefaultAPIService) V3EnvironmentVariableGroupsNameGet(ctx context.Context, name string) ApiV3EnvironmentVariableGroupsNameGetRequest {
	return ApiV3EnvironmentVariableGroupsNameGetRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return EnvironmentVariableGroup
func (a *DefaultAPIService) V3EnvironmentVariableGroupsNameGetExecute(r ApiV3EnvironmentVariableGroupsNameGetRequest) (*EnvironmentVariableGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvironmentVariableGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3EnvironmentVariableGroupsNameGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/environment_variable_groups/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3EnvironmentVariableGroupsNamePatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	name string
	v3EnvironmentVariableGroupsNamePatchRequest *V3EnvironmentVariableGroupsNamePatchRequest
}

func (r ApiV3EnvironmentVariableGroupsNamePatchRequest) V3EnvironmentVariableGroupsNamePatchRequest(v3EnvironmentVariableGroupsNamePatchRequest V3EnvironmentVariableGroupsNamePatchRequest) ApiV3EnvironmentVariableGroupsNamePatchRequest {
	r.v3EnvironmentVariableGroupsNamePatchRequest = &v3EnvironmentVariableGroupsNamePatchRequest
	return r
}

func (r ApiV3EnvironmentVariableGroupsNamePatchRequest) Execute() (*EnvironmentVariableGroup, *http.Response, error) {
	return r.ApiService.V3EnvironmentVariableGroupsNamePatchExecute(r)
}

/*
V3EnvironmentVariableGroupsNamePatch Update environment variable group

Update the environment variable group. The variables given in the request will be merged with the existing environment variable group. Any requested variables with a value of null will be removed from the group. Environment variable names may not start with VCAP_. PORT is not a valid environment variable.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the environment variable group (running or staging)
 @return ApiV3EnvironmentVariableGroupsNamePatchRequest
*/
func (a *DefaultAPIService) V3EnvironmentVariableGroupsNamePatch(ctx context.Context, name string) ApiV3EnvironmentVariableGroupsNamePatchRequest {
	return ApiV3EnvironmentVariableGroupsNamePatchRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return EnvironmentVariableGroup
func (a *DefaultAPIService) V3EnvironmentVariableGroupsNamePatchExecute(r ApiV3EnvironmentVariableGroupsNamePatchRequest) (*EnvironmentVariableGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvironmentVariableGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3EnvironmentVariableGroupsNamePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/environment_variable_groups/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3EnvironmentVariableGroupsNamePatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3EnvironmentVariableGroupsNamePatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3EnvironmentVariableGroupsNamePatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3FeatureFlagsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	page *int32
	perPage *int32
	orderBy *string
	updatedAts *time.Time
}

// Page to display
func (r ApiV3FeatureFlagsGetRequest) Page(page int32) ApiV3FeatureFlagsGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3FeatureFlagsGetRequest) PerPage(perPage int32) ApiV3FeatureFlagsGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by. Defaults to name ascending; prepend with - to sort descending.
func (r ApiV3FeatureFlagsGetRequest) OrderBy(orderBy string) ApiV3FeatureFlagsGetRequest {
	r.orderBy = &orderBy
	return r
}

// Timestamp to filter by
func (r ApiV3FeatureFlagsGetRequest) UpdatedAts(updatedAts time.Time) ApiV3FeatureFlagsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3FeatureFlagsGetRequest) Execute() (*V3FeatureFlagsGet200Response, *http.Response, error) {
	return r.ApiService.V3FeatureFlagsGetExecute(r)
}

/*
V3FeatureFlagsGet List feature flags

Retrieve all feature flags.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3FeatureFlagsGetRequest
*/
func (a *DefaultAPIService) V3FeatureFlagsGet(ctx context.Context) ApiV3FeatureFlagsGetRequest {
	return ApiV3FeatureFlagsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3FeatureFlagsGet200Response
func (a *DefaultAPIService) V3FeatureFlagsGetExecute(r ApiV3FeatureFlagsGetRequest) (*V3FeatureFlagsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3FeatureFlagsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3FeatureFlagsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/feature_flags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3FeatureFlagsNameGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	name string
}

func (r ApiV3FeatureFlagsNameGetRequest) Execute() (*FeatureFlag, *http.Response, error) {
	return r.ApiService.V3FeatureFlagsNameGetExecute(r)
}

/*
V3FeatureFlagsNameGet Get a feature flag

Retrieve a specific feature flag.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the feature flag
 @return ApiV3FeatureFlagsNameGetRequest
*/
func (a *DefaultAPIService) V3FeatureFlagsNameGet(ctx context.Context, name string) ApiV3FeatureFlagsNameGetRequest {
	return ApiV3FeatureFlagsNameGetRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return FeatureFlag
func (a *DefaultAPIService) V3FeatureFlagsNameGetExecute(r ApiV3FeatureFlagsNameGetRequest) (*FeatureFlag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FeatureFlag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3FeatureFlagsNameGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/feature_flags/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3FeatureFlagsNamePatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	name string
	v3FeatureFlagsNamePatchRequest *V3FeatureFlagsNamePatchRequest
}

func (r ApiV3FeatureFlagsNamePatchRequest) V3FeatureFlagsNamePatchRequest(v3FeatureFlagsNamePatchRequest V3FeatureFlagsNamePatchRequest) ApiV3FeatureFlagsNamePatchRequest {
	r.v3FeatureFlagsNamePatchRequest = &v3FeatureFlagsNamePatchRequest
	return r
}

func (r ApiV3FeatureFlagsNamePatchRequest) Execute() (*FeatureFlag, *http.Response, error) {
	return r.ApiService.V3FeatureFlagsNamePatchExecute(r)
}

/*
V3FeatureFlagsNamePatch Update a feature flag

Update the status or custom error message of a feature flag.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the feature flag
 @return ApiV3FeatureFlagsNamePatchRequest
*/
func (a *DefaultAPIService) V3FeatureFlagsNamePatch(ctx context.Context, name string) ApiV3FeatureFlagsNamePatchRequest {
	return ApiV3FeatureFlagsNamePatchRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return FeatureFlag
func (a *DefaultAPIService) V3FeatureFlagsNamePatchExecute(r ApiV3FeatureFlagsNamePatchRequest) (*FeatureFlag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FeatureFlag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3FeatureFlagsNamePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/feature_flags/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3FeatureFlagsNamePatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3FeatureFlagsNamePatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3FeatureFlagsNamePatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3GetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiV3GetRequest) Execute() (*V3Get200Response, *http.Response, error) {
	return r.ApiService.V3GetExecute(r)
}

/*
V3Get V3 API Root

Returns links to all the resources available on the v3 API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3GetRequest
*/
func (a *DefaultAPIService) V3Get(ctx context.Context) ApiV3GetRequest {
	return ApiV3GetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3Get200Response
func (a *DefaultAPIService) V3GetExecute(r ApiV3GetRequest) (*V3Get200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3Get200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3Get")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3InfoGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiV3InfoGetRequest) Execute() (*PlatformInfo, *http.Response, error) {
	return r.ApiService.V3InfoGetExecute(r)
}

/*
V3InfoGet Get platform info

Retrieve Cloud Controller configuration information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3InfoGetRequest
*/
func (a *DefaultAPIService) V3InfoGet(ctx context.Context) ApiV3InfoGetRequest {
	return ApiV3InfoGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PlatformInfo
func (a *DefaultAPIService) V3InfoGetExecute(r ApiV3InfoGetRequest) (*PlatformInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlatformInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3InfoGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3InfoUsageSummaryGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiV3InfoUsageSummaryGetRequest) Execute() (*UsageSummary, *http.Response, error) {
	return r.ApiService.V3InfoUsageSummaryGetExecute(r)
}

/*
V3InfoUsageSummaryGet Get platform usage summary

Retrieve a high-level summary of usage across the entire Cloud Foundry installation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3InfoUsageSummaryGetRequest
*/
func (a *DefaultAPIService) V3InfoUsageSummaryGet(ctx context.Context) ApiV3InfoUsageSummaryGetRequest {
	return ApiV3InfoUsageSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsageSummary
func (a *DefaultAPIService) V3InfoUsageSummaryGetExecute(r ApiV3InfoUsageSummaryGetRequest) (*UsageSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsageSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3InfoUsageSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/info/usage_summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3IsolationSegmentsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guids *[]string
	names *[]string
	organizationGuids *[]string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *time.Time
	updatedAts *time.Time
}

// Comma-delimited list of isolation segment guids to filter by
func (r ApiV3IsolationSegmentsGetRequest) Guids(guids []string) ApiV3IsolationSegmentsGetRequest {
	r.guids = &guids
	return r
}

// Comma-delimited list of isolation segment names to filter by
func (r ApiV3IsolationSegmentsGetRequest) Names(names []string) ApiV3IsolationSegmentsGetRequest {
	r.names = &names
	return r
}

// Comma-delimited list of organization guids to filter by
func (r ApiV3IsolationSegmentsGetRequest) OrganizationGuids(organizationGuids []string) ApiV3IsolationSegmentsGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

// Page to display
func (r ApiV3IsolationSegmentsGetRequest) Page(page int32) ApiV3IsolationSegmentsGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3IsolationSegmentsGetRequest) PerPage(perPage int32) ApiV3IsolationSegmentsGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by; defaults to ascending. Prepend with - to sort descending
func (r ApiV3IsolationSegmentsGetRequest) OrderBy(orderBy string) ApiV3IsolationSegmentsGetRequest {
	r.orderBy = &orderBy
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3IsolationSegmentsGetRequest) LabelSelector(labelSelector string) ApiV3IsolationSegmentsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Timestamp to filter by
func (r ApiV3IsolationSegmentsGetRequest) CreatedAts(createdAts time.Time) ApiV3IsolationSegmentsGetRequest {
	r.createdAts = &createdAts
	return r
}

// Timestamp to filter by
func (r ApiV3IsolationSegmentsGetRequest) UpdatedAts(updatedAts time.Time) ApiV3IsolationSegmentsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3IsolationSegmentsGetRequest) Execute() (*V3IsolationSegmentsGet200Response, *http.Response, error) {
	return r.ApiService.V3IsolationSegmentsGetExecute(r)
}

/*
V3IsolationSegmentsGet List isolation segments

Retrieve all isolation segments to which the user has access.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3IsolationSegmentsGetRequest
*/
func (a *DefaultAPIService) V3IsolationSegmentsGet(ctx context.Context) ApiV3IsolationSegmentsGetRequest {
	return ApiV3IsolationSegmentsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3IsolationSegmentsGet200Response
func (a *DefaultAPIService) V3IsolationSegmentsGetExecute(r ApiV3IsolationSegmentsGetRequest) (*V3IsolationSegmentsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3IsolationSegmentsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3IsolationSegmentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/isolation_segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		t := *r.guids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guids", t, "form", "multi")
		}
	}
	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.organizationGuids != nil {
		t := *r.organizationGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", t, "form", "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3IsolationSegmentsGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3IsolationSegmentsGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3IsolationSegmentsGuidDeleteExecute(r)
}

/*
V3IsolationSegmentsGuidDelete Delete an isolation segment

Delete an isolation segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the isolation segment
 @return ApiV3IsolationSegmentsGuidDeleteRequest
*/
func (a *DefaultAPIService) V3IsolationSegmentsGuidDelete(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidDeleteRequest {
	return ApiV3IsolationSegmentsGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3IsolationSegmentsGuidDeleteExecute(r ApiV3IsolationSegmentsGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3IsolationSegmentsGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/isolation_segments/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3IsolationSegmentsGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3IsolationSegmentsGuidGetRequest) Execute() (*IsolationSegment, *http.Response, error) {
	return r.ApiService.V3IsolationSegmentsGuidGetExecute(r)
}

/*
V3IsolationSegmentsGuidGet Get an isolation segment

Retrieve an isolation segment to which the user has access.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the isolation segment
 @return ApiV3IsolationSegmentsGuidGetRequest
*/
func (a *DefaultAPIService) V3IsolationSegmentsGuidGet(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidGetRequest {
	return ApiV3IsolationSegmentsGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return IsolationSegment
func (a *DefaultAPIService) V3IsolationSegmentsGuidGetExecute(r ApiV3IsolationSegmentsGuidGetRequest) (*IsolationSegment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IsolationSegment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3IsolationSegmentsGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/isolation_segments/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3IsolationSegmentsGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	isolationSegment *IsolationSegment
}

func (r ApiV3IsolationSegmentsGuidPatchRequest) IsolationSegment(isolationSegment IsolationSegment) ApiV3IsolationSegmentsGuidPatchRequest {
	r.isolationSegment = &isolationSegment
	return r
}

func (r ApiV3IsolationSegmentsGuidPatchRequest) Execute() (*IsolationSegment, *http.Response, error) {
	return r.ApiService.V3IsolationSegmentsGuidPatchExecute(r)
}

/*
V3IsolationSegmentsGuidPatch Update an isolation segment

Update the name or metadata of an isolation segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the isolation segment
 @return ApiV3IsolationSegmentsGuidPatchRequest
*/
func (a *DefaultAPIService) V3IsolationSegmentsGuidPatch(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidPatchRequest {
	return ApiV3IsolationSegmentsGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return IsolationSegment
func (a *DefaultAPIService) V3IsolationSegmentsGuidPatchExecute(r ApiV3IsolationSegmentsGuidPatchRequest) (*IsolationSegment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IsolationSegment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3IsolationSegmentsGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/isolation_segments/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.isolationSegment == nil {
		return localVarReturnValue, nil, reportError("isolationSegment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.isolationSegment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3IsolationSegmentsGuidRelationshipsOrganizationsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsGetRequest) Execute() (*V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response, *http.Response, error) {
	return r.ApiService.V3IsolationSegmentsGuidRelationshipsOrganizationsGetExecute(r)
}

/*
V3IsolationSegmentsGuidRelationshipsOrganizationsGet List organizations relationship

List the organizations entitled for the isolation segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the isolation segment
 @return ApiV3IsolationSegmentsGuidRelationshipsOrganizationsGetRequest
*/
func (a *DefaultAPIService) V3IsolationSegmentsGuidRelationshipsOrganizationsGet(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidRelationshipsOrganizationsGetRequest {
	return ApiV3IsolationSegmentsGuidRelationshipsOrganizationsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response
func (a *DefaultAPIService) V3IsolationSegmentsGuidRelationshipsOrganizationsGetExecute(r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsGetRequest) (*V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3IsolationSegmentsGuidRelationshipsOrganizationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/isolation_segments/{guid}/relationships/organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	orgGuid string
}

func (r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteExecute(r)
}

/*
V3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDelete Revoke entitlement to isolation segment for an organization

Revoke the entitlement for the specified organization to the isolation segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the isolation segment
 @param orgGuid The guid of the organization
 @return ApiV3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteRequest
*/
func (a *DefaultAPIService) V3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDelete(ctx context.Context, guid string, orgGuid string) ApiV3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteRequest {
	return ApiV3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
		orgGuid: orgGuid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteExecute(r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/isolation_segments/{guid}/relationships/organizations/{org_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org_guid"+"}", url.PathEscape(parameterValueToString(r.orgGuid, "orgGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest *V3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest
}

func (r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest) V3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest(v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest V3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest) ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest {
	r.v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest = &v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest
	return r
}

func (r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest) Execute() (*V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response, *http.Response, error) {
	return r.ApiService.V3IsolationSegmentsGuidRelationshipsOrganizationsPostExecute(r)
}

/*
V3IsolationSegmentsGuidRelationshipsOrganizationsPost Entitle organizations for an isolation segment

Entitle the specified organizations for the isolation segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the isolation segment
 @return ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest
*/
func (a *DefaultAPIService) V3IsolationSegmentsGuidRelationshipsOrganizationsPost(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest {
	return ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response
func (a *DefaultAPIService) V3IsolationSegmentsGuidRelationshipsOrganizationsPostExecute(r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest) (*V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3IsolationSegmentsGuidRelationshipsOrganizationsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/isolation_segments/{guid}/relationships/organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3IsolationSegmentsGuidRelationshipsSpacesGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3IsolationSegmentsGuidRelationshipsSpacesGetRequest) Execute() (*V3IsolationSegmentsGuidRelationshipsSpacesGet200Response, *http.Response, error) {
	return r.ApiService.V3IsolationSegmentsGuidRelationshipsSpacesGetExecute(r)
}

/*
V3IsolationSegmentsGuidRelationshipsSpacesGet List spaces relationship

List the spaces to which the isolation segment is assigned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the isolation segment
 @return ApiV3IsolationSegmentsGuidRelationshipsSpacesGetRequest
*/
func (a *DefaultAPIService) V3IsolationSegmentsGuidRelationshipsSpacesGet(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidRelationshipsSpacesGetRequest {
	return ApiV3IsolationSegmentsGuidRelationshipsSpacesGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3IsolationSegmentsGuidRelationshipsSpacesGet200Response
func (a *DefaultAPIService) V3IsolationSegmentsGuidRelationshipsSpacesGetExecute(r ApiV3IsolationSegmentsGuidRelationshipsSpacesGetRequest) (*V3IsolationSegmentsGuidRelationshipsSpacesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3IsolationSegmentsGuidRelationshipsSpacesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3IsolationSegmentsGuidRelationshipsSpacesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/isolation_segments/{guid}/relationships/spaces"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3IsolationSegmentsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	isolationSegment *IsolationSegment
}

func (r ApiV3IsolationSegmentsPostRequest) IsolationSegment(isolationSegment IsolationSegment) ApiV3IsolationSegmentsPostRequest {
	r.isolationSegment = &isolationSegment
	return r
}

func (r ApiV3IsolationSegmentsPostRequest) Execute() (*IsolationSegment, *http.Response, error) {
	return r.ApiService.V3IsolationSegmentsPostExecute(r)
}

/*
V3IsolationSegmentsPost Create an isolation segment

Create a new isolation segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3IsolationSegmentsPostRequest
*/
func (a *DefaultAPIService) V3IsolationSegmentsPost(ctx context.Context) ApiV3IsolationSegmentsPostRequest {
	return ApiV3IsolationSegmentsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IsolationSegment
func (a *DefaultAPIService) V3IsolationSegmentsPostExecute(r ApiV3IsolationSegmentsPostRequest) (*IsolationSegment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IsolationSegment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3IsolationSegmentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/isolation_segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.isolationSegment == nil {
		return localVarReturnValue, nil, reportError("isolationSegment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.isolationSegment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3PackagesGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guids *[]string
	states *[]string
	types *[]string
	appGuids *[]string
	spaceGuids *[]string
	organizationGuids *[]string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *[]time.Time
	updatedAts *[]time.Time
}

// Comma-delimited list of package guids to filter by
func (r ApiV3PackagesGetRequest) Guids(guids []string) ApiV3PackagesGetRequest {
	r.guids = &guids
	return r
}

// Comma-delimited list of package states to filter by
func (r ApiV3PackagesGetRequest) States(states []string) ApiV3PackagesGetRequest {
	r.states = &states
	return r
}

// Comma-delimited list of package types to filter by
func (r ApiV3PackagesGetRequest) Types(types []string) ApiV3PackagesGetRequest {
	r.types = &types
	return r
}

// Comma-delimited list of app guids to filter by
func (r ApiV3PackagesGetRequest) AppGuids(appGuids []string) ApiV3PackagesGetRequest {
	r.appGuids = &appGuids
	return r
}

// Comma-delimited list of space guids to filter by
func (r ApiV3PackagesGetRequest) SpaceGuids(spaceGuids []string) ApiV3PackagesGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

// Comma-delimited list of organization guids to filter by
func (r ApiV3PackagesGetRequest) OrganizationGuids(organizationGuids []string) ApiV3PackagesGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

// Page to display
func (r ApiV3PackagesGetRequest) Page(page int32) ApiV3PackagesGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3PackagesGetRequest) PerPage(perPage int32) ApiV3PackagesGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by; defaults to ascending. Prepend with - to sort descending. Valid values are created_at, updated_at
func (r ApiV3PackagesGetRequest) OrderBy(orderBy string) ApiV3PackagesGetRequest {
	r.orderBy = &orderBy
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3PackagesGetRequest) LabelSelector(labelSelector string) ApiV3PackagesGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3PackagesGetRequest) CreatedAts(createdAts []time.Time) ApiV3PackagesGetRequest {
	r.createdAts = &createdAts
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3PackagesGetRequest) UpdatedAts(updatedAts []time.Time) ApiV3PackagesGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3PackagesGetRequest) Execute() (*V3PackagesGet200Response, *http.Response, error) {
	return r.ApiService.V3PackagesGetExecute(r)
}

/*
V3PackagesGet List packages

Retrieve all packages the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3PackagesGetRequest
*/
func (a *DefaultAPIService) V3PackagesGet(ctx context.Context) ApiV3PackagesGetRequest {
	return ApiV3PackagesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3PackagesGet200Response
func (a *DefaultAPIService) V3PackagesGetExecute(r ApiV3PackagesGetRequest) (*V3PackagesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3PackagesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3PackagesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/packages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "csv")
	}
	if r.states != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "states", r.states, "form", "csv")
	}
	if r.types != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "types", r.types, "form", "csv")
	}
	if r.appGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "app_guids", r.appGuids, "form", "csv")
	}
	if r.spaceGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", r.spaceGuids, "form", "csv")
	}
	if r.organizationGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", r.organizationGuids, "form", "csv")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "csv")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3PackagesGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3PackagesGuidDeleteRequest) Execute() (*V3PackagesGuidDelete202Response, *http.Response, error) {
	return r.ApiService.V3PackagesGuidDeleteExecute(r)
}

/*
V3PackagesGuidDelete Delete a package

Delete a package by its GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3PackagesGuidDeleteRequest
*/
func (a *DefaultAPIService) V3PackagesGuidDelete(ctx context.Context, guid string) ApiV3PackagesGuidDeleteRequest {
	return ApiV3PackagesGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3PackagesGuidDelete202Response
func (a *DefaultAPIService) V3PackagesGuidDeleteExecute(r ApiV3PackagesGuidDeleteRequest) (*V3PackagesGuidDelete202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3PackagesGuidDelete202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3PackagesGuidDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/packages/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3PackagesGuidDropletsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	guids *[]string
	states *[]string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
}

// Comma-delimited list of droplet guids to filter by
func (r ApiV3PackagesGuidDropletsGetRequest) Guids(guids []string) ApiV3PackagesGuidDropletsGetRequest {
	r.guids = &guids
	return r
}

// Comma-delimited list of droplet states to filter by
func (r ApiV3PackagesGuidDropletsGetRequest) States(states []string) ApiV3PackagesGuidDropletsGetRequest {
	r.states = &states
	return r
}

// Page to display
func (r ApiV3PackagesGuidDropletsGetRequest) Page(page int32) ApiV3PackagesGuidDropletsGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3PackagesGuidDropletsGetRequest) PerPage(perPage int32) ApiV3PackagesGuidDropletsGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by
func (r ApiV3PackagesGuidDropletsGetRequest) OrderBy(orderBy string) ApiV3PackagesGuidDropletsGetRequest {
	r.orderBy = &orderBy
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3PackagesGuidDropletsGetRequest) LabelSelector(labelSelector string) ApiV3PackagesGuidDropletsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3PackagesGuidDropletsGetRequest) Execute() (*V3AppsGuidDropletsGet200Response, *http.Response, error) {
	return r.ApiService.V3PackagesGuidDropletsGetExecute(r)
}

/*
V3PackagesGuidDropletsGet List droplets for a package

Retrieve a list of droplets belonging to a package.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the package
 @return ApiV3PackagesGuidDropletsGetRequest
*/
func (a *DefaultAPIService) V3PackagesGuidDropletsGet(ctx context.Context, guid string) ApiV3PackagesGuidDropletsGetRequest {
	return ApiV3PackagesGuidDropletsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidDropletsGet200Response
func (a *DefaultAPIService) V3PackagesGuidDropletsGetExecute(r ApiV3PackagesGuidDropletsGetRequest) (*V3AppsGuidDropletsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidDropletsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3PackagesGuidDropletsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/packages/{guid}/droplets"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		t := *r.guids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guids", t, "form", "multi")
		}
	}
	if r.states != nil {
		t := *r.states
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "states", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "states", t, "form", "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3PackagesGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3PackagesGuidGetRequest) Execute() (*Package, *http.Response, error) {
	return r.ApiService.V3PackagesGuidGetExecute(r)
}

/*
V3PackagesGuidGet Get a package

Retrieve a package by its GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3PackagesGuidGetRequest
*/
func (a *DefaultAPIService) V3PackagesGuidGet(ctx context.Context, guid string) ApiV3PackagesGuidGetRequest {
	return ApiV3PackagesGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Package
func (a *DefaultAPIService) V3PackagesGuidGetExecute(r ApiV3PackagesGuidGetRequest) (*Package, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Package
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3PackagesGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/packages/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3PackagesGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3PackagesGuidPatchRequest *V3PackagesGuidPatchRequest
}

func (r ApiV3PackagesGuidPatchRequest) V3PackagesGuidPatchRequest(v3PackagesGuidPatchRequest V3PackagesGuidPatchRequest) ApiV3PackagesGuidPatchRequest {
	r.v3PackagesGuidPatchRequest = &v3PackagesGuidPatchRequest
	return r
}

func (r ApiV3PackagesGuidPatchRequest) Execute() (*Package, *http.Response, error) {
	return r.ApiService.V3PackagesGuidPatchExecute(r)
}

/*
V3PackagesGuidPatch Update a package

Update a package by its GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3PackagesGuidPatchRequest
*/
func (a *DefaultAPIService) V3PackagesGuidPatch(ctx context.Context, guid string) ApiV3PackagesGuidPatchRequest {
	return ApiV3PackagesGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Package
func (a *DefaultAPIService) V3PackagesGuidPatchExecute(r ApiV3PackagesGuidPatchRequest) (*Package, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Package
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3PackagesGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/packages/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3PackagesGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3PackagesGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3PackagesGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3PackagesGuidUploadPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	bits *os.File
	resources *[]V3PackagesGuidUploadPostRequestResourcesInner
}

// A binary zip file containing the package bits
func (r ApiV3PackagesGuidUploadPostRequest) Bits(bits *os.File) ApiV3PackagesGuidUploadPostRequest {
	r.bits = bits
	return r
}

func (r ApiV3PackagesGuidUploadPostRequest) Resources(resources []V3PackagesGuidUploadPostRequestResourcesInner) ApiV3PackagesGuidUploadPostRequest {
	r.resources = &resources
	return r
}

func (r ApiV3PackagesGuidUploadPostRequest) Execute() (*Package, *http.Response, error) {
	return r.ApiService.V3PackagesGuidUploadPostExecute(r)
}

/*
V3PackagesGuidUploadPost Upload package bits

Upload a new package by its GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3PackagesGuidUploadPostRequest
*/
func (a *DefaultAPIService) V3PackagesGuidUploadPost(ctx context.Context, guid string) ApiV3PackagesGuidUploadPostRequest {
	return ApiV3PackagesGuidUploadPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Package
func (a *DefaultAPIService) V3PackagesGuidUploadPostExecute(r ApiV3PackagesGuidUploadPostRequest) (*Package, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Package
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3PackagesGuidUploadPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/packages/{guid}/upload"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var bitsLocalVarFormFileName string
	var bitsLocalVarFileName     string
	var bitsLocalVarFileBytes    []byte

	bitsLocalVarFormFileName = "bits"
	bitsLocalVarFile := r.bits

	if bitsLocalVarFile != nil {
		fbs, _ := io.ReadAll(bitsLocalVarFile)

		bitsLocalVarFileBytes = fbs
		bitsLocalVarFileName = bitsLocalVarFile.Name()
		bitsLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: bitsLocalVarFileBytes, fileName: bitsLocalVarFileName, formFileName: bitsLocalVarFormFileName})
	}
	if r.resources != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "resources", r.resources, "", "csv")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3PackagesPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	v3PackagesPostRequest *V3PackagesPostRequest
}

func (r ApiV3PackagesPostRequest) V3PackagesPostRequest(v3PackagesPostRequest V3PackagesPostRequest) ApiV3PackagesPostRequest {
	r.v3PackagesPostRequest = &v3PackagesPostRequest
	return r
}

func (r ApiV3PackagesPostRequest) Execute() (*Package, *http.Response, error) {
	return r.ApiService.V3PackagesPostExecute(r)
}

/*
V3PackagesPost Create a package

Create a new package.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3PackagesPostRequest
*/
func (a *DefaultAPIService) V3PackagesPost(ctx context.Context) ApiV3PackagesPostRequest {
	return ApiV3PackagesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Package
func (a *DefaultAPIService) V3PackagesPostExecute(r ApiV3PackagesPostRequest) (*Package, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Package
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3PackagesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/packages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3PackagesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3PackagesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3PackagesPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ProcessesGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guids *string
	types *string
	appGuids *string
	spaceGuids *string
	organizationGuids *string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

func (r ApiV3ProcessesGetRequest) Guids(guids string) ApiV3ProcessesGetRequest {
	r.guids = &guids
	return r
}

func (r ApiV3ProcessesGetRequest) Types(types string) ApiV3ProcessesGetRequest {
	r.types = &types
	return r
}

func (r ApiV3ProcessesGetRequest) AppGuids(appGuids string) ApiV3ProcessesGetRequest {
	r.appGuids = &appGuids
	return r
}

func (r ApiV3ProcessesGetRequest) SpaceGuids(spaceGuids string) ApiV3ProcessesGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

func (r ApiV3ProcessesGetRequest) OrganizationGuids(organizationGuids string) ApiV3ProcessesGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

func (r ApiV3ProcessesGetRequest) Page(page int32) ApiV3ProcessesGetRequest {
	r.page = &page
	return r
}

func (r ApiV3ProcessesGetRequest) PerPage(perPage int32) ApiV3ProcessesGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3ProcessesGetRequest) OrderBy(orderBy string) ApiV3ProcessesGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3ProcessesGetRequest) LabelSelector(labelSelector string) ApiV3ProcessesGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3ProcessesGetRequest) CreatedAts(createdAts string) ApiV3ProcessesGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3ProcessesGetRequest) UpdatedAts(updatedAts string) ApiV3ProcessesGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3ProcessesGetRequest) Execute() (*ProcessList, *http.Response, error) {
	return r.ApiService.V3ProcessesGetExecute(r)
}

/*
V3ProcessesGet List processes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ProcessesGetRequest
*/
func (a *DefaultAPIService) V3ProcessesGet(ctx context.Context) ApiV3ProcessesGetRequest {
	return ApiV3ProcessesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProcessList
func (a *DefaultAPIService) V3ProcessesGetExecute(r ApiV3ProcessesGetRequest) (*ProcessList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ProcessesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/processes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "")
	}
	if r.types != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "types", r.types, "form", "")
	}
	if r.appGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "app_guids", r.appGuids, "form", "")
	}
	if r.spaceGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", r.spaceGuids, "form", "")
	}
	if r.organizationGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", r.organizationGuids, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ProcessesGuidActionsScalePostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	processScale *ProcessScale
}

func (r ApiV3ProcessesGuidActionsScalePostRequest) ProcessScale(processScale ProcessScale) ApiV3ProcessesGuidActionsScalePostRequest {
	r.processScale = &processScale
	return r
}

func (r ApiV3ProcessesGuidActionsScalePostRequest) Execute() (*Process, *http.Response, error) {
	return r.ApiService.V3ProcessesGuidActionsScalePostExecute(r)
}

/*
V3ProcessesGuidActionsScalePost Scale a process

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ProcessesGuidActionsScalePostRequest
*/
func (a *DefaultAPIService) V3ProcessesGuidActionsScalePost(ctx context.Context, guid string) ApiV3ProcessesGuidActionsScalePostRequest {
	return ApiV3ProcessesGuidActionsScalePostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Process
func (a *DefaultAPIService) V3ProcessesGuidActionsScalePostExecute(r ApiV3ProcessesGuidActionsScalePostRequest) (*Process, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Process
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ProcessesGuidActionsScalePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/processes/{guid}/actions/scale"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.processScale
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ProcessesGuidInstancesIndexDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	index int32
}

func (r ApiV3ProcessesGuidInstancesIndexDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3ProcessesGuidInstancesIndexDeleteExecute(r)
}

/*
V3ProcessesGuidInstancesIndexDelete Terminate a process instance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @param index
 @return ApiV3ProcessesGuidInstancesIndexDeleteRequest
*/
func (a *DefaultAPIService) V3ProcessesGuidInstancesIndexDelete(ctx context.Context, guid string, index int32) ApiV3ProcessesGuidInstancesIndexDeleteRequest {
	return ApiV3ProcessesGuidInstancesIndexDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
		index: index,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3ProcessesGuidInstancesIndexDeleteExecute(r ApiV3ProcessesGuidInstancesIndexDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ProcessesGuidInstancesIndexDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/processes/{guid}/instances/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3ProcessesGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	processUpdate *ProcessUpdate
}

func (r ApiV3ProcessesGuidPatchRequest) ProcessUpdate(processUpdate ProcessUpdate) ApiV3ProcessesGuidPatchRequest {
	r.processUpdate = &processUpdate
	return r
}

func (r ApiV3ProcessesGuidPatchRequest) Execute() (*Process, *http.Response, error) {
	return r.ApiService.V3ProcessesGuidPatchExecute(r)
}

/*
V3ProcessesGuidPatch Update a process

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ProcessesGuidPatchRequest
*/
func (a *DefaultAPIService) V3ProcessesGuidPatch(ctx context.Context, guid string) ApiV3ProcessesGuidPatchRequest {
	return ApiV3ProcessesGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Process
func (a *DefaultAPIService) V3ProcessesGuidPatchExecute(r ApiV3ProcessesGuidPatchRequest) (*Process, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Process
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ProcessesGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/processes/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.processUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ProcessesGuidSidecarsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	page *int32
	perPage *int32
	orderBy *string
	createdAts *string
	updatedAts *string
}

func (r ApiV3ProcessesGuidSidecarsGetRequest) Page(page int32) ApiV3ProcessesGuidSidecarsGetRequest {
	r.page = &page
	return r
}

func (r ApiV3ProcessesGuidSidecarsGetRequest) PerPage(perPage int32) ApiV3ProcessesGuidSidecarsGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3ProcessesGuidSidecarsGetRequest) OrderBy(orderBy string) ApiV3ProcessesGuidSidecarsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3ProcessesGuidSidecarsGetRequest) CreatedAts(createdAts string) ApiV3ProcessesGuidSidecarsGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3ProcessesGuidSidecarsGetRequest) UpdatedAts(updatedAts string) ApiV3ProcessesGuidSidecarsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3ProcessesGuidSidecarsGetRequest) Execute() (*V3AppsGuidSidecarsGet200Response, *http.Response, error) {
	return r.ApiService.V3ProcessesGuidSidecarsGetExecute(r)
}

/*
V3ProcessesGuidSidecarsGet List sidecars for a process

Retrieves all sidecars associated with a process.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ProcessesGuidSidecarsGetRequest
*/
func (a *DefaultAPIService) V3ProcessesGuidSidecarsGet(ctx context.Context, guid string) ApiV3ProcessesGuidSidecarsGetRequest {
	return ApiV3ProcessesGuidSidecarsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidSidecarsGet200Response
func (a *DefaultAPIService) V3ProcessesGuidSidecarsGetExecute(r ApiV3ProcessesGuidSidecarsGetRequest) (*V3AppsGuidSidecarsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidSidecarsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ProcessesGuidSidecarsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/processes/{guid}/sidecars"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ProcessesGuidStatsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ProcessesGuidStatsGetRequest) Execute() ([]ProcessStats, *http.Response, error) {
	return r.ApiService.V3ProcessesGuidStatsGetExecute(r)
}

/*
V3ProcessesGuidStatsGet Get stats for a process

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ProcessesGuidStatsGetRequest
*/
func (a *DefaultAPIService) V3ProcessesGuidStatsGet(ctx context.Context, guid string) ApiV3ProcessesGuidStatsGetRequest {
	return ApiV3ProcessesGuidStatsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return []ProcessStats
func (a *DefaultAPIService) V3ProcessesGuidStatsGetExecute(r ApiV3ProcessesGuidStatsGetRequest) ([]ProcessStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ProcessStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ProcessesGuidStatsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/processes/{guid}/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ResourceMatchesPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	resourceMatchRequest *ResourceMatchRequest
}

func (r ApiV3ResourceMatchesPostRequest) ResourceMatchRequest(resourceMatchRequest ResourceMatchRequest) ApiV3ResourceMatchesPostRequest {
	r.resourceMatchRequest = &resourceMatchRequest
	return r
}

func (r ApiV3ResourceMatchesPostRequest) Execute() (*ResourceMatchResponse, *http.Response, error) {
	return r.ApiService.V3ResourceMatchesPostExecute(r)
}

/*
V3ResourceMatchesPost Create a resource match

This endpoint matches given resource SHA-1/file size pairs against the Cloud Controller cache and reports the subset that describes already cached files. This is usually used to avoid uploading duplicate files when pushing an app which has only been partially changed. The path and mode fields are not used when matching.

When uploading package bits, the response from this endpoint should be used as the resources form field. As such, it is useful to include the path and mode fields for each resource even though they are not used when determining a resource match.

Cloud Foundry operators may set minimum/maximum file sizes to match against. If the file size provided is outside this range, it will not be matched against.

If the resource_matching feature flag is disabled, resource matching will always return an empty array.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ResourceMatchesPostRequest
*/
func (a *DefaultAPIService) V3ResourceMatchesPost(ctx context.Context) ApiV3ResourceMatchesPostRequest {
	return ApiV3ResourceMatchesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResourceMatchResponse
func (a *DefaultAPIService) V3ResourceMatchesPostExecute(r ApiV3ResourceMatchesPostRequest) (*ResourceMatchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceMatchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ResourceMatchesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/resource_matches"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resourceMatchRequest == nil {
		return localVarReturnValue, nil, reportError("resourceMatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resourceMatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3RevisionsGuidEnvironmentVariablesGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3RevisionsGuidEnvironmentVariablesGetRequest) Execute() (*EnvironmentVariables, *http.Response, error) {
	return r.ApiService.V3RevisionsGuidEnvironmentVariablesGetExecute(r)
}

/*
V3RevisionsGuidEnvironmentVariablesGet Get environment variables for a revision

Retrieve the environment variables associated with the revision.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid Unique identifier for the revision
 @return ApiV3RevisionsGuidEnvironmentVariablesGetRequest
*/
func (a *DefaultAPIService) V3RevisionsGuidEnvironmentVariablesGet(ctx context.Context, guid string) ApiV3RevisionsGuidEnvironmentVariablesGetRequest {
	return ApiV3RevisionsGuidEnvironmentVariablesGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return EnvironmentVariables
func (a *DefaultAPIService) V3RevisionsGuidEnvironmentVariablesGetExecute(r ApiV3RevisionsGuidEnvironmentVariablesGetRequest) (*EnvironmentVariables, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvironmentVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3RevisionsGuidEnvironmentVariablesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/revisions/{guid}/environment_variables"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3RevisionsGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3RevisionsGuidPatchRequest *V3RevisionsGuidPatchRequest
}

func (r ApiV3RevisionsGuidPatchRequest) V3RevisionsGuidPatchRequest(v3RevisionsGuidPatchRequest V3RevisionsGuidPatchRequest) ApiV3RevisionsGuidPatchRequest {
	r.v3RevisionsGuidPatchRequest = &v3RevisionsGuidPatchRequest
	return r
}

func (r ApiV3RevisionsGuidPatchRequest) Execute() (*Revision, *http.Response, error) {
	return r.ApiService.V3RevisionsGuidPatchExecute(r)
}

/*
V3RevisionsGuidPatch Update a revision

Update metadata for a specific revision.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid Unique identifier for the revision
 @return ApiV3RevisionsGuidPatchRequest
*/
func (a *DefaultAPIService) V3RevisionsGuidPatch(ctx context.Context, guid string) ApiV3RevisionsGuidPatchRequest {
	return ApiV3RevisionsGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Revision
func (a *DefaultAPIService) V3RevisionsGuidPatchExecute(r ApiV3RevisionsGuidPatchRequest) (*Revision, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Revision
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3RevisionsGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/revisions/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3RevisionsGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3RolesGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guids *[]string
	types *[]string
	spaceGuids *[]string
	organizationGuids *[]string
	userGuids *[]string
	page *int32
	perPage *int32
	orderBy *string
	include *[]string
	createdAts *[]string
	updatedAts *[]string
}

// Comma-delimited list of role guids to filter by
func (r ApiV3RolesGetRequest) Guids(guids []string) ApiV3RolesGetRequest {
	r.guids = &guids
	return r
}

// Comma-delimited list of role types to filter by
func (r ApiV3RolesGetRequest) Types(types []string) ApiV3RolesGetRequest {
	r.types = &types
	return r
}

// Comma-delimited list of space guids to filter by
func (r ApiV3RolesGetRequest) SpaceGuids(spaceGuids []string) ApiV3RolesGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

// Comma-delimited list of organization guids to filter by
func (r ApiV3RolesGetRequest) OrganizationGuids(organizationGuids []string) ApiV3RolesGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

// Comma-delimited list of user guids to filter by
func (r ApiV3RolesGetRequest) UserGuids(userGuids []string) ApiV3RolesGetRequest {
	r.userGuids = &userGuids
	return r
}

// Page to display, valid values are integers &gt;&#x3D; 1
func (r ApiV3RolesGetRequest) Page(page int32) ApiV3RolesGetRequest {
	r.page = &page
	return r
}

// Number of results per page, valid values are 1 through 5000
func (r ApiV3RolesGetRequest) PerPage(perPage int32) ApiV3RolesGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by, defaults to ascending, prepend with - to sort descending
func (r ApiV3RolesGetRequest) OrderBy(orderBy string) ApiV3RolesGetRequest {
	r.orderBy = &orderBy
	return r
}

// Optionally include a list of unique related resources in the response
func (r ApiV3RolesGetRequest) Include(include []string) ApiV3RolesGetRequest {
	r.include = &include
	return r
}

// Timestamp to filter by, supports filtering with relational operators
func (r ApiV3RolesGetRequest) CreatedAts(createdAts []string) ApiV3RolesGetRequest {
	r.createdAts = &createdAts
	return r
}

// Timestamp to filter by, supports filtering with relational operators
func (r ApiV3RolesGetRequest) UpdatedAts(updatedAts []string) ApiV3RolesGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3RolesGetRequest) Execute() (*RolesList, *http.Response, error) {
	return r.ApiService.V3RolesGetExecute(r)
}

/*
V3RolesGet List roles

List roles that the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3RolesGetRequest
*/
func (a *DefaultAPIService) V3RolesGet(ctx context.Context) ApiV3RolesGetRequest {
	return ApiV3RolesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RolesList
func (a *DefaultAPIService) V3RolesGetExecute(r ApiV3RolesGetRequest) (*RolesList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RolesList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3RolesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		t := *r.guids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guids", t, "form", "multi")
		}
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "form", "multi")
		}
	}
	if r.spaceGuids != nil {
		t := *r.spaceGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", t, "form", "multi")
		}
	}
	if r.organizationGuids != nil {
		t := *r.organizationGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", t, "form", "multi")
		}
	}
	if r.userGuids != nil {
		t := *r.userGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "user_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "user_guids", t, "form", "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.include != nil {
		t := *r.include
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "include", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "include", t, "form", "multi")
		}
	}
	if r.createdAts != nil {
		t := *r.createdAts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", t, "form", "multi")
		}
	}
	if r.updatedAts != nil {
		t := *r.updatedAts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3RolesGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3RolesGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3RolesGuidDeleteExecute(r)
}

/*
V3RolesGuidDelete Delete a role

Delete an individual role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid Unique identifier for the role
 @return ApiV3RolesGuidDeleteRequest
*/
func (a *DefaultAPIService) V3RolesGuidDelete(ctx context.Context, guid string) ApiV3RolesGuidDeleteRequest {
	return ApiV3RolesGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3RolesGuidDeleteExecute(r ApiV3RolesGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3RolesGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/roles/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3RolesGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	include *[]string
}

// Optionally include a list of unique related resources in the response
func (r ApiV3RolesGuidGetRequest) Include(include []string) ApiV3RolesGuidGetRequest {
	r.include = &include
	return r
}

func (r ApiV3RolesGuidGetRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.V3RolesGuidGetExecute(r)
}

/*
V3RolesGuidGet Get a role

Get an individual role resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid Unique identifier for the role
 @return ApiV3RolesGuidGetRequest
*/
func (a *DefaultAPIService) V3RolesGuidGet(ctx context.Context, guid string) ApiV3RolesGuidGetRequest {
	return ApiV3RolesGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Role
func (a *DefaultAPIService) V3RolesGuidGetExecute(r ApiV3RolesGuidGetRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3RolesGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/roles/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		t := *r.include
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "include", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "include", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3RolesPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	v3RolesPostRequest *V3RolesPostRequest
}

func (r ApiV3RolesPostRequest) V3RolesPostRequest(v3RolesPostRequest V3RolesPostRequest) ApiV3RolesPostRequest {
	r.v3RolesPostRequest = &v3RolesPostRequest
	return r
}

func (r ApiV3RolesPostRequest) Execute() (*Role, *http.Response, error) {
	return r.ApiService.V3RolesPostExecute(r)
}

/*
V3RolesPost Create a role

Create a new role for a user in an organization or space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3RolesPostRequest
*/
func (a *DefaultAPIService) V3RolesPost(ctx context.Context) ApiV3RolesPostRequest {
	return ApiV3RolesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Role
func (a *DefaultAPIService) V3RolesPostExecute(r ApiV3RolesPostRequest) (*Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3RolesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3RolesPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3RoutesGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	appGuids *string
	domainGuids *string
	hosts *string
	organizationGuids *string
	paths *string
	ports *string
	spaceGuids *string
	serviceInstanceGuids *string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	include *string
	createdAts *string
	updatedAts *string
}

// Comma-delimited list of app guids to filter by
func (r ApiV3RoutesGetRequest) AppGuids(appGuids string) ApiV3RoutesGetRequest {
	r.appGuids = &appGuids
	return r
}

// Comma-delimited list of domain guids to filter by
func (r ApiV3RoutesGetRequest) DomainGuids(domainGuids string) ApiV3RoutesGetRequest {
	r.domainGuids = &domainGuids
	return r
}

// Comma-delimited list of hostnames to filter by
func (r ApiV3RoutesGetRequest) Hosts(hosts string) ApiV3RoutesGetRequest {
	r.hosts = &hosts
	return r
}

// Comma-delimited list of organization guids to filter by
func (r ApiV3RoutesGetRequest) OrganizationGuids(organizationGuids string) ApiV3RoutesGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

// Comma-delimited list of paths to filter by (e.g. /path1,/path2)
func (r ApiV3RoutesGetRequest) Paths(paths string) ApiV3RoutesGetRequest {
	r.paths = &paths
	return r
}

// Comma-delimited list of ports to filter by (e.g. 3306,5432)
func (r ApiV3RoutesGetRequest) Ports(ports string) ApiV3RoutesGetRequest {
	r.ports = &ports
	return r
}

// Comma-delimited list of space guids to filter by
func (r ApiV3RoutesGetRequest) SpaceGuids(spaceGuids string) ApiV3RoutesGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

// Comma-delimited list of service instance guids to filter by
func (r ApiV3RoutesGetRequest) ServiceInstanceGuids(serviceInstanceGuids string) ApiV3RoutesGetRequest {
	r.serviceInstanceGuids = &serviceInstanceGuids
	return r
}

// Page to display; valid values are integers &gt;&#x3D; 1
func (r ApiV3RoutesGetRequest) Page(page int32) ApiV3RoutesGetRequest {
	r.page = &page
	return r
}

// Number of results per page; valid values are 1 through 5000
func (r ApiV3RoutesGetRequest) PerPage(perPage int32) ApiV3RoutesGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by. Defaults to ascending; prepend with - to sort descending. Valid values are created_at, updated_at
func (r ApiV3RoutesGetRequest) OrderBy(orderBy string) ApiV3RoutesGetRequest {
	r.orderBy = &orderBy
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3RoutesGetRequest) LabelSelector(labelSelector string) ApiV3RoutesGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Optionally include a list of unique related resources in the response. Valid values are domain, space.organization, space
func (r ApiV3RoutesGetRequest) Include(include string) ApiV3RoutesGetRequest {
	r.include = &include
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3RoutesGetRequest) CreatedAts(createdAts string) ApiV3RoutesGetRequest {
	r.createdAts = &createdAts
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3RoutesGetRequest) UpdatedAts(updatedAts string) ApiV3RoutesGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3RoutesGetRequest) Execute() (*V3RoutesGet200Response, *http.Response, error) {
	return r.ApiService.V3RoutesGetExecute(r)
}

/*
V3RoutesGet List routes

Retrieve all routes the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3RoutesGetRequest
*/
func (a *DefaultAPIService) V3RoutesGet(ctx context.Context) ApiV3RoutesGetRequest {
	return ApiV3RoutesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3RoutesGet200Response
func (a *DefaultAPIService) V3RoutesGetExecute(r ApiV3RoutesGetRequest) (*V3RoutesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3RoutesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3RoutesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/routes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.appGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "app_guids", r.appGuids, "form", "")
	}
	if r.domainGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain_guids", r.domainGuids, "form", "")
	}
	if r.hosts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hosts", r.hosts, "form", "")
	}
	if r.organizationGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", r.organizationGuids, "form", "")
	}
	if r.paths != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paths", r.paths, "form", "")
	}
	if r.ports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ports", r.ports, "form", "")
	}
	if r.spaceGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", r.spaceGuids, "form", "")
	}
	if r.serviceInstanceGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "service_instance_guids", r.serviceInstanceGuids, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3RoutesGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	include *string
}

// Optionally include additional related resources in the response. Valid values are domain, space.organization, space
func (r ApiV3RoutesGuidGetRequest) Include(include string) ApiV3RoutesGuidGetRequest {
	r.include = &include
	return r
}

func (r ApiV3RoutesGuidGetRequest) Execute() (*Route, *http.Response, error) {
	return r.ApiService.V3RoutesGuidGetExecute(r)
}

/*
V3RoutesGuidGet Get a route

Retrieve a route by its GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The route GUID
 @return ApiV3RoutesGuidGetRequest
*/
func (a *DefaultAPIService) V3RoutesGuidGet(ctx context.Context, guid string) ApiV3RoutesGuidGetRequest {
	return ApiV3RoutesGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Route
func (a *DefaultAPIService) V3RoutesGuidGetExecute(r ApiV3RoutesGuidGetRequest) (*Route, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Route
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3RoutesGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/routes/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3RoutesPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	v3RoutesPostRequest *V3RoutesPostRequest
}

func (r ApiV3RoutesPostRequest) V3RoutesPostRequest(v3RoutesPostRequest V3RoutesPostRequest) ApiV3RoutesPostRequest {
	r.v3RoutesPostRequest = &v3RoutesPostRequest
	return r
}

func (r ApiV3RoutesPostRequest) Execute() (*Route, *http.Response, error) {
	return r.ApiService.V3RoutesPostExecute(r)
}

/*
V3RoutesPost Create a route

Create a new route.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3RoutesPostRequest
*/
func (a *DefaultAPIService) V3RoutesPost(ctx context.Context) ApiV3RoutesPostRequest {
	return ApiV3RoutesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Route
func (a *DefaultAPIService) V3RoutesPostExecute(r ApiV3RoutesPostRequest) (*Route, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Route
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3RoutesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/routes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3RoutesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3RoutesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3RoutesPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SecurityGroupsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guids *[]string
	names *[]string
	globallyEnabledRunning *bool
	globallyEnabledStaging *bool
	runningSpaceGuids *[]string
	stagingSpaceGuids *[]string
	page *int32
	perPage *int32
	orderBy *string
	createdAts *string
	updatedAts *string
}

// Comma-delimited list of security group guids to filter by
func (r ApiV3SecurityGroupsGetRequest) Guids(guids []string) ApiV3SecurityGroupsGetRequest {
	r.guids = &guids
	return r
}

// Comma-delimited list of security group names to filter by
func (r ApiV3SecurityGroupsGetRequest) Names(names []string) ApiV3SecurityGroupsGetRequest {
	r.names = &names
	return r
}

// If true, only include the security groups that are enabled for running
func (r ApiV3SecurityGroupsGetRequest) GloballyEnabledRunning(globallyEnabledRunning bool) ApiV3SecurityGroupsGetRequest {
	r.globallyEnabledRunning = &globallyEnabledRunning
	return r
}

// If true, only include the security groups that are enabled for staging
func (r ApiV3SecurityGroupsGetRequest) GloballyEnabledStaging(globallyEnabledStaging bool) ApiV3SecurityGroupsGetRequest {
	r.globallyEnabledStaging = &globallyEnabledStaging
	return r
}

// Comma-delimited list of space guids to filter by
func (r ApiV3SecurityGroupsGetRequest) RunningSpaceGuids(runningSpaceGuids []string) ApiV3SecurityGroupsGetRequest {
	r.runningSpaceGuids = &runningSpaceGuids
	return r
}

// Comma-delimited list of space guids to filter by
func (r ApiV3SecurityGroupsGetRequest) StagingSpaceGuids(stagingSpaceGuids []string) ApiV3SecurityGroupsGetRequest {
	r.stagingSpaceGuids = &stagingSpaceGuids
	return r
}

// Page to display; valid values are integers &gt;&#x3D; 1
func (r ApiV3SecurityGroupsGetRequest) Page(page int32) ApiV3SecurityGroupsGetRequest {
	r.page = &page
	return r
}

// Number of results per page; valid values are 1 through 5000
func (r ApiV3SecurityGroupsGetRequest) PerPage(perPage int32) ApiV3SecurityGroupsGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by. Defaults to ascending; prepend with - to sort descending. Valid values are created_at, updated_at
func (r ApiV3SecurityGroupsGetRequest) OrderBy(orderBy string) ApiV3SecurityGroupsGetRequest {
	r.orderBy = &orderBy
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3SecurityGroupsGetRequest) CreatedAts(createdAts string) ApiV3SecurityGroupsGetRequest {
	r.createdAts = &createdAts
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3SecurityGroupsGetRequest) UpdatedAts(updatedAts string) ApiV3SecurityGroupsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3SecurityGroupsGetRequest) Execute() (*SecurityGroupList, *http.Response, error) {
	return r.ApiService.V3SecurityGroupsGetExecute(r)
}

/*
V3SecurityGroupsGet List security groups

Retrieves a list of security groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3SecurityGroupsGetRequest
*/
func (a *DefaultAPIService) V3SecurityGroupsGet(ctx context.Context) ApiV3SecurityGroupsGetRequest {
	return ApiV3SecurityGroupsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SecurityGroupList
func (a *DefaultAPIService) V3SecurityGroupsGetExecute(r ApiV3SecurityGroupsGetRequest) (*SecurityGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecurityGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SecurityGroupsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/security_groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		t := *r.guids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guids", t, "form", "multi")
		}
	}
	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.globallyEnabledRunning != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "globally_enabled_running", r.globallyEnabledRunning, "form", "")
	}
	if r.globallyEnabledStaging != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "globally_enabled_staging", r.globallyEnabledStaging, "form", "")
	}
	if r.runningSpaceGuids != nil {
		t := *r.runningSpaceGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "running_space_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "running_space_guids", t, "form", "multi")
		}
	}
	if r.stagingSpaceGuids != nil {
		t := *r.stagingSpaceGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "staging_space_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "staging_space_guids", t, "form", "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SecurityGroupsGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3SecurityGroupsGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3SecurityGroupsGuidDeleteExecute(r)
}

/*
V3SecurityGroupsGuidDelete Delete a security group

Deletes a security group by its GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The security group GUID
 @return ApiV3SecurityGroupsGuidDeleteRequest
*/
func (a *DefaultAPIService) V3SecurityGroupsGuidDelete(ctx context.Context, guid string) ApiV3SecurityGroupsGuidDeleteRequest {
	return ApiV3SecurityGroupsGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3SecurityGroupsGuidDeleteExecute(r ApiV3SecurityGroupsGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SecurityGroupsGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/security_groups/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3SecurityGroupsGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3SecurityGroupsGuidGetRequest) Execute() (*SecurityGroup, *http.Response, error) {
	return r.ApiService.V3SecurityGroupsGuidGetExecute(r)
}

/*
V3SecurityGroupsGuidGet Get a security group

Retrieves a security group by its GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The security group GUID
 @return ApiV3SecurityGroupsGuidGetRequest
*/
func (a *DefaultAPIService) V3SecurityGroupsGuidGet(ctx context.Context, guid string) ApiV3SecurityGroupsGuidGetRequest {
	return ApiV3SecurityGroupsGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return SecurityGroup
func (a *DefaultAPIService) V3SecurityGroupsGuidGetExecute(r ApiV3SecurityGroupsGuidGetRequest) (*SecurityGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecurityGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SecurityGroupsGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/security_groups/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SecurityGroupsGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	securityGroupUpdate *SecurityGroupUpdate
}

func (r ApiV3SecurityGroupsGuidPatchRequest) SecurityGroupUpdate(securityGroupUpdate SecurityGroupUpdate) ApiV3SecurityGroupsGuidPatchRequest {
	r.securityGroupUpdate = &securityGroupUpdate
	return r
}

func (r ApiV3SecurityGroupsGuidPatchRequest) Execute() (*SecurityGroup, *http.Response, error) {
	return r.ApiService.V3SecurityGroupsGuidPatchExecute(r)
}

/*
V3SecurityGroupsGuidPatch Update a security group

Updates the specified attributes of the security group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The security group GUID
 @return ApiV3SecurityGroupsGuidPatchRequest
*/
func (a *DefaultAPIService) V3SecurityGroupsGuidPatch(ctx context.Context, guid string) ApiV3SecurityGroupsGuidPatchRequest {
	return ApiV3SecurityGroupsGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return SecurityGroup
func (a *DefaultAPIService) V3SecurityGroupsGuidPatchExecute(r ApiV3SecurityGroupsGuidPatchRequest) (*SecurityGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecurityGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SecurityGroupsGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/security_groups/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.securityGroupUpdate == nil {
		return localVarReturnValue, nil, reportError("securityGroupUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.securityGroupUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SecurityGroupsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	securityGroupCreate *SecurityGroupCreate
}

func (r ApiV3SecurityGroupsPostRequest) SecurityGroupCreate(securityGroupCreate SecurityGroupCreate) ApiV3SecurityGroupsPostRequest {
	r.securityGroupCreate = &securityGroupCreate
	return r
}

func (r ApiV3SecurityGroupsPostRequest) Execute() (*SecurityGroup, *http.Response, error) {
	return r.ApiService.V3SecurityGroupsPostExecute(r)
}

/*
V3SecurityGroupsPost Create a security group

Creates a new security group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3SecurityGroupsPostRequest
*/
func (a *DefaultAPIService) V3SecurityGroupsPost(ctx context.Context) ApiV3SecurityGroupsPostRequest {
	return ApiV3SecurityGroupsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SecurityGroup
func (a *DefaultAPIService) V3SecurityGroupsPostExecute(r ApiV3SecurityGroupsPostRequest) (*SecurityGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecurityGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SecurityGroupsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/security_groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.securityGroupCreate == nil {
		return localVarReturnValue, nil, reportError("securityGroupCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.securityGroupCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceBrokersGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	names *[]string
	page *int32
	perPage *int32
	spaceGuids *[]string
	orderBy *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

// Comma-delimited list of service broker names to filter by
func (r ApiV3ServiceBrokersGetRequest) Names(names []string) ApiV3ServiceBrokersGetRequest {
	r.names = &names
	return r
}

// Page to display; valid values are integers &gt;&#x3D; 1
func (r ApiV3ServiceBrokersGetRequest) Page(page int32) ApiV3ServiceBrokersGetRequest {
	r.page = &page
	return r
}

// Number of results per page; valid values are 1 through 5000
func (r ApiV3ServiceBrokersGetRequest) PerPage(perPage int32) ApiV3ServiceBrokersGetRequest {
	r.perPage = &perPage
	return r
}

// Comma-delimited list of space GUIDs to filter by
func (r ApiV3ServiceBrokersGetRequest) SpaceGuids(spaceGuids []string) ApiV3ServiceBrokersGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

// Value to sort by. Defaults to ascending; prepend with - to sort descending. Valid values are created_at, updated_at, name
func (r ApiV3ServiceBrokersGetRequest) OrderBy(orderBy string) ApiV3ServiceBrokersGetRequest {
	r.orderBy = &orderBy
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3ServiceBrokersGetRequest) LabelSelector(labelSelector string) ApiV3ServiceBrokersGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3ServiceBrokersGetRequest) CreatedAts(createdAts string) ApiV3ServiceBrokersGetRequest {
	r.createdAts = &createdAts
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3ServiceBrokersGetRequest) UpdatedAts(updatedAts string) ApiV3ServiceBrokersGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3ServiceBrokersGetRequest) Execute() (*ServiceBrokerList, *http.Response, error) {
	return r.ApiService.V3ServiceBrokersGetExecute(r)
}

/*
V3ServiceBrokersGet List service brokers

Retrieves the service brokers the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceBrokersGetRequest
*/
func (a *DefaultAPIService) V3ServiceBrokersGet(ctx context.Context) ApiV3ServiceBrokersGetRequest {
	return ApiV3ServiceBrokersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceBrokerList
func (a *DefaultAPIService) V3ServiceBrokersGetExecute(r ApiV3ServiceBrokersGetRequest) (*ServiceBrokerList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceBrokerList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceBrokersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_brokers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.spaceGuids != nil {
		t := *r.spaceGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", t, "form", "multi")
		}
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceBrokersGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceBrokersGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3ServiceBrokersGuidDeleteExecute(r)
}

/*
V3ServiceBrokersGuidDelete Delete a service broker

Creates a job to delete an existing service broker.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The service broker GUID
 @return ApiV3ServiceBrokersGuidDeleteRequest
*/
func (a *DefaultAPIService) V3ServiceBrokersGuidDelete(ctx context.Context, guid string) ApiV3ServiceBrokersGuidDeleteRequest {
	return ApiV3ServiceBrokersGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3ServiceBrokersGuidDeleteExecute(r ApiV3ServiceBrokersGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceBrokersGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_brokers/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3ServiceBrokersGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceBrokersGuidGetRequest) Execute() (*ServiceBroker, *http.Response, error) {
	return r.ApiService.V3ServiceBrokersGuidGetExecute(r)
}

/*
V3ServiceBrokersGuidGet Get a service broker

Retrieves the service broker by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The service broker GUID
 @return ApiV3ServiceBrokersGuidGetRequest
*/
func (a *DefaultAPIService) V3ServiceBrokersGuidGet(ctx context.Context, guid string) ApiV3ServiceBrokersGuidGetRequest {
	return ApiV3ServiceBrokersGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceBroker
func (a *DefaultAPIService) V3ServiceBrokersGuidGetExecute(r ApiV3ServiceBrokersGuidGetRequest) (*ServiceBroker, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceBroker
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceBrokersGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_brokers/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceBrokersGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	serviceBrokerUpdate *ServiceBrokerUpdate
}

func (r ApiV3ServiceBrokersGuidPatchRequest) ServiceBrokerUpdate(serviceBrokerUpdate ServiceBrokerUpdate) ApiV3ServiceBrokersGuidPatchRequest {
	r.serviceBrokerUpdate = &serviceBrokerUpdate
	return r
}

func (r ApiV3ServiceBrokersGuidPatchRequest) Execute() (*ServiceBroker, *http.Response, error) {
	return r.ApiService.V3ServiceBrokersGuidPatchExecute(r)
}

/*
V3ServiceBrokersGuidPatch Update a service broker

Updates a service broker.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The service broker GUID
 @return ApiV3ServiceBrokersGuidPatchRequest
*/
func (a *DefaultAPIService) V3ServiceBrokersGuidPatch(ctx context.Context, guid string) ApiV3ServiceBrokersGuidPatchRequest {
	return ApiV3ServiceBrokersGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceBroker
func (a *DefaultAPIService) V3ServiceBrokersGuidPatchExecute(r ApiV3ServiceBrokersGuidPatchRequest) (*ServiceBroker, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceBroker
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceBrokersGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_brokers/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceBrokerUpdate == nil {
		return localVarReturnValue, nil, reportError("serviceBrokerUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serviceBrokerUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceBrokersPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	serviceBrokerCreate *ServiceBrokerCreate
}

func (r ApiV3ServiceBrokersPostRequest) ServiceBrokerCreate(serviceBrokerCreate ServiceBrokerCreate) ApiV3ServiceBrokersPostRequest {
	r.serviceBrokerCreate = &serviceBrokerCreate
	return r
}

func (r ApiV3ServiceBrokersPostRequest) Execute() (*ServiceBroker, *http.Response, error) {
	return r.ApiService.V3ServiceBrokersPostExecute(r)
}

/*
V3ServiceBrokersPost Create a service broker

Creates a new service broker and a job to synchronize the service offerings and service plans with those in the broker’s catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceBrokersPostRequest
*/
func (a *DefaultAPIService) V3ServiceBrokersPost(ctx context.Context) ApiV3ServiceBrokersPostRequest {
	return ApiV3ServiceBrokersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceBroker
func (a *DefaultAPIService) V3ServiceBrokersPostExecute(r ApiV3ServiceBrokersPostRequest) (*ServiceBroker, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceBroker
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceBrokersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_brokers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceBrokerCreate == nil {
		return localVarReturnValue, nil, reportError("serviceBrokerCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serviceBrokerCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceCredentialBindingsGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceCredentialBindingsGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3ServiceCredentialBindingsGuidDeleteExecute(r)
}

/*
V3ServiceCredentialBindingsGuidDelete Delete a service credential binding

This endpoint deletes a service credential binding.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceCredentialBindingsGuidDeleteRequest
*/
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidDelete(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidDeleteRequest {
	return ApiV3ServiceCredentialBindingsGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidDeleteExecute(r ApiV3ServiceCredentialBindingsGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceCredentialBindingsGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_credential_bindings/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3ServiceCredentialBindingsGuidDetailsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceCredentialBindingsGuidDetailsGetRequest) Execute() (*V3ServiceCredentialBindingsGuidDetailsGet200Response, *http.Response, error) {
	return r.ApiService.V3ServiceCredentialBindingsGuidDetailsGetExecute(r)
}

/*
V3ServiceCredentialBindingsGuidDetailsGet Get a service credential binding details

This endpoint retrieves the service credential binding details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceCredentialBindingsGuidDetailsGetRequest
*/
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidDetailsGet(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidDetailsGetRequest {
	return ApiV3ServiceCredentialBindingsGuidDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3ServiceCredentialBindingsGuidDetailsGet200Response
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidDetailsGetExecute(r ApiV3ServiceCredentialBindingsGuidDetailsGetRequest) (*V3ServiceCredentialBindingsGuidDetailsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3ServiceCredentialBindingsGuidDetailsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceCredentialBindingsGuidDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_credential_bindings/{guid}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceCredentialBindingsGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	include *[]string
}

func (r ApiV3ServiceCredentialBindingsGuidGetRequest) Include(include []string) ApiV3ServiceCredentialBindingsGuidGetRequest {
	r.include = &include
	return r
}

func (r ApiV3ServiceCredentialBindingsGuidGetRequest) Execute() (*ServiceCredentialBinding, *http.Response, error) {
	return r.ApiService.V3ServiceCredentialBindingsGuidGetExecute(r)
}

/*
V3ServiceCredentialBindingsGuidGet Get a service credential binding

This endpoint retrieves the service credential binding by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceCredentialBindingsGuidGetRequest
*/
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidGet(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidGetRequest {
	return ApiV3ServiceCredentialBindingsGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceCredentialBinding
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidGetExecute(r ApiV3ServiceCredentialBindingsGuidGetRequest) (*ServiceCredentialBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceCredentialBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceCredentialBindingsGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_credential_bindings/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		t := *r.include
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "include", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "include", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceCredentialBindingsGuidParametersGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceCredentialBindingsGuidParametersGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V3ServiceCredentialBindingsGuidParametersGetExecute(r)
}

/*
V3ServiceCredentialBindingsGuidParametersGet Get parameters for a service credential binding

Queries the Service Broker for the parameters associated with this service credential binding.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceCredentialBindingsGuidParametersGetRequest
*/
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidParametersGet(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidParametersGetRequest {
	return ApiV3ServiceCredentialBindingsGuidParametersGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidParametersGetExecute(r ApiV3ServiceCredentialBindingsGuidParametersGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceCredentialBindingsGuidParametersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_credential_bindings/{guid}/parameters"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceCredentialBindingsGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3ServiceCredentialBindingsGuidPatchRequest *V3ServiceCredentialBindingsGuidPatchRequest
}

func (r ApiV3ServiceCredentialBindingsGuidPatchRequest) V3ServiceCredentialBindingsGuidPatchRequest(v3ServiceCredentialBindingsGuidPatchRequest V3ServiceCredentialBindingsGuidPatchRequest) ApiV3ServiceCredentialBindingsGuidPatchRequest {
	r.v3ServiceCredentialBindingsGuidPatchRequest = &v3ServiceCredentialBindingsGuidPatchRequest
	return r
}

func (r ApiV3ServiceCredentialBindingsGuidPatchRequest) Execute() (*ServiceCredentialBinding, *http.Response, error) {
	return r.ApiService.V3ServiceCredentialBindingsGuidPatchExecute(r)
}

/*
V3ServiceCredentialBindingsGuidPatch Update a service credential binding

This endpoint updates a service credential binding with labels and annotations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceCredentialBindingsGuidPatchRequest
*/
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidPatch(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidPatchRequest {
	return ApiV3ServiceCredentialBindingsGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceCredentialBinding
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidPatchExecute(r ApiV3ServiceCredentialBindingsGuidPatchRequest) (*ServiceCredentialBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceCredentialBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceCredentialBindingsGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_credential_bindings/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3ServiceCredentialBindingsGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3ServiceCredentialBindingsGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3ServiceCredentialBindingsGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceCredentialBindingsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	v3ServiceCredentialBindingsPostRequest *V3ServiceCredentialBindingsPostRequest
}

func (r ApiV3ServiceCredentialBindingsPostRequest) V3ServiceCredentialBindingsPostRequest(v3ServiceCredentialBindingsPostRequest V3ServiceCredentialBindingsPostRequest) ApiV3ServiceCredentialBindingsPostRequest {
	r.v3ServiceCredentialBindingsPostRequest = &v3ServiceCredentialBindingsPostRequest
	return r
}

func (r ApiV3ServiceCredentialBindingsPostRequest) Execute() (*ServiceCredentialBinding, *http.Response, error) {
	return r.ApiService.V3ServiceCredentialBindingsPostExecute(r)
}

/*
V3ServiceCredentialBindingsPost Create a service credential binding

This endpoint creates a new service credential binding. Service credential bindings can be of type app or key; key is only valid for managed service instances.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceCredentialBindingsPostRequest
*/
func (a *DefaultAPIService) V3ServiceCredentialBindingsPost(ctx context.Context) ApiV3ServiceCredentialBindingsPostRequest {
	return ApiV3ServiceCredentialBindingsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceCredentialBinding
func (a *DefaultAPIService) V3ServiceCredentialBindingsPostExecute(r ApiV3ServiceCredentialBindingsPostRequest) (*ServiceCredentialBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceCredentialBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceCredentialBindingsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_credential_bindings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3ServiceCredentialBindingsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3ServiceCredentialBindingsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3ServiceCredentialBindingsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceInstancesGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	names *[]string
	guids *[]string
	type_ *string
	spaceGuids *[]string
	organizationGuids *[]string
	servicePlanGuids *[]string
	servicePlanNames *[]string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *[]time.Time
	updatedAts *[]time.Time
}

// Comma-delimited list of service instance names to filter by
func (r ApiV3ServiceInstancesGetRequest) Names(names []string) ApiV3ServiceInstancesGetRequest {
	r.names = &names
	return r
}

// Comma-delimited list of service instance guids to filter by
func (r ApiV3ServiceInstancesGetRequest) Guids(guids []string) ApiV3ServiceInstancesGetRequest {
	r.guids = &guids
	return r
}

// Filter by type
func (r ApiV3ServiceInstancesGetRequest) Type_(type_ string) ApiV3ServiceInstancesGetRequest {
	r.type_ = &type_
	return r
}

// Comma-delimited list of space guids to filter by
func (r ApiV3ServiceInstancesGetRequest) SpaceGuids(spaceGuids []string) ApiV3ServiceInstancesGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

// Comma-delimited list of organization guids to filter by
func (r ApiV3ServiceInstancesGetRequest) OrganizationGuids(organizationGuids []string) ApiV3ServiceInstancesGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

// Comma-delimited list of service plan guids to filter by
func (r ApiV3ServiceInstancesGetRequest) ServicePlanGuids(servicePlanGuids []string) ApiV3ServiceInstancesGetRequest {
	r.servicePlanGuids = &servicePlanGuids
	return r
}

// Comma-delimited list of service plan names to filter by
func (r ApiV3ServiceInstancesGetRequest) ServicePlanNames(servicePlanNames []string) ApiV3ServiceInstancesGetRequest {
	r.servicePlanNames = &servicePlanNames
	return r
}

// Page to display
func (r ApiV3ServiceInstancesGetRequest) Page(page int32) ApiV3ServiceInstancesGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3ServiceInstancesGetRequest) PerPage(perPage int32) ApiV3ServiceInstancesGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by
func (r ApiV3ServiceInstancesGetRequest) OrderBy(orderBy string) ApiV3ServiceInstancesGetRequest {
	r.orderBy = &orderBy
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3ServiceInstancesGetRequest) LabelSelector(labelSelector string) ApiV3ServiceInstancesGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Timestamp to filter by
func (r ApiV3ServiceInstancesGetRequest) CreatedAts(createdAts []time.Time) ApiV3ServiceInstancesGetRequest {
	r.createdAts = &createdAts
	return r
}

// Timestamp to filter by
func (r ApiV3ServiceInstancesGetRequest) UpdatedAts(updatedAts []time.Time) ApiV3ServiceInstancesGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3ServiceInstancesGetRequest) Execute() (*V3ServiceInstancesGet200Response, *http.Response, error) {
	return r.ApiService.V3ServiceInstancesGetExecute(r)
}

/*
V3ServiceInstancesGet Retrieve service instances

Retrieves the service instances the user has access to, including access granted by service instance sharing.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceInstancesGetRequest
*/
func (a *DefaultAPIService) V3ServiceInstancesGet(ctx context.Context) ApiV3ServiceInstancesGetRequest {
	return ApiV3ServiceInstancesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3ServiceInstancesGet200Response
func (a *DefaultAPIService) V3ServiceInstancesGetExecute(r ApiV3ServiceInstancesGetRequest) (*V3ServiceInstancesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3ServiceInstancesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceInstancesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.guids != nil {
		t := *r.guids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guids", t, "form", "multi")
		}
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.spaceGuids != nil {
		t := *r.spaceGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", t, "form", "multi")
		}
	}
	if r.organizationGuids != nil {
		t := *r.organizationGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", t, "form", "multi")
		}
	}
	if r.servicePlanGuids != nil {
		t := *r.servicePlanGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_plan_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_plan_guids", t, "form", "multi")
		}
	}
	if r.servicePlanNames != nil {
		t := *r.servicePlanNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_plan_names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_plan_names", t, "form", "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		t := *r.createdAts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", t, "form", "multi")
		}
	}
	if r.updatedAts != nil {
		t := *r.updatedAts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceInstancesGuidCredentialsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceInstancesGuidCredentialsGetRequest) Execute() (map[string]string, *http.Response, error) {
	return r.ApiService.V3ServiceInstancesGuidCredentialsGetExecute(r)
}

/*
V3ServiceInstancesGuidCredentialsGet Get credentials for a user-provided service instance

Retrieves the credentials for a user-provided service instance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid GUID of the service instance
 @return ApiV3ServiceInstancesGuidCredentialsGetRequest
*/
func (a *DefaultAPIService) V3ServiceInstancesGuidCredentialsGet(ctx context.Context, guid string) ApiV3ServiceInstancesGuidCredentialsGetRequest {
	return ApiV3ServiceInstancesGuidCredentialsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return map[string]string
func (a *DefaultAPIService) V3ServiceInstancesGuidCredentialsGetExecute(r ApiV3ServiceInstancesGuidCredentialsGetRequest) (map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceInstancesGuidCredentialsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_instances/{guid}/credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceInstancesGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3ServiceInstancesGuidPatchRequest *V3ServiceInstancesGuidPatchRequest
}

func (r ApiV3ServiceInstancesGuidPatchRequest) V3ServiceInstancesGuidPatchRequest(v3ServiceInstancesGuidPatchRequest V3ServiceInstancesGuidPatchRequest) ApiV3ServiceInstancesGuidPatchRequest {
	r.v3ServiceInstancesGuidPatchRequest = &v3ServiceInstancesGuidPatchRequest
	return r
}

func (r ApiV3ServiceInstancesGuidPatchRequest) Execute() (*ServiceInstance, *http.Response, error) {
	return r.ApiService.V3ServiceInstancesGuidPatchExecute(r)
}

/*
V3ServiceInstancesGuidPatch Update a service instance

Updates a service instance with the provided attributes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid GUID of the service instance
 @return ApiV3ServiceInstancesGuidPatchRequest
*/
func (a *DefaultAPIService) V3ServiceInstancesGuidPatch(ctx context.Context, guid string) ApiV3ServiceInstancesGuidPatchRequest {
	return ApiV3ServiceInstancesGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceInstance
func (a *DefaultAPIService) V3ServiceInstancesGuidPatchExecute(r ApiV3ServiceInstancesGuidPatchRequest) (*ServiceInstance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceInstancesGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_instances/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3ServiceInstancesGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest *V3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest
}

func (r ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest) V3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest(v3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest V3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest) ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest {
	r.v3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest = &v3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest
	return r
}

func (r ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest) Execute() (*V3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest, *http.Response, error) {
	return r.ApiService.V3ServiceInstancesGuidRelationshipsSharedSpacesPostExecute(r)
}

/*
V3ServiceInstancesGuidRelationshipsSharedSpacesPost Share a service instance to other spaces

Shares the service instance with the specified spaces.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid GUID of the service instance
 @return ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest
*/
func (a *DefaultAPIService) V3ServiceInstancesGuidRelationshipsSharedSpacesPost(ctx context.Context, guid string) ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest {
	return ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest
func (a *DefaultAPIService) V3ServiceInstancesGuidRelationshipsSharedSpacesPostExecute(r ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest) (*V3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceInstancesGuidRelationshipsSharedSpacesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_instances/{guid}/relationships/shared_spaces"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	spaceGuid string
}

func (r ApiV3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteExecute(r)
}

/*
V3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDelete Unshare a service instance from another space

Unshares the service instance from the specified space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid GUID of the service instance
 @param spaceGuid GUID of the space
 @return ApiV3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteRequest
*/
func (a *DefaultAPIService) V3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDelete(ctx context.Context, guid string, spaceGuid string) ApiV3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteRequest {
	return ApiV3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
		spaceGuid: spaceGuid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteExecute(r ApiV3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_instances/{guid}/relationships/shared_spaces/{space_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"space_guid"+"}", url.PathEscape(parameterValueToString(r.spaceGuid, "spaceGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3ServiceInstancesGuidRelationshipsSharedSpacesUsageSummaryGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceInstancesGuidRelationshipsSharedSpacesUsageSummaryGetRequest) Execute() (*UsageSummary, *http.Response, error) {
	return r.ApiService.V3ServiceInstancesGuidRelationshipsSharedSpacesUsageSummaryGetExecute(r)
}

/*
V3ServiceInstancesGuidRelationshipsSharedSpacesUsageSummaryGet Get usage summary in shared spaces

Returns the number of bound apps in spaces where the service instance has been shared to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid GUID of the service instance
 @return ApiV3ServiceInstancesGuidRelationshipsSharedSpacesUsageSummaryGetRequest
*/
func (a *DefaultAPIService) V3ServiceInstancesGuidRelationshipsSharedSpacesUsageSummaryGet(ctx context.Context, guid string) ApiV3ServiceInstancesGuidRelationshipsSharedSpacesUsageSummaryGetRequest {
	return ApiV3ServiceInstancesGuidRelationshipsSharedSpacesUsageSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return UsageSummary
func (a *DefaultAPIService) V3ServiceInstancesGuidRelationshipsSharedSpacesUsageSummaryGetExecute(r ApiV3ServiceInstancesGuidRelationshipsSharedSpacesUsageSummaryGetRequest) (*UsageSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsageSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceInstancesGuidRelationshipsSharedSpacesUsageSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_instances/{guid}/relationships/shared_spaces/usage_summary"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceOfferingsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	names *[]string
	available *bool
	serviceBrokerGuids *[]string
	serviceBrokerNames *[]string
	spaceGuids *[]string
	organizationGuids *[]string
	labelSelector *string
	orderBy *string
	page *int32
	perPage *int32
	createdAts *string
	updatedAts *string
}

// Comma-delimited list of names to filter by
func (r ApiV3ServiceOfferingsGetRequest) Names(names []string) ApiV3ServiceOfferingsGetRequest {
	r.names = &names
	return r
}

// Filter by the available property; valid values are true or false
func (r ApiV3ServiceOfferingsGetRequest) Available(available bool) ApiV3ServiceOfferingsGetRequest {
	r.available = &available
	return r
}

// Comma-delimited list of service broker GUIDs to filter by
func (r ApiV3ServiceOfferingsGetRequest) ServiceBrokerGuids(serviceBrokerGuids []string) ApiV3ServiceOfferingsGetRequest {
	r.serviceBrokerGuids = &serviceBrokerGuids
	return r
}

// Comma-delimited list of service broker names to filter by
func (r ApiV3ServiceOfferingsGetRequest) ServiceBrokerNames(serviceBrokerNames []string) ApiV3ServiceOfferingsGetRequest {
	r.serviceBrokerNames = &serviceBrokerNames
	return r
}

// Comma-delimited list of space GUIDs to filter by
func (r ApiV3ServiceOfferingsGetRequest) SpaceGuids(spaceGuids []string) ApiV3ServiceOfferingsGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

// Comma-delimited list of organization GUIDs to filter by
func (r ApiV3ServiceOfferingsGetRequest) OrganizationGuids(organizationGuids []string) ApiV3ServiceOfferingsGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3ServiceOfferingsGetRequest) LabelSelector(labelSelector string) ApiV3ServiceOfferingsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Value to sort by. Defaults to ascending; prepend with - to sort descending. Valid values are created_at, updated_at, name
func (r ApiV3ServiceOfferingsGetRequest) OrderBy(orderBy string) ApiV3ServiceOfferingsGetRequest {
	r.orderBy = &orderBy
	return r
}

// Page to display; valid values are integers &gt;&#x3D; 1
func (r ApiV3ServiceOfferingsGetRequest) Page(page int32) ApiV3ServiceOfferingsGetRequest {
	r.page = &page
	return r
}

// Number of results per page; valid values are 1 through 5000
func (r ApiV3ServiceOfferingsGetRequest) PerPage(perPage int32) ApiV3ServiceOfferingsGetRequest {
	r.perPage = &perPage
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3ServiceOfferingsGetRequest) CreatedAts(createdAts string) ApiV3ServiceOfferingsGetRequest {
	r.createdAts = &createdAts
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3ServiceOfferingsGetRequest) UpdatedAts(updatedAts string) ApiV3ServiceOfferingsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3ServiceOfferingsGetRequest) Execute() (*ServiceOfferingList, *http.Response, error) {
	return r.ApiService.V3ServiceOfferingsGetExecute(r)
}

/*
V3ServiceOfferingsGet List service offerings

Retrieves the service offerings the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceOfferingsGetRequest
*/
func (a *DefaultAPIService) V3ServiceOfferingsGet(ctx context.Context) ApiV3ServiceOfferingsGetRequest {
	return ApiV3ServiceOfferingsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceOfferingList
func (a *DefaultAPIService) V3ServiceOfferingsGetExecute(r ApiV3ServiceOfferingsGetRequest) (*ServiceOfferingList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceOfferingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceOfferingsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_offerings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.available != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "available", r.available, "form", "")
	}
	if r.serviceBrokerGuids != nil {
		t := *r.serviceBrokerGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_broker_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_broker_guids", t, "form", "multi")
		}
	}
	if r.serviceBrokerNames != nil {
		t := *r.serviceBrokerNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_broker_names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_broker_names", t, "form", "multi")
		}
	}
	if r.spaceGuids != nil {
		t := *r.spaceGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", t, "form", "multi")
		}
	}
	if r.organizationGuids != nil {
		t := *r.organizationGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", t, "form", "multi")
		}
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceOfferingsGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	purge *bool
}

// If true, any service plans, instances, and bindings associated with this service offering will also be deleted
func (r ApiV3ServiceOfferingsGuidDeleteRequest) Purge(purge bool) ApiV3ServiceOfferingsGuidDeleteRequest {
	r.purge = &purge
	return r
}

func (r ApiV3ServiceOfferingsGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3ServiceOfferingsGuidDeleteExecute(r)
}

/*
V3ServiceOfferingsGuidDelete Delete a service offering

Deletes a service offering.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The service offering GUID
 @return ApiV3ServiceOfferingsGuidDeleteRequest
*/
func (a *DefaultAPIService) V3ServiceOfferingsGuidDelete(ctx context.Context, guid string) ApiV3ServiceOfferingsGuidDeleteRequest {
	return ApiV3ServiceOfferingsGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3ServiceOfferingsGuidDeleteExecute(r ApiV3ServiceOfferingsGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceOfferingsGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_offerings/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.purge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purge", r.purge, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3ServiceOfferingsGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceOfferingsGuidGetRequest) Execute() (*ServiceOffering, *http.Response, error) {
	return r.ApiService.V3ServiceOfferingsGuidGetExecute(r)
}

/*
V3ServiceOfferingsGuidGet Get a service offering

Retrieves the service offering by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The service offering GUID
 @return ApiV3ServiceOfferingsGuidGetRequest
*/
func (a *DefaultAPIService) V3ServiceOfferingsGuidGet(ctx context.Context, guid string) ApiV3ServiceOfferingsGuidGetRequest {
	return ApiV3ServiceOfferingsGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceOffering
func (a *DefaultAPIService) V3ServiceOfferingsGuidGetExecute(r ApiV3ServiceOfferingsGuidGetRequest) (*ServiceOffering, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceOffering
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceOfferingsGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_offerings/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceOfferingsGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	serviceOfferingUpdate *ServiceOfferingUpdate
}

func (r ApiV3ServiceOfferingsGuidPatchRequest) ServiceOfferingUpdate(serviceOfferingUpdate ServiceOfferingUpdate) ApiV3ServiceOfferingsGuidPatchRequest {
	r.serviceOfferingUpdate = &serviceOfferingUpdate
	return r
}

func (r ApiV3ServiceOfferingsGuidPatchRequest) Execute() (*ServiceOffering, *http.Response, error) {
	return r.ApiService.V3ServiceOfferingsGuidPatchExecute(r)
}

/*
V3ServiceOfferingsGuidPatch Update a service offering

Updates a service offering.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The service offering GUID
 @return ApiV3ServiceOfferingsGuidPatchRequest
*/
func (a *DefaultAPIService) V3ServiceOfferingsGuidPatch(ctx context.Context, guid string) ApiV3ServiceOfferingsGuidPatchRequest {
	return ApiV3ServiceOfferingsGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceOffering
func (a *DefaultAPIService) V3ServiceOfferingsGuidPatchExecute(r ApiV3ServiceOfferingsGuidPatchRequest) (*ServiceOffering, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceOffering
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceOfferingsGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_offerings/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceOfferingUpdate == nil {
		return localVarReturnValue, nil, reportError("serviceOfferingUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serviceOfferingUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceOfferingsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	serviceOfferingCreate *ServiceOfferingCreate
}

func (r ApiV3ServiceOfferingsPostRequest) ServiceOfferingCreate(serviceOfferingCreate ServiceOfferingCreate) ApiV3ServiceOfferingsPostRequest {
	r.serviceOfferingCreate = &serviceOfferingCreate
	return r
}

func (r ApiV3ServiceOfferingsPostRequest) Execute() (*ServiceOffering, *http.Response, error) {
	return r.ApiService.V3ServiceOfferingsPostExecute(r)
}

/*
V3ServiceOfferingsPost Create a service offering

Creates a new service offering.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceOfferingsPostRequest
*/
func (a *DefaultAPIService) V3ServiceOfferingsPost(ctx context.Context) ApiV3ServiceOfferingsPostRequest {
	return ApiV3ServiceOfferingsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceOffering
func (a *DefaultAPIService) V3ServiceOfferingsPostExecute(r ApiV3ServiceOfferingsPostRequest) (*ServiceOffering, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceOffering
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceOfferingsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_offerings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceOfferingCreate == nil {
		return localVarReturnValue, nil, reportError("serviceOfferingCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serviceOfferingCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServicePlansGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	names *[]string
	available *bool
	brokerCatalogIds *[]string
	spaceGuids *[]string
	organizationGuids *[]string
	serviceBrokerGuids *[]string
	serviceBrokerNames *[]string
	serviceOfferingGuids *[]string
	serviceOfferingNames *[]string
	serviceInstanceGuids *[]string
	include *[]string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	fields *string
	createdAts *string
	updatedAts *string
}

// Comma-delimited list of names to filter by
func (r ApiV3ServicePlansGetRequest) Names(names []string) ApiV3ServicePlansGetRequest {
	r.names = &names
	return r
}

// Filter by the available property; valid values are true or false
func (r ApiV3ServicePlansGetRequest) Available(available bool) ApiV3ServicePlansGetRequest {
	r.available = &available
	return r
}

// Comma-delimited list of IDs provided by the service broker for the service plan to filter by
func (r ApiV3ServicePlansGetRequest) BrokerCatalogIds(brokerCatalogIds []string) ApiV3ServicePlansGetRequest {
	r.brokerCatalogIds = &brokerCatalogIds
	return r
}

// Comma-delimited list of space GUIDs to filter by
func (r ApiV3ServicePlansGetRequest) SpaceGuids(spaceGuids []string) ApiV3ServicePlansGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

// Comma-delimited list of organization GUIDs to filter by
func (r ApiV3ServicePlansGetRequest) OrganizationGuids(organizationGuids []string) ApiV3ServicePlansGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

// Comma-delimited list of service broker GUIDs to filter by
func (r ApiV3ServicePlansGetRequest) ServiceBrokerGuids(serviceBrokerGuids []string) ApiV3ServicePlansGetRequest {
	r.serviceBrokerGuids = &serviceBrokerGuids
	return r
}

// Comma-delimited list of service broker names to filter by
func (r ApiV3ServicePlansGetRequest) ServiceBrokerNames(serviceBrokerNames []string) ApiV3ServicePlansGetRequest {
	r.serviceBrokerNames = &serviceBrokerNames
	return r
}

// Comma-delimited list of service Offering GUIDs to filter by
func (r ApiV3ServicePlansGetRequest) ServiceOfferingGuids(serviceOfferingGuids []string) ApiV3ServicePlansGetRequest {
	r.serviceOfferingGuids = &serviceOfferingGuids
	return r
}

// Comma-delimited list of service Offering names to filter by
func (r ApiV3ServicePlansGetRequest) ServiceOfferingNames(serviceOfferingNames []string) ApiV3ServicePlansGetRequest {
	r.serviceOfferingNames = &serviceOfferingNames
	return r
}

// Comma-delimited list of service Instance GUIDs to filter by
func (r ApiV3ServicePlansGetRequest) ServiceInstanceGuids(serviceInstanceGuids []string) ApiV3ServicePlansGetRequest {
	r.serviceInstanceGuids = &serviceInstanceGuids
	return r
}

// Optionally include a list of related resources in the response; valid values are space.organization and service_offering
func (r ApiV3ServicePlansGetRequest) Include(include []string) ApiV3ServicePlansGetRequest {
	r.include = &include
	return r
}

// Page to display; valid values are integers &gt;&#x3D; 1
func (r ApiV3ServicePlansGetRequest) Page(page int32) ApiV3ServicePlansGetRequest {
	r.page = &page
	return r
}

// Number of results per page; valid values are 1 through 5000
func (r ApiV3ServicePlansGetRequest) PerPage(perPage int32) ApiV3ServicePlansGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by. Defaults to ascending; prepend with - to sort descending. Valid values are created_at, updated_at, name
func (r ApiV3ServicePlansGetRequest) OrderBy(orderBy string) ApiV3ServicePlansGetRequest {
	r.orderBy = &orderBy
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3ServicePlansGetRequest) LabelSelector(labelSelector string) ApiV3ServicePlansGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Allowed values for fields
func (r ApiV3ServicePlansGetRequest) Fields(fields string) ApiV3ServicePlansGetRequest {
	r.fields = &fields
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3ServicePlansGetRequest) CreatedAts(createdAts string) ApiV3ServicePlansGetRequest {
	r.createdAts = &createdAts
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3ServicePlansGetRequest) UpdatedAts(updatedAts string) ApiV3ServicePlansGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3ServicePlansGetRequest) Execute() (*ServicePlanList, *http.Response, error) {
	return r.ApiService.V3ServicePlansGetExecute(r)
}

/*
V3ServicePlansGet List service plans

Retrieves the service plans the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServicePlansGetRequest
*/
func (a *DefaultAPIService) V3ServicePlansGet(ctx context.Context) ApiV3ServicePlansGetRequest {
	return ApiV3ServicePlansGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServicePlanList
func (a *DefaultAPIService) V3ServicePlansGetExecute(r ApiV3ServicePlansGetRequest) (*ServicePlanList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServicePlanList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServicePlansGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_plans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.available != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "available", r.available, "form", "")
	}
	if r.brokerCatalogIds != nil {
		t := *r.brokerCatalogIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "broker_catalog_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "broker_catalog_ids", t, "form", "multi")
		}
	}
	if r.spaceGuids != nil {
		t := *r.spaceGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", t, "form", "multi")
		}
	}
	if r.organizationGuids != nil {
		t := *r.organizationGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", t, "form", "multi")
		}
	}
	if r.serviceBrokerGuids != nil {
		t := *r.serviceBrokerGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_broker_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_broker_guids", t, "form", "multi")
		}
	}
	if r.serviceBrokerNames != nil {
		t := *r.serviceBrokerNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_broker_names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_broker_names", t, "form", "multi")
		}
	}
	if r.serviceOfferingGuids != nil {
		t := *r.serviceOfferingGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_offering_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_offering_guids", t, "form", "multi")
		}
	}
	if r.serviceOfferingNames != nil {
		t := *r.serviceOfferingNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_offering_names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_offering_names", t, "form", "multi")
		}
	}
	if r.serviceInstanceGuids != nil {
		t := *r.serviceInstanceGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_instance_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_instance_guids", t, "form", "multi")
		}
	}
	if r.include != nil {
		t := *r.include
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "include", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "include", t, "form", "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServicePlansGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	purge *bool
}

// If true, any service plans, instances, and bindings associated with this service plan will also be deleted
func (r ApiV3ServicePlansGuidDeleteRequest) Purge(purge bool) ApiV3ServicePlansGuidDeleteRequest {
	r.purge = &purge
	return r
}

func (r ApiV3ServicePlansGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3ServicePlansGuidDeleteExecute(r)
}

/*
V3ServicePlansGuidDelete Delete a service plan

Deletes a service plan.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The service plan GUID
 @return ApiV3ServicePlansGuidDeleteRequest
*/
func (a *DefaultAPIService) V3ServicePlansGuidDelete(ctx context.Context, guid string) ApiV3ServicePlansGuidDeleteRequest {
	return ApiV3ServicePlansGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3ServicePlansGuidDeleteExecute(r ApiV3ServicePlansGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServicePlansGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_plans/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.purge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purge", r.purge, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3ServicePlansGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServicePlansGuidGetRequest) Execute() (*ServicePlan, *http.Response, error) {
	return r.ApiService.V3ServicePlansGuidGetExecute(r)
}

/*
V3ServicePlansGuidGet Get a service plan

Retrieves the service plan by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The service plan GUID
 @return ApiV3ServicePlansGuidGetRequest
*/
func (a *DefaultAPIService) V3ServicePlansGuidGet(ctx context.Context, guid string) ApiV3ServicePlansGuidGetRequest {
	return ApiV3ServicePlansGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServicePlan
func (a *DefaultAPIService) V3ServicePlansGuidGetExecute(r ApiV3ServicePlansGuidGetRequest) (*ServicePlan, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServicePlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServicePlansGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_plans/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServicePlansGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	servicePlanUpdate *ServicePlanUpdate
}

func (r ApiV3ServicePlansGuidPatchRequest) ServicePlanUpdate(servicePlanUpdate ServicePlanUpdate) ApiV3ServicePlansGuidPatchRequest {
	r.servicePlanUpdate = &servicePlanUpdate
	return r
}

func (r ApiV3ServicePlansGuidPatchRequest) Execute() (*ServicePlan, *http.Response, error) {
	return r.ApiService.V3ServicePlansGuidPatchExecute(r)
}

/*
V3ServicePlansGuidPatch Update a service plan

Updates a service plan.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The service plan GUID
 @return ApiV3ServicePlansGuidPatchRequest
*/
func (a *DefaultAPIService) V3ServicePlansGuidPatch(ctx context.Context, guid string) ApiV3ServicePlansGuidPatchRequest {
	return ApiV3ServicePlansGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServicePlan
func (a *DefaultAPIService) V3ServicePlansGuidPatchExecute(r ApiV3ServicePlansGuidPatchRequest) (*ServicePlan, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServicePlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServicePlansGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_plans/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.servicePlanUpdate == nil {
		return localVarReturnValue, nil, reportError("servicePlanUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.servicePlanUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServicePlansGuidVisibilityGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServicePlansGuidVisibilityGetRequest) Execute() (*ServicePlanVisibility, *http.Response, error) {
	return r.ApiService.V3ServicePlansGuidVisibilityGetExecute(r)
}

/*
V3ServicePlansGuidVisibilityGet Get a service plan visibility

Retrieves the service plan visibility for a given plan.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The service plan GUID
 @return ApiV3ServicePlansGuidVisibilityGetRequest
*/
func (a *DefaultAPIService) V3ServicePlansGuidVisibilityGet(ctx context.Context, guid string) ApiV3ServicePlansGuidVisibilityGetRequest {
	return ApiV3ServicePlansGuidVisibilityGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServicePlanVisibility
func (a *DefaultAPIService) V3ServicePlansGuidVisibilityGetExecute(r ApiV3ServicePlansGuidVisibilityGetRequest) (*ServicePlanVisibility, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServicePlanVisibility
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServicePlansGuidVisibilityGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_plans/{guid}/visibility"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServicePlansGuidVisibilityOrganizationGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	organizationGuid string
}

func (r ApiV3ServicePlansGuidVisibilityOrganizationGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3ServicePlansGuidVisibilityOrganizationGuidDeleteExecute(r)
}

/*
V3ServicePlansGuidVisibilityOrganizationGuidDelete Remove organization from a service plan visibility

Removes an organization from a service plan visibility list of organizations. Defined only for service plans which are organization-restricted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The service plan GUID
 @param organizationGuid The organization GUID
 @return ApiV3ServicePlansGuidVisibilityOrganizationGuidDeleteRequest
*/
func (a *DefaultAPIService) V3ServicePlansGuidVisibilityOrganizationGuidDelete(ctx context.Context, guid string, organizationGuid string) ApiV3ServicePlansGuidVisibilityOrganizationGuidDeleteRequest {
	return ApiV3ServicePlansGuidVisibilityOrganizationGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
		organizationGuid: organizationGuid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3ServicePlansGuidVisibilityOrganizationGuidDeleteExecute(r ApiV3ServicePlansGuidVisibilityOrganizationGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServicePlansGuidVisibilityOrganizationGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_plans/{guid}/visibility/{organization_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organization_guid"+"}", url.PathEscape(parameterValueToString(r.organizationGuid, "organizationGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3ServicePlansGuidVisibilityPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	servicePlanVisibilityUpdate *ServicePlanVisibilityUpdate
}

func (r ApiV3ServicePlansGuidVisibilityPatchRequest) ServicePlanVisibilityUpdate(servicePlanVisibilityUpdate ServicePlanVisibilityUpdate) ApiV3ServicePlansGuidVisibilityPatchRequest {
	r.servicePlanVisibilityUpdate = &servicePlanVisibilityUpdate
	return r
}

func (r ApiV3ServicePlansGuidVisibilityPatchRequest) Execute() (*ServicePlanVisibility, *http.Response, error) {
	return r.ApiService.V3ServicePlansGuidVisibilityPatchExecute(r)
}

/*
V3ServicePlansGuidVisibilityPatch Update a service plan visibility

Updates a service plan visibility. Replaces the existing list of organizations when the service plan is organization visible.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The service plan GUID
 @return ApiV3ServicePlansGuidVisibilityPatchRequest
*/
func (a *DefaultAPIService) V3ServicePlansGuidVisibilityPatch(ctx context.Context, guid string) ApiV3ServicePlansGuidVisibilityPatchRequest {
	return ApiV3ServicePlansGuidVisibilityPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServicePlanVisibility
func (a *DefaultAPIService) V3ServicePlansGuidVisibilityPatchExecute(r ApiV3ServicePlansGuidVisibilityPatchRequest) (*ServicePlanVisibility, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServicePlanVisibility
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServicePlansGuidVisibilityPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_plans/{guid}/visibility"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.servicePlanVisibilityUpdate == nil {
		return localVarReturnValue, nil, reportError("servicePlanVisibilityUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.servicePlanVisibilityUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServicePlansGuidVisibilityPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	servicePlanVisibilityApply *ServicePlanVisibilityApply
}

func (r ApiV3ServicePlansGuidVisibilityPostRequest) ServicePlanVisibilityApply(servicePlanVisibilityApply ServicePlanVisibilityApply) ApiV3ServicePlansGuidVisibilityPostRequest {
	r.servicePlanVisibilityApply = &servicePlanVisibilityApply
	return r
}

func (r ApiV3ServicePlansGuidVisibilityPostRequest) Execute() (*ServicePlanVisibility, *http.Response, error) {
	return r.ApiService.V3ServicePlansGuidVisibilityPostExecute(r)
}

/*
V3ServicePlansGuidVisibilityPost Apply a service plan visibility

Applies a service plan visibility. Appends to the existing list of organizations when the service plan is organization visible.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The service plan GUID
 @return ApiV3ServicePlansGuidVisibilityPostRequest
*/
func (a *DefaultAPIService) V3ServicePlansGuidVisibilityPost(ctx context.Context, guid string) ApiV3ServicePlansGuidVisibilityPostRequest {
	return ApiV3ServicePlansGuidVisibilityPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServicePlanVisibility
func (a *DefaultAPIService) V3ServicePlansGuidVisibilityPostExecute(r ApiV3ServicePlansGuidVisibilityPostRequest) (*ServicePlanVisibility, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServicePlanVisibility
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServicePlansGuidVisibilityPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_plans/{guid}/visibility"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.servicePlanVisibilityApply == nil {
		return localVarReturnValue, nil, reportError("servicePlanVisibilityApply is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.servicePlanVisibilityApply
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServicePlansPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	servicePlanCreate *ServicePlanCreate
}

func (r ApiV3ServicePlansPostRequest) ServicePlanCreate(servicePlanCreate ServicePlanCreate) ApiV3ServicePlansPostRequest {
	r.servicePlanCreate = &servicePlanCreate
	return r
}

func (r ApiV3ServicePlansPostRequest) Execute() (*ServicePlan, *http.Response, error) {
	return r.ApiService.V3ServicePlansPostExecute(r)
}

/*
V3ServicePlansPost Create a service plan

Creates a new service plan.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServicePlansPostRequest
*/
func (a *DefaultAPIService) V3ServicePlansPost(ctx context.Context) ApiV3ServicePlansPostRequest {
	return ApiV3ServicePlansPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServicePlan
func (a *DefaultAPIService) V3ServicePlansPostExecute(r ApiV3ServicePlansPostRequest) (*ServicePlan, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServicePlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServicePlansPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_plans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.servicePlanCreate == nil {
		return localVarReturnValue, nil, reportError("servicePlanCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.servicePlanCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceRouteBindingsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	routeGuids *[]string
	serviceInstanceGuids *[]string
	serviceInstanceNames *[]string
	labelSelector *string
	guids *[]string
	createdAts *string
	updatedAts *string
	include *[]string
	page *int32
	perPage *int32
	orderBy *string
}

func (r ApiV3ServiceRouteBindingsGetRequest) RouteGuids(routeGuids []string) ApiV3ServiceRouteBindingsGetRequest {
	r.routeGuids = &routeGuids
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) ServiceInstanceGuids(serviceInstanceGuids []string) ApiV3ServiceRouteBindingsGetRequest {
	r.serviceInstanceGuids = &serviceInstanceGuids
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) ServiceInstanceNames(serviceInstanceNames []string) ApiV3ServiceRouteBindingsGetRequest {
	r.serviceInstanceNames = &serviceInstanceNames
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) LabelSelector(labelSelector string) ApiV3ServiceRouteBindingsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) Guids(guids []string) ApiV3ServiceRouteBindingsGetRequest {
	r.guids = &guids
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) CreatedAts(createdAts string) ApiV3ServiceRouteBindingsGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) UpdatedAts(updatedAts string) ApiV3ServiceRouteBindingsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) Include(include []string) ApiV3ServiceRouteBindingsGetRequest {
	r.include = &include
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) Page(page int32) ApiV3ServiceRouteBindingsGetRequest {
	r.page = &page
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) PerPage(perPage int32) ApiV3ServiceRouteBindingsGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) OrderBy(orderBy string) ApiV3ServiceRouteBindingsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) Execute() (*V3ServiceRouteBindingsGet200Response, *http.Response, error) {
	return r.ApiService.V3ServiceRouteBindingsGetExecute(r)
}

/*
V3ServiceRouteBindingsGet List service route bindings

Retrieves the service route bindings the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceRouteBindingsGetRequest
*/
func (a *DefaultAPIService) V3ServiceRouteBindingsGet(ctx context.Context) ApiV3ServiceRouteBindingsGetRequest {
	return ApiV3ServiceRouteBindingsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3ServiceRouteBindingsGet200Response
func (a *DefaultAPIService) V3ServiceRouteBindingsGetExecute(r ApiV3ServiceRouteBindingsGetRequest) (*V3ServiceRouteBindingsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3ServiceRouteBindingsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceRouteBindingsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_route_bindings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.routeGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "route_guids", r.routeGuids, "form", "csv")
	}
	if r.serviceInstanceGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "service_instance_guids", r.serviceInstanceGuids, "form", "csv")
	}
	if r.serviceInstanceNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "service_instance_names", r.serviceInstanceNames, "form", "csv")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "csv")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceRouteBindingsGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceRouteBindingsGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3ServiceRouteBindingsGuidDeleteExecute(r)
}

/*
V3ServiceRouteBindingsGuidDelete Delete a service route binding

Deletes a service route binding. When deleting route bindings originating from user-provided service instances, the delete operation does not require interactions with service brokers, therefore the API will respond synchronously to the delete request.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceRouteBindingsGuidDeleteRequest
*/
func (a *DefaultAPIService) V3ServiceRouteBindingsGuidDelete(ctx context.Context, guid string) ApiV3ServiceRouteBindingsGuidDeleteRequest {
	return ApiV3ServiceRouteBindingsGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3ServiceRouteBindingsGuidDeleteExecute(r ApiV3ServiceRouteBindingsGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceRouteBindingsGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_route_bindings/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3ServiceRouteBindingsGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	include *[]string
}

func (r ApiV3ServiceRouteBindingsGuidGetRequest) Include(include []string) ApiV3ServiceRouteBindingsGuidGetRequest {
	r.include = &include
	return r
}

func (r ApiV3ServiceRouteBindingsGuidGetRequest) Execute() (*ServiceRouteBinding, *http.Response, error) {
	return r.ApiService.V3ServiceRouteBindingsGuidGetExecute(r)
}

/*
V3ServiceRouteBindingsGuidGet Get a service route binding

Retrieves the service route binding by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceRouteBindingsGuidGetRequest
*/
func (a *DefaultAPIService) V3ServiceRouteBindingsGuidGet(ctx context.Context, guid string) ApiV3ServiceRouteBindingsGuidGetRequest {
	return ApiV3ServiceRouteBindingsGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceRouteBinding
func (a *DefaultAPIService) V3ServiceRouteBindingsGuidGetExecute(r ApiV3ServiceRouteBindingsGuidGetRequest) (*ServiceRouteBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceRouteBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceRouteBindingsGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_route_bindings/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		t := *r.include
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "include", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "include", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceRouteBindingsGuidParametersGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceRouteBindingsGuidParametersGetRequest) Execute() (map[string]string, *http.Response, error) {
	return r.ApiService.V3ServiceRouteBindingsGuidParametersGetExecute(r)
}

/*
V3ServiceRouteBindingsGuidParametersGet Get parameters for a route binding

Queries the Service Broker for the parameters associated with this service route binding. This endpoint is not available for User-Provided Service Instances.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceRouteBindingsGuidParametersGetRequest
*/
func (a *DefaultAPIService) V3ServiceRouteBindingsGuidParametersGet(ctx context.Context, guid string) ApiV3ServiceRouteBindingsGuidParametersGetRequest {
	return ApiV3ServiceRouteBindingsGuidParametersGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return map[string]string
func (a *DefaultAPIService) V3ServiceRouteBindingsGuidParametersGetExecute(r ApiV3ServiceRouteBindingsGuidParametersGetRequest) (map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceRouteBindingsGuidParametersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_route_bindings/{guid}/parameters"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceRouteBindingsGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3ServiceRouteBindingsGuidPatchRequest *V3ServiceRouteBindingsGuidPatchRequest
}

func (r ApiV3ServiceRouteBindingsGuidPatchRequest) V3ServiceRouteBindingsGuidPatchRequest(v3ServiceRouteBindingsGuidPatchRequest V3ServiceRouteBindingsGuidPatchRequest) ApiV3ServiceRouteBindingsGuidPatchRequest {
	r.v3ServiceRouteBindingsGuidPatchRequest = &v3ServiceRouteBindingsGuidPatchRequest
	return r
}

func (r ApiV3ServiceRouteBindingsGuidPatchRequest) Execute() (*ServiceRouteBinding, *http.Response, error) {
	return r.ApiService.V3ServiceRouteBindingsGuidPatchExecute(r)
}

/*
V3ServiceRouteBindingsGuidPatch Update a service route binding

Updates a service route binding with labels and annotations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceRouteBindingsGuidPatchRequest
*/
func (a *DefaultAPIService) V3ServiceRouteBindingsGuidPatch(ctx context.Context, guid string) ApiV3ServiceRouteBindingsGuidPatchRequest {
	return ApiV3ServiceRouteBindingsGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceRouteBinding
func (a *DefaultAPIService) V3ServiceRouteBindingsGuidPatchExecute(r ApiV3ServiceRouteBindingsGuidPatchRequest) (*ServiceRouteBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceRouteBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceRouteBindingsGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_route_bindings/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3ServiceRouteBindingsGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3ServiceRouteBindingsGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3ServiceRouteBindingsGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceRouteBindingsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	v3ServiceRouteBindingsPostRequest *V3ServiceRouteBindingsPostRequest
}

func (r ApiV3ServiceRouteBindingsPostRequest) V3ServiceRouteBindingsPostRequest(v3ServiceRouteBindingsPostRequest V3ServiceRouteBindingsPostRequest) ApiV3ServiceRouteBindingsPostRequest {
	r.v3ServiceRouteBindingsPostRequest = &v3ServiceRouteBindingsPostRequest
	return r
}

func (r ApiV3ServiceRouteBindingsPostRequest) Execute() (*ServiceRouteBinding, *http.Response, error) {
	return r.ApiService.V3ServiceRouteBindingsPostExecute(r)
}

/*
V3ServiceRouteBindingsPost Create a service route binding

Creates a new route service binding. The service instance and the route must be in the same space.
To bind a route to a user-provided service instance, the service instance must have the route_service_url property set.
To bind a route to a managed service instance, the service offering must be bindable, and the service offering must have route_forwarding set in the requires property.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceRouteBindingsPostRequest
*/
func (a *DefaultAPIService) V3ServiceRouteBindingsPost(ctx context.Context) ApiV3ServiceRouteBindingsPostRequest {
	return ApiV3ServiceRouteBindingsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceRouteBinding
func (a *DefaultAPIService) V3ServiceRouteBindingsPostExecute(r ApiV3ServiceRouteBindingsPostRequest) (*ServiceRouteBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceRouteBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceRouteBindingsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_route_bindings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3ServiceRouteBindingsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3ServiceRouteBindingsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3ServiceRouteBindingsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceUsageEventsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	page *int32
	perPage *int32
	orderBy *string
	afterGuid *string
	guids *[]string
	serviceInstanceTypes *[]string
	serviceOfferingGuids *[]string
	createdAts *string
	updatedAts *string
}

func (r ApiV3ServiceUsageEventsGetRequest) Page(page int32) ApiV3ServiceUsageEventsGetRequest {
	r.page = &page
	return r
}

func (r ApiV3ServiceUsageEventsGetRequest) PerPage(perPage int32) ApiV3ServiceUsageEventsGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3ServiceUsageEventsGetRequest) OrderBy(orderBy string) ApiV3ServiceUsageEventsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3ServiceUsageEventsGetRequest) AfterGuid(afterGuid string) ApiV3ServiceUsageEventsGetRequest {
	r.afterGuid = &afterGuid
	return r
}

func (r ApiV3ServiceUsageEventsGetRequest) Guids(guids []string) ApiV3ServiceUsageEventsGetRequest {
	r.guids = &guids
	return r
}

func (r ApiV3ServiceUsageEventsGetRequest) ServiceInstanceTypes(serviceInstanceTypes []string) ApiV3ServiceUsageEventsGetRequest {
	r.serviceInstanceTypes = &serviceInstanceTypes
	return r
}

func (r ApiV3ServiceUsageEventsGetRequest) ServiceOfferingGuids(serviceOfferingGuids []string) ApiV3ServiceUsageEventsGetRequest {
	r.serviceOfferingGuids = &serviceOfferingGuids
	return r
}

func (r ApiV3ServiceUsageEventsGetRequest) CreatedAts(createdAts string) ApiV3ServiceUsageEventsGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3ServiceUsageEventsGetRequest) UpdatedAts(updatedAts string) ApiV3ServiceUsageEventsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3ServiceUsageEventsGetRequest) Execute() (*V3ServiceUsageEventsGet200Response, *http.Response, error) {
	return r.ApiService.V3ServiceUsageEventsGetExecute(r)
}

/*
V3ServiceUsageEventsGet List service usage events

Retrieve all service usage events the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceUsageEventsGetRequest
*/
func (a *DefaultAPIService) V3ServiceUsageEventsGet(ctx context.Context) ApiV3ServiceUsageEventsGetRequest {
	return ApiV3ServiceUsageEventsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3ServiceUsageEventsGet200Response
func (a *DefaultAPIService) V3ServiceUsageEventsGetExecute(r ApiV3ServiceUsageEventsGetRequest) (*V3ServiceUsageEventsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3ServiceUsageEventsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceUsageEventsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_usage_events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.afterGuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after_guid", r.afterGuid, "form", "")
	}
	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "csv")
	}
	if r.serviceInstanceTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "service_instance_types", r.serviceInstanceTypes, "form", "csv")
	}
	if r.serviceOfferingGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "service_offering_guids", r.serviceOfferingGuids, "form", "csv")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceUsageEventsGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceUsageEventsGuidGetRequest) Execute() (*ServiceUsageEvent, *http.Response, error) {
	return r.ApiService.V3ServiceUsageEventsGuidGetExecute(r)
}

/*
V3ServiceUsageEventsGuidGet Get a service usage event

Retrieve a service usage event by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceUsageEventsGuidGetRequest
*/
func (a *DefaultAPIService) V3ServiceUsageEventsGuidGet(ctx context.Context, guid string) ApiV3ServiceUsageEventsGuidGetRequest {
	return ApiV3ServiceUsageEventsGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceUsageEvent
func (a *DefaultAPIService) V3ServiceUsageEventsGuidGetExecute(r ApiV3ServiceUsageEventsGuidGetRequest) (*ServiceUsageEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceUsageEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceUsageEventsGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_usage_events/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceUsageEventsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiV3ServiceUsageEventsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3ServiceUsageEventsPostExecute(r)
}

/*
V3ServiceUsageEventsPost Purge and seed service usage events

Destroys all existing events. Populates new usage events, one for each existing service instance.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceUsageEventsPostRequest
*/
func (a *DefaultAPIService) V3ServiceUsageEventsPost(ctx context.Context) ApiV3ServiceUsageEventsPostRequest {
	return ApiV3ServiceUsageEventsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3ServiceUsageEventsPostExecute(r ApiV3ServiceUsageEventsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceUsageEventsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_usage_events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3SidecarsGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3SidecarsGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3SidecarsGuidDeleteExecute(r)
}

/*
V3SidecarsGuidDelete Delete a sidecar

Deletes a sidecar by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3SidecarsGuidDeleteRequest
*/
func (a *DefaultAPIService) V3SidecarsGuidDelete(ctx context.Context, guid string) ApiV3SidecarsGuidDeleteRequest {
	return ApiV3SidecarsGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3SidecarsGuidDeleteExecute(r ApiV3SidecarsGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SidecarsGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/sidecars/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3SidecarsGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3SidecarsGuidGetRequest) Execute() (*Sidecar, *http.Response, error) {
	return r.ApiService.V3SidecarsGuidGetExecute(r)
}

/*
V3SidecarsGuidGet Get a sidecar

Retrieve a sidecar by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3SidecarsGuidGetRequest
*/
func (a *DefaultAPIService) V3SidecarsGuidGet(ctx context.Context, guid string) ApiV3SidecarsGuidGetRequest {
	return ApiV3SidecarsGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Sidecar
func (a *DefaultAPIService) V3SidecarsGuidGetExecute(r ApiV3SidecarsGuidGetRequest) (*Sidecar, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Sidecar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SidecarsGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/sidecars/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SidecarsGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3SidecarsGuidPatchRequest *V3SidecarsGuidPatchRequest
}

func (r ApiV3SidecarsGuidPatchRequest) V3SidecarsGuidPatchRequest(v3SidecarsGuidPatchRequest V3SidecarsGuidPatchRequest) ApiV3SidecarsGuidPatchRequest {
	r.v3SidecarsGuidPatchRequest = &v3SidecarsGuidPatchRequest
	return r
}

func (r ApiV3SidecarsGuidPatchRequest) Execute() (*Sidecar, *http.Response, error) {
	return r.ApiService.V3SidecarsGuidPatchExecute(r)
}

/*
V3SidecarsGuidPatch Update a sidecar

Updates the attributes of a sidecar.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3SidecarsGuidPatchRequest
*/
func (a *DefaultAPIService) V3SidecarsGuidPatch(ctx context.Context, guid string) ApiV3SidecarsGuidPatchRequest {
	return ApiV3SidecarsGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Sidecar
func (a *DefaultAPIService) V3SidecarsGuidPatchExecute(r ApiV3SidecarsGuidPatchRequest) (*Sidecar, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Sidecar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SidecarsGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/sidecars/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3SidecarsGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3SidecarsGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3SidecarsGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpaceQuotasGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guids *string
	names *string
	organizationGuids *string
	spaceGuids *string
	page *int32
	perPage *int32
	orderBy *string
	createdAts *string
	updatedAts *string
}

func (r ApiV3SpaceQuotasGetRequest) Guids(guids string) ApiV3SpaceQuotasGetRequest {
	r.guids = &guids
	return r
}

func (r ApiV3SpaceQuotasGetRequest) Names(names string) ApiV3SpaceQuotasGetRequest {
	r.names = &names
	return r
}

func (r ApiV3SpaceQuotasGetRequest) OrganizationGuids(organizationGuids string) ApiV3SpaceQuotasGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

func (r ApiV3SpaceQuotasGetRequest) SpaceGuids(spaceGuids string) ApiV3SpaceQuotasGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

func (r ApiV3SpaceQuotasGetRequest) Page(page int32) ApiV3SpaceQuotasGetRequest {
	r.page = &page
	return r
}

func (r ApiV3SpaceQuotasGetRequest) PerPage(perPage int32) ApiV3SpaceQuotasGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3SpaceQuotasGetRequest) OrderBy(orderBy string) ApiV3SpaceQuotasGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3SpaceQuotasGetRequest) CreatedAts(createdAts string) ApiV3SpaceQuotasGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3SpaceQuotasGetRequest) UpdatedAts(updatedAts string) ApiV3SpaceQuotasGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3SpaceQuotasGetRequest) Execute() (*V3SpaceQuotasGet200Response, *http.Response, error) {
	return r.ApiService.V3SpaceQuotasGetExecute(r)
}

/*
V3SpaceQuotasGet List space quotas

List all space quota resources that the user has permission to view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3SpaceQuotasGetRequest
*/
func (a *DefaultAPIService) V3SpaceQuotasGet(ctx context.Context) ApiV3SpaceQuotasGetRequest {
	return ApiV3SpaceQuotasGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3SpaceQuotasGet200Response
func (a *DefaultAPIService) V3SpaceQuotasGetExecute(r ApiV3SpaceQuotasGetRequest) (*V3SpaceQuotasGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3SpaceQuotasGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpaceQuotasGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/space_quotas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "")
	}
	if r.names != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "names", r.names, "form", "")
	}
	if r.organizationGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", r.organizationGuids, "form", "")
	}
	if r.spaceGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", r.spaceGuids, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpaceQuotasGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3SpaceQuotasGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3SpaceQuotasGuidDeleteExecute(r)
}

/*
V3SpaceQuotasGuidDelete Delete a space quota

Delete a space quota by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3SpaceQuotasGuidDeleteRequest
*/
func (a *DefaultAPIService) V3SpaceQuotasGuidDelete(ctx context.Context, guid string) ApiV3SpaceQuotasGuidDeleteRequest {
	return ApiV3SpaceQuotasGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3SpaceQuotasGuidDeleteExecute(r ApiV3SpaceQuotasGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpaceQuotasGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/space_quotas/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3SpaceQuotasGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3SpaceQuotasGuidGetRequest) Execute() (*SpaceQuota, *http.Response, error) {
	return r.ApiService.V3SpaceQuotasGuidGetExecute(r)
}

/*
V3SpaceQuotasGuidGet Get a space quota

Retrieve a space quota by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3SpaceQuotasGuidGetRequest
*/
func (a *DefaultAPIService) V3SpaceQuotasGuidGet(ctx context.Context, guid string) ApiV3SpaceQuotasGuidGetRequest {
	return ApiV3SpaceQuotasGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return SpaceQuota
func (a *DefaultAPIService) V3SpaceQuotasGuidGetExecute(r ApiV3SpaceQuotasGuidGetRequest) (*SpaceQuota, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpaceQuota
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpaceQuotasGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/space_quotas/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpaceQuotasGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3SpaceQuotasGuidPatchRequest *V3SpaceQuotasGuidPatchRequest
}

func (r ApiV3SpaceQuotasGuidPatchRequest) V3SpaceQuotasGuidPatchRequest(v3SpaceQuotasGuidPatchRequest V3SpaceQuotasGuidPatchRequest) ApiV3SpaceQuotasGuidPatchRequest {
	r.v3SpaceQuotasGuidPatchRequest = &v3SpaceQuotasGuidPatchRequest
	return r
}

func (r ApiV3SpaceQuotasGuidPatchRequest) Execute() (*SpaceQuota, *http.Response, error) {
	return r.ApiService.V3SpaceQuotasGuidPatchExecute(r)
}

/*
V3SpaceQuotasGuidPatch Update a space quota

Update the specified parameters of a space quota.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3SpaceQuotasGuidPatchRequest
*/
func (a *DefaultAPIService) V3SpaceQuotasGuidPatch(ctx context.Context, guid string) ApiV3SpaceQuotasGuidPatchRequest {
	return ApiV3SpaceQuotasGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return SpaceQuota
func (a *DefaultAPIService) V3SpaceQuotasGuidPatchExecute(r ApiV3SpaceQuotasGuidPatchRequest) (*SpaceQuota, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpaceQuota
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpaceQuotasGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/space_quotas/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3SpaceQuotasGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3SpaceQuotasGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3SpaceQuotasGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpaceQuotasPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	v3SpaceQuotasPostRequest *V3SpaceQuotasPostRequest
}

func (r ApiV3SpaceQuotasPostRequest) V3SpaceQuotasPostRequest(v3SpaceQuotasPostRequest V3SpaceQuotasPostRequest) ApiV3SpaceQuotasPostRequest {
	r.v3SpaceQuotasPostRequest = &v3SpaceQuotasPostRequest
	return r
}

func (r ApiV3SpaceQuotasPostRequest) Execute() (*SpaceQuota, *http.Response, error) {
	return r.ApiService.V3SpaceQuotasPostExecute(r)
}

/*
V3SpaceQuotasPost Create a space quota

Create a new space quota scoped to a specific organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3SpaceQuotasPostRequest
*/
func (a *DefaultAPIService) V3SpaceQuotasPost(ctx context.Context) ApiV3SpaceQuotasPostRequest {
	return ApiV3SpaceQuotasPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpaceQuota
func (a *DefaultAPIService) V3SpaceQuotasPostExecute(r ApiV3SpaceQuotasPostRequest) (*SpaceQuota, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpaceQuota
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpaceQuotasPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/space_quotas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3SpaceQuotasPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3SpaceQuotasPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3SpaceQuotasPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	quotaGuid string
	v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest *V3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest
}

func (r ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesPostRequest) V3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest(v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest V3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest) ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesPostRequest {
	r.v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest = &v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest
	return r
}

func (r ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesPostRequest) Execute() (*V3SpaceQuotasQuotaGuidRelationshipsSpacesPost200Response, *http.Response, error) {
	return r.ApiService.V3SpaceQuotasQuotaGuidRelationshipsSpacesPostExecute(r)
}

/*
V3SpaceQuotasQuotaGuidRelationshipsSpacesPost Apply a space quota to spaces

Apply a space quota to one or more spaces.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param quotaGuid
 @return ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesPostRequest
*/
func (a *DefaultAPIService) V3SpaceQuotasQuotaGuidRelationshipsSpacesPost(ctx context.Context, quotaGuid string) ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesPostRequest {
	return ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesPostRequest{
		ApiService: a,
		ctx: ctx,
		quotaGuid: quotaGuid,
	}
}

// Execute executes the request
//  @return V3SpaceQuotasQuotaGuidRelationshipsSpacesPost200Response
func (a *DefaultAPIService) V3SpaceQuotasQuotaGuidRelationshipsSpacesPostExecute(r ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesPostRequest) (*V3SpaceQuotasQuotaGuidRelationshipsSpacesPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3SpaceQuotasQuotaGuidRelationshipsSpacesPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpaceQuotasQuotaGuidRelationshipsSpacesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/space_quotas/{quota_guid}/relationships/spaces"
	localVarPath = strings.Replace(localVarPath, "{"+"quota_guid"+"}", url.PathEscape(parameterValueToString(r.quotaGuid, "quotaGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesSpaceGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	quotaGuid string
	spaceGuid string
}

func (r ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesSpaceGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3SpaceQuotasQuotaGuidRelationshipsSpacesSpaceGuidDeleteExecute(r)
}

/*
V3SpaceQuotasQuotaGuidRelationshipsSpacesSpaceGuidDelete Remove a space quota from a space

Remove a space quota from a space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param quotaGuid
 @param spaceGuid
 @return ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesSpaceGuidDeleteRequest
*/
func (a *DefaultAPIService) V3SpaceQuotasQuotaGuidRelationshipsSpacesSpaceGuidDelete(ctx context.Context, quotaGuid string, spaceGuid string) ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesSpaceGuidDeleteRequest {
	return ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesSpaceGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		quotaGuid: quotaGuid,
		spaceGuid: spaceGuid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3SpaceQuotasQuotaGuidRelationshipsSpacesSpaceGuidDeleteExecute(r ApiV3SpaceQuotasQuotaGuidRelationshipsSpacesSpaceGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpaceQuotasQuotaGuidRelationshipsSpacesSpaceGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/space_quotas/{quota_guid}/relationships/spaces/{space_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"quota_guid"+"}", url.PathEscape(parameterValueToString(r.quotaGuid, "quotaGuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"space_guid"+"}", url.PathEscape(parameterValueToString(r.spaceGuid, "spaceGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3SpacesGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	names *string
	guids *string
	organizationGuids *string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	include *string
	createdAts *string
	updatedAts *string
}

func (r ApiV3SpacesGetRequest) Names(names string) ApiV3SpacesGetRequest {
	r.names = &names
	return r
}

func (r ApiV3SpacesGetRequest) Guids(guids string) ApiV3SpacesGetRequest {
	r.guids = &guids
	return r
}

func (r ApiV3SpacesGetRequest) OrganizationGuids(organizationGuids string) ApiV3SpacesGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

func (r ApiV3SpacesGetRequest) Page(page int32) ApiV3SpacesGetRequest {
	r.page = &page
	return r
}

func (r ApiV3SpacesGetRequest) PerPage(perPage int32) ApiV3SpacesGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3SpacesGetRequest) OrderBy(orderBy string) ApiV3SpacesGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3SpacesGetRequest) LabelSelector(labelSelector string) ApiV3SpacesGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3SpacesGetRequest) Include(include string) ApiV3SpacesGetRequest {
	r.include = &include
	return r
}

func (r ApiV3SpacesGetRequest) CreatedAts(createdAts string) ApiV3SpacesGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3SpacesGetRequest) UpdatedAts(updatedAts string) ApiV3SpacesGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3SpacesGetRequest) Execute() (*V3SpacesGet200Response, *http.Response, error) {
	return r.ApiService.V3SpacesGetExecute(r)
}

/*
V3SpacesGet List spaces

Retrieve all spaces the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3SpacesGetRequest
*/
func (a *DefaultAPIService) V3SpacesGet(ctx context.Context) ApiV3SpacesGetRequest {
	return ApiV3SpacesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3SpacesGet200Response
func (a *DefaultAPIService) V3SpacesGetExecute(r ApiV3SpacesGetRequest) (*V3SpacesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3SpacesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpacesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/spaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.names != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "names", r.names, "form", "")
	}
	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "")
	}
	if r.organizationGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", r.organizationGuids, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpacesGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3SpacesGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3SpacesGuidDeleteExecute(r)
}

/*
V3SpacesGuidDelete Delete a space

Delete a space by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3SpacesGuidDeleteRequest
*/
func (a *DefaultAPIService) V3SpacesGuidDelete(ctx context.Context, guid string) ApiV3SpacesGuidDeleteRequest {
	return ApiV3SpacesGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3SpacesGuidDeleteExecute(r ApiV3SpacesGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpacesGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/spaces/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3SpacesGuidFeaturesGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3SpacesGuidFeaturesGetRequest) Execute() (*V3SpacesGuidFeaturesGet200Response, *http.Response, error) {
	return r.ApiService.V3SpacesGuidFeaturesGetExecute(r)
}

/*
V3SpacesGuidFeaturesGet List space features

Retrieve the list of features for the specified space. Currently, the only feature on spaces is the SSH feature.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3SpacesGuidFeaturesGetRequest
*/
func (a *DefaultAPIService) V3SpacesGuidFeaturesGet(ctx context.Context, guid string) ApiV3SpacesGuidFeaturesGetRequest {
	return ApiV3SpacesGuidFeaturesGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3SpacesGuidFeaturesGet200Response
func (a *DefaultAPIService) V3SpacesGuidFeaturesGetExecute(r ApiV3SpacesGuidFeaturesGetRequest) (*V3SpacesGuidFeaturesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3SpacesGuidFeaturesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpacesGuidFeaturesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/spaces/{guid}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpacesGuidFeaturesNameGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	name string
}

func (r ApiV3SpacesGuidFeaturesNameGetRequest) Execute() (*SpaceFeature, *http.Response, error) {
	return r.ApiService.V3SpacesGuidFeaturesNameGetExecute(r)
}

/*
V3SpacesGuidFeaturesNameGet Get a space feature

Retrieve a space feature by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @param name
 @return ApiV3SpacesGuidFeaturesNameGetRequest
*/
func (a *DefaultAPIService) V3SpacesGuidFeaturesNameGet(ctx context.Context, guid string, name string) ApiV3SpacesGuidFeaturesNameGetRequest {
	return ApiV3SpacesGuidFeaturesNameGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
		name: name,
	}
}

// Execute executes the request
//  @return SpaceFeature
func (a *DefaultAPIService) V3SpacesGuidFeaturesNameGetExecute(r ApiV3SpacesGuidFeaturesNameGetRequest) (*SpaceFeature, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpaceFeature
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpacesGuidFeaturesNameGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/spaces/{guid}/features/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpacesGuidFeaturesPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	name string
	v3SpacesGuidFeaturesPatchRequest *V3SpacesGuidFeaturesPatchRequest
}

func (r ApiV3SpacesGuidFeaturesPatchRequest) V3SpacesGuidFeaturesPatchRequest(v3SpacesGuidFeaturesPatchRequest V3SpacesGuidFeaturesPatchRequest) ApiV3SpacesGuidFeaturesPatchRequest {
	r.v3SpacesGuidFeaturesPatchRequest = &v3SpacesGuidFeaturesPatchRequest
	return r
}

func (r ApiV3SpacesGuidFeaturesPatchRequest) Execute() (*SpaceFeature, *http.Response, error) {
	return r.ApiService.V3SpacesGuidFeaturesPatchExecute(r)
}

/*
V3SpacesGuidFeaturesPatch Update space features

Update a space feature.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @param name
 @return ApiV3SpacesGuidFeaturesPatchRequest
*/
func (a *DefaultAPIService) V3SpacesGuidFeaturesPatch(ctx context.Context, guid string, name string) ApiV3SpacesGuidFeaturesPatchRequest {
	return ApiV3SpacesGuidFeaturesPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
		name: name,
	}
}

// Execute executes the request
//  @return SpaceFeature
func (a *DefaultAPIService) V3SpacesGuidFeaturesPatchExecute(r ApiV3SpacesGuidFeaturesPatchRequest) (*SpaceFeature, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpaceFeature
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpacesGuidFeaturesPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/spaces/{guid}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3SpacesGuidFeaturesPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3SpacesGuidFeaturesPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3SpacesGuidFeaturesPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpacesGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3SpacesGuidGetRequest) Execute() (*Space, *http.Response, error) {
	return r.ApiService.V3SpacesGuidGetExecute(r)
}

/*
V3SpacesGuidGet Get a space

Retrieve a space by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3SpacesGuidGetRequest
*/
func (a *DefaultAPIService) V3SpacesGuidGet(ctx context.Context, guid string) ApiV3SpacesGuidGetRequest {
	return ApiV3SpacesGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Space
func (a *DefaultAPIService) V3SpacesGuidGetExecute(r ApiV3SpacesGuidGetRequest) (*Space, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Space
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpacesGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/spaces/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpacesGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3SpacesGuidPatchRequest *V3SpacesGuidPatchRequest
}

func (r ApiV3SpacesGuidPatchRequest) V3SpacesGuidPatchRequest(v3SpacesGuidPatchRequest V3SpacesGuidPatchRequest) ApiV3SpacesGuidPatchRequest {
	r.v3SpacesGuidPatchRequest = &v3SpacesGuidPatchRequest
	return r
}

func (r ApiV3SpacesGuidPatchRequest) Execute() (*Space, *http.Response, error) {
	return r.ApiService.V3SpacesGuidPatchExecute(r)
}

/*
V3SpacesGuidPatch Update a space

Update a space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3SpacesGuidPatchRequest
*/
func (a *DefaultAPIService) V3SpacesGuidPatch(ctx context.Context, guid string) ApiV3SpacesGuidPatchRequest {
	return ApiV3SpacesGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Space
func (a *DefaultAPIService) V3SpacesGuidPatchExecute(r ApiV3SpacesGuidPatchRequest) (*Space, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Space
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpacesGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/spaces/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3SpacesGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3SpacesGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3SpacesGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpacesGuidRelationshipsIsolationSegmentGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3SpacesGuidRelationshipsIsolationSegmentGetRequest) Execute() (*V3AppsPostRequestRelationshipsSpace, *http.Response, error) {
	return r.ApiService.V3SpacesGuidRelationshipsIsolationSegmentGetExecute(r)
}

/*
V3SpacesGuidRelationshipsIsolationSegmentGet Get assigned isolation segment

Retrieve the isolation segment assigned to the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3SpacesGuidRelationshipsIsolationSegmentGetRequest
*/
func (a *DefaultAPIService) V3SpacesGuidRelationshipsIsolationSegmentGet(ctx context.Context, guid string) ApiV3SpacesGuidRelationshipsIsolationSegmentGetRequest {
	return ApiV3SpacesGuidRelationshipsIsolationSegmentGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsPostRequestRelationshipsSpace
func (a *DefaultAPIService) V3SpacesGuidRelationshipsIsolationSegmentGetExecute(r ApiV3SpacesGuidRelationshipsIsolationSegmentGetRequest) (*V3AppsPostRequestRelationshipsSpace, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsPostRequestRelationshipsSpace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpacesGuidRelationshipsIsolationSegmentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/spaces/{guid}/relationships/isolation_segment"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3AppsPostRequestRelationshipsSpace *V3AppsPostRequestRelationshipsSpace
}

func (r ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest) V3AppsPostRequestRelationshipsSpace(v3AppsPostRequestRelationshipsSpace V3AppsPostRequestRelationshipsSpace) ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest {
	r.v3AppsPostRequestRelationshipsSpace = &v3AppsPostRequestRelationshipsSpace
	return r
}

func (r ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest) Execute() (*V3AppsPostRequestRelationshipsSpace, *http.Response, error) {
	return r.ApiService.V3SpacesGuidRelationshipsIsolationSegmentPatchExecute(r)
}

/*
V3SpacesGuidRelationshipsIsolationSegmentPatch Manage isolation segment

Assign or unassign an isolation segment to a space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest
*/
func (a *DefaultAPIService) V3SpacesGuidRelationshipsIsolationSegmentPatch(ctx context.Context, guid string) ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest {
	return ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsPostRequestRelationshipsSpace
func (a *DefaultAPIService) V3SpacesGuidRelationshipsIsolationSegmentPatchExecute(r ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest) (*V3AppsPostRequestRelationshipsSpace, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsPostRequestRelationshipsSpace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpacesGuidRelationshipsIsolationSegmentPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/spaces/{guid}/relationships/isolation_segment"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3AppsPostRequestRelationshipsSpace == nil {
		return localVarReturnValue, nil, reportError("v3AppsPostRequestRelationshipsSpace is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3AppsPostRequestRelationshipsSpace
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpacesGuidUsersGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	guids *string
	usernames *string
	partialUsernames *string
	origins *string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

func (r ApiV3SpacesGuidUsersGetRequest) Guids(guids string) ApiV3SpacesGuidUsersGetRequest {
	r.guids = &guids
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) Usernames(usernames string) ApiV3SpacesGuidUsersGetRequest {
	r.usernames = &usernames
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) PartialUsernames(partialUsernames string) ApiV3SpacesGuidUsersGetRequest {
	r.partialUsernames = &partialUsernames
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) Origins(origins string) ApiV3SpacesGuidUsersGetRequest {
	r.origins = &origins
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) Page(page int32) ApiV3SpacesGuidUsersGetRequest {
	r.page = &page
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) PerPage(perPage int32) ApiV3SpacesGuidUsersGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) OrderBy(orderBy string) ApiV3SpacesGuidUsersGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) LabelSelector(labelSelector string) ApiV3SpacesGuidUsersGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) CreatedAts(createdAts string) ApiV3SpacesGuidUsersGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) UpdatedAts(updatedAts string) ApiV3SpacesGuidUsersGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) Execute() (*V3SpacesGuidUsersGet200Response, *http.Response, error) {
	return r.ApiService.V3SpacesGuidUsersGetExecute(r)
}

/*
V3SpacesGuidUsersGet List users for a space

Retrieve all users with a role in the specified space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3SpacesGuidUsersGetRequest
*/
func (a *DefaultAPIService) V3SpacesGuidUsersGet(ctx context.Context, guid string) ApiV3SpacesGuidUsersGetRequest {
	return ApiV3SpacesGuidUsersGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3SpacesGuidUsersGet200Response
func (a *DefaultAPIService) V3SpacesGuidUsersGetExecute(r ApiV3SpacesGuidUsersGetRequest) (*V3SpacesGuidUsersGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3SpacesGuidUsersGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpacesGuidUsersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/spaces/{guid}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "")
	}
	if r.usernames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usernames", r.usernames, "form", "")
	}
	if r.partialUsernames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partial_usernames", r.partialUsernames, "form", "")
	}
	if r.origins != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origins", r.origins, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpacesPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	v3SpacesPostRequest *V3SpacesPostRequest
}

func (r ApiV3SpacesPostRequest) V3SpacesPostRequest(v3SpacesPostRequest V3SpacesPostRequest) ApiV3SpacesPostRequest {
	r.v3SpacesPostRequest = &v3SpacesPostRequest
	return r
}

func (r ApiV3SpacesPostRequest) Execute() (*Space, *http.Response, error) {
	return r.ApiService.V3SpacesPostExecute(r)
}

/*
V3SpacesPost Create a space

Create a space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3SpacesPostRequest
*/
func (a *DefaultAPIService) V3SpacesPost(ctx context.Context) ApiV3SpacesPostRequest {
	return ApiV3SpacesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Space
func (a *DefaultAPIService) V3SpacesPostExecute(r ApiV3SpacesPostRequest) (*Space, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Space
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpacesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/spaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3SpacesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3SpacesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3SpacesPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3StacksGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	names *string
	default_ *bool
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

func (r ApiV3StacksGetRequest) Names(names string) ApiV3StacksGetRequest {
	r.names = &names
	return r
}

func (r ApiV3StacksGetRequest) Default_(default_ bool) ApiV3StacksGetRequest {
	r.default_ = &default_
	return r
}

func (r ApiV3StacksGetRequest) Page(page int32) ApiV3StacksGetRequest {
	r.page = &page
	return r
}

func (r ApiV3StacksGetRequest) PerPage(perPage int32) ApiV3StacksGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3StacksGetRequest) OrderBy(orderBy string) ApiV3StacksGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3StacksGetRequest) LabelSelector(labelSelector string) ApiV3StacksGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3StacksGetRequest) CreatedAts(createdAts string) ApiV3StacksGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3StacksGetRequest) UpdatedAts(updatedAts string) ApiV3StacksGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3StacksGetRequest) Execute() (*V3StacksGet200Response, *http.Response, error) {
	return r.ApiService.V3StacksGetExecute(r)
}

/*
V3StacksGet List all stacks

Retrieve all stacks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3StacksGetRequest
*/
func (a *DefaultAPIService) V3StacksGet(ctx context.Context) ApiV3StacksGetRequest {
	return ApiV3StacksGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3StacksGet200Response
func (a *DefaultAPIService) V3StacksGetExecute(r ApiV3StacksGetRequest) (*V3StacksGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3StacksGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3StacksGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/stacks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.names != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "names", r.names, "form", "")
	}
	if r.default_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default", r.default_, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	} else {
		var defaultValue int32 = 50
		r.perPage = &defaultValue
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3StacksGuidAppsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

func (r ApiV3StacksGuidAppsGetRequest) Page(page int32) ApiV3StacksGuidAppsGetRequest {
	r.page = &page
	return r
}

func (r ApiV3StacksGuidAppsGetRequest) PerPage(perPage int32) ApiV3StacksGuidAppsGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3StacksGuidAppsGetRequest) OrderBy(orderBy string) ApiV3StacksGuidAppsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3StacksGuidAppsGetRequest) LabelSelector(labelSelector string) ApiV3StacksGuidAppsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3StacksGuidAppsGetRequest) CreatedAts(createdAts string) ApiV3StacksGuidAppsGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3StacksGuidAppsGetRequest) UpdatedAts(updatedAts string) ApiV3StacksGuidAppsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3StacksGuidAppsGetRequest) Execute() (*V3StacksGuidAppsGet200Response, *http.Response, error) {
	return r.ApiService.V3StacksGuidAppsGetExecute(r)
}

/*
V3StacksGuidAppsGet List apps on a stack

Retrieve all apps using a given stack.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3StacksGuidAppsGetRequest
*/
func (a *DefaultAPIService) V3StacksGuidAppsGet(ctx context.Context, guid string) ApiV3StacksGuidAppsGetRequest {
	return ApiV3StacksGuidAppsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3StacksGuidAppsGet200Response
func (a *DefaultAPIService) V3StacksGuidAppsGetExecute(r ApiV3StacksGuidAppsGetRequest) (*V3StacksGuidAppsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3StacksGuidAppsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3StacksGuidAppsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/stacks/{guid}/apps"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	} else {
		var defaultValue int32 = 50
		r.perPage = &defaultValue
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3StacksGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3StacksGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3StacksGuidDeleteExecute(r)
}

/*
V3StacksGuidDelete Delete a stack

Delete a stack by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3StacksGuidDeleteRequest
*/
func (a *DefaultAPIService) V3StacksGuidDelete(ctx context.Context, guid string) ApiV3StacksGuidDeleteRequest {
	return ApiV3StacksGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3StacksGuidDeleteExecute(r ApiV3StacksGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3StacksGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/stacks/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3StacksGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3StacksGuidGetRequest) Execute() (*Stack, *http.Response, error) {
	return r.ApiService.V3StacksGuidGetExecute(r)
}

/*
V3StacksGuidGet Get a stack by GUID

Retrieve a stack by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3StacksGuidGetRequest
*/
func (a *DefaultAPIService) V3StacksGuidGet(ctx context.Context, guid string) ApiV3StacksGuidGetRequest {
	return ApiV3StacksGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Stack
func (a *DefaultAPIService) V3StacksGuidGetExecute(r ApiV3StacksGuidGetRequest) (*Stack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Stack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3StacksGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/stacks/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3StacksGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3RevisionsGuidPatchRequest *V3RevisionsGuidPatchRequest
}

func (r ApiV3StacksGuidPatchRequest) V3RevisionsGuidPatchRequest(v3RevisionsGuidPatchRequest V3RevisionsGuidPatchRequest) ApiV3StacksGuidPatchRequest {
	r.v3RevisionsGuidPatchRequest = &v3RevisionsGuidPatchRequest
	return r
}

func (r ApiV3StacksGuidPatchRequest) Execute() (*Stack, *http.Response, error) {
	return r.ApiService.V3StacksGuidPatchExecute(r)
}

/*
V3StacksGuidPatch Update a stack

Update the specified parameters of a stack.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3StacksGuidPatchRequest
*/
func (a *DefaultAPIService) V3StacksGuidPatch(ctx context.Context, guid string) ApiV3StacksGuidPatchRequest {
	return ApiV3StacksGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Stack
func (a *DefaultAPIService) V3StacksGuidPatchExecute(r ApiV3StacksGuidPatchRequest) (*Stack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Stack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3StacksGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/stacks/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3RevisionsGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3RevisionsGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3RevisionsGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3StacksPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	v3StacksPostRequest *V3StacksPostRequest
}

func (r ApiV3StacksPostRequest) V3StacksPostRequest(v3StacksPostRequest V3StacksPostRequest) ApiV3StacksPostRequest {
	r.v3StacksPostRequest = &v3StacksPostRequest
	return r
}

func (r ApiV3StacksPostRequest) Execute() (*Stack, *http.Response, error) {
	return r.ApiService.V3StacksPostExecute(r)
}

/*
V3StacksPost Create a stack

Create a new stack.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3StacksPostRequest
*/
func (a *DefaultAPIService) V3StacksPost(ctx context.Context) ApiV3StacksPostRequest {
	return ApiV3StacksPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Stack
func (a *DefaultAPIService) V3StacksPostExecute(r ApiV3StacksPostRequest) (*Stack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Stack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3StacksPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/stacks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3StacksPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3StacksPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3StacksPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3TasksGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guids *string
	names *string
	states *string
	appGuids *string
	spaceGuids *string
	organizationGuids *string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

func (r ApiV3TasksGetRequest) Guids(guids string) ApiV3TasksGetRequest {
	r.guids = &guids
	return r
}

func (r ApiV3TasksGetRequest) Names(names string) ApiV3TasksGetRequest {
	r.names = &names
	return r
}

func (r ApiV3TasksGetRequest) States(states string) ApiV3TasksGetRequest {
	r.states = &states
	return r
}

func (r ApiV3TasksGetRequest) AppGuids(appGuids string) ApiV3TasksGetRequest {
	r.appGuids = &appGuids
	return r
}

func (r ApiV3TasksGetRequest) SpaceGuids(spaceGuids string) ApiV3TasksGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

func (r ApiV3TasksGetRequest) OrganizationGuids(organizationGuids string) ApiV3TasksGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

func (r ApiV3TasksGetRequest) Page(page int32) ApiV3TasksGetRequest {
	r.page = &page
	return r
}

func (r ApiV3TasksGetRequest) PerPage(perPage int32) ApiV3TasksGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3TasksGetRequest) OrderBy(orderBy string) ApiV3TasksGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3TasksGetRequest) LabelSelector(labelSelector string) ApiV3TasksGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3TasksGetRequest) CreatedAts(createdAts string) ApiV3TasksGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3TasksGetRequest) UpdatedAts(updatedAts string) ApiV3TasksGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3TasksGetRequest) Execute() (*V3TasksGet200Response, *http.Response, error) {
	return r.ApiService.V3TasksGetExecute(r)
}

/*
V3TasksGet List all tasks

Retrieve all tasks the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3TasksGetRequest
*/
func (a *DefaultAPIService) V3TasksGet(ctx context.Context) ApiV3TasksGetRequest {
	return ApiV3TasksGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3TasksGet200Response
func (a *DefaultAPIService) V3TasksGetExecute(r ApiV3TasksGetRequest) (*V3TasksGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3TasksGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3TasksGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "")
	}
	if r.names != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "names", r.names, "form", "")
	}
	if r.states != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "states", r.states, "form", "")
	}
	if r.appGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "app_guids", r.appGuids, "form", "")
	}
	if r.spaceGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", r.spaceGuids, "form", "")
	}
	if r.organizationGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", r.organizationGuids, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	} else {
		var defaultValue int32 = 50
		r.perPage = &defaultValue
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3TasksGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3TasksGuidGetRequest) Execute() (*Task, *http.Response, error) {
	return r.ApiService.V3TasksGuidGetExecute(r)
}

/*
V3TasksGuidGet Get a task

Retrieve a specific task by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3TasksGuidGetRequest
*/
func (a *DefaultAPIService) V3TasksGuidGet(ctx context.Context, guid string) ApiV3TasksGuidGetRequest {
	return ApiV3TasksGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Task
func (a *DefaultAPIService) V3TasksGuidGetExecute(r ApiV3TasksGuidGetRequest) (*Task, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Task
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3TasksGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/tasks/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3TasksGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3RevisionsGuidPatchRequest *V3RevisionsGuidPatchRequest
}

func (r ApiV3TasksGuidPatchRequest) V3RevisionsGuidPatchRequest(v3RevisionsGuidPatchRequest V3RevisionsGuidPatchRequest) ApiV3TasksGuidPatchRequest {
	r.v3RevisionsGuidPatchRequest = &v3RevisionsGuidPatchRequest
	return r
}

func (r ApiV3TasksGuidPatchRequest) Execute() (*Task, *http.Response, error) {
	return r.ApiService.V3TasksGuidPatchExecute(r)
}

/*
V3TasksGuidPatch Update a task

Update the specified parameters of a task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3TasksGuidPatchRequest
*/
func (a *DefaultAPIService) V3TasksGuidPatch(ctx context.Context, guid string) ApiV3TasksGuidPatchRequest {
	return ApiV3TasksGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Task
func (a *DefaultAPIService) V3TasksGuidPatchExecute(r ApiV3TasksGuidPatchRequest) (*Task, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Task
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3TasksGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/tasks/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3RevisionsGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3RevisionsGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3RevisionsGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3TasksGuidPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3TasksGuidPostRequest) Execute() (*Task, *http.Response, error) {
	return r.ApiService.V3TasksGuidPostExecute(r)
}

/*
V3TasksGuidPost Cancel a task

Cancels a running task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3TasksGuidPostRequest
*/
func (a *DefaultAPIService) V3TasksGuidPost(ctx context.Context, guid string) ApiV3TasksGuidPostRequest {
	return ApiV3TasksGuidPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Task
func (a *DefaultAPIService) V3TasksGuidPostExecute(r ApiV3TasksGuidPostRequest) (*Task, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Task
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3TasksGuidPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/tasks/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3UsersGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guids *[]string
	usernames *[]string
	partialUsernames *[]string
	origins *[]string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

// Comma-delimited list of user guids to filter by
func (r ApiV3UsersGetRequest) Guids(guids []string) ApiV3UsersGetRequest {
	r.guids = &guids
	return r
}

// Comma-delimited list of usernames to filter by. Mutually exclusive with partial_usernames
func (r ApiV3UsersGetRequest) Usernames(usernames []string) ApiV3UsersGetRequest {
	r.usernames = &usernames
	return r
}

// Comma-delimited list of strings to search by. When using this query parameter, all the users that contain the string provided in their username will be returned. Mutually exclusive with usernames
func (r ApiV3UsersGetRequest) PartialUsernames(partialUsernames []string) ApiV3UsersGetRequest {
	r.partialUsernames = &partialUsernames
	return r
}

// Comma-delimited list of user origins (user stores) to filter by, for example, users authenticated by UAA have the origin “uaa”; users authenticated by an LDAP provider have the origin “ldap”; when filtering by origins, usernames must be included
func (r ApiV3UsersGetRequest) Origins(origins []string) ApiV3UsersGetRequest {
	r.origins = &origins
	return r
}

// Page to display; valid values are integers &gt;&#x3D; 1
func (r ApiV3UsersGetRequest) Page(page int32) ApiV3UsersGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3UsersGetRequest) PerPage(perPage int32) ApiV3UsersGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by. Defaults to ascending; prepend with - to sort descending
func (r ApiV3UsersGetRequest) OrderBy(orderBy string) ApiV3UsersGetRequest {
	r.orderBy = &orderBy
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3UsersGetRequest) LabelSelector(labelSelector string) ApiV3UsersGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3UsersGetRequest) CreatedAts(createdAts string) ApiV3UsersGetRequest {
	r.createdAts = &createdAts
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3UsersGetRequest) UpdatedAts(updatedAts string) ApiV3UsersGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3UsersGetRequest) Execute() (*V3UsersGet200Response, *http.Response, error) {
	return r.ApiService.V3UsersGetExecute(r)
}

/*
V3UsersGet List users

Retrieve all users that the current user can see.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3UsersGetRequest
*/
func (a *DefaultAPIService) V3UsersGet(ctx context.Context) ApiV3UsersGetRequest {
	return ApiV3UsersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3UsersGet200Response
func (a *DefaultAPIService) V3UsersGetExecute(r ApiV3UsersGetRequest) (*V3UsersGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3UsersGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3UsersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "csv")
	}
	if r.usernames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usernames", r.usernames, "form", "csv")
	}
	if r.partialUsernames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partial_usernames", r.partialUsernames, "form", "csv")
	}
	if r.origins != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origins", r.origins, "form", "csv")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3UsersGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3UsersGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3UsersGuidDeleteExecute(r)
}

/*
V3UsersGuidDelete Delete a user

Delete a user by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid Unique identifier for the user
 @return ApiV3UsersGuidDeleteRequest
*/
func (a *DefaultAPIService) V3UsersGuidDelete(ctx context.Context, guid string) ApiV3UsersGuidDeleteRequest {
	return ApiV3UsersGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3UsersGuidDeleteExecute(r ApiV3UsersGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3UsersGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/users/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3UsersGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3UsersGuidGetRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.V3UsersGuidGetExecute(r)
}

/*
V3UsersGuidGet Get a user

Retrieve a user by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid Unique identifier for the user
 @return ApiV3UsersGuidGetRequest
*/
func (a *DefaultAPIService) V3UsersGuidGet(ctx context.Context, guid string) ApiV3UsersGuidGetRequest {
	return ApiV3UsersGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return User
func (a *DefaultAPIService) V3UsersGuidGetExecute(r ApiV3UsersGuidGetRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3UsersGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/users/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3UsersGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3UsersGuidPatchRequest *V3UsersGuidPatchRequest
}

func (r ApiV3UsersGuidPatchRequest) V3UsersGuidPatchRequest(v3UsersGuidPatchRequest V3UsersGuidPatchRequest) ApiV3UsersGuidPatchRequest {
	r.v3UsersGuidPatchRequest = &v3UsersGuidPatchRequest
	return r
}

func (r ApiV3UsersGuidPatchRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.V3UsersGuidPatchExecute(r)
}

/*
V3UsersGuidPatch Update a user

Update a user’s metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid Unique identifier for the user
 @return ApiV3UsersGuidPatchRequest
*/
func (a *DefaultAPIService) V3UsersGuidPatch(ctx context.Context, guid string) ApiV3UsersGuidPatchRequest {
	return ApiV3UsersGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return User
func (a *DefaultAPIService) V3UsersGuidPatchExecute(r ApiV3UsersGuidPatchRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3UsersGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/users/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3UsersGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3UsersGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3UsersGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3UsersPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	v3UsersPostRequest *V3UsersPostRequest
}

func (r ApiV3UsersPostRequest) V3UsersPostRequest(v3UsersPostRequest V3UsersPostRequest) ApiV3UsersPostRequest {
	r.v3UsersPostRequest = &v3UsersPostRequest
	return r
}

func (r ApiV3UsersPostRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.V3UsersPostExecute(r)
}

/*
V3UsersPost Create a user

Creates a user in the Cloud Controller database.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3UsersPostRequest
*/
func (a *DefaultAPIService) V3UsersPost(ctx context.Context) ApiV3UsersPostRequest {
	return ApiV3UsersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return User
func (a *DefaultAPIService) V3UsersPostExecute(r ApiV3UsersPostRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3UsersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3UsersPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3UsersPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3UsersPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
