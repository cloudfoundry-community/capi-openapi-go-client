/*
Cloud Foundry API

OpenAPI specification for the Cloud Foundry API.

API version: 3.195.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package capiclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
)


type DefaultAPI interface {

	/*
	AssignDefaultIsolationSegment Assign Default Isolation Segment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiAssignDefaultIsolationSegmentRequest
	*/
	AssignDefaultIsolationSegment(ctx context.Context, guid string) ApiAssignDefaultIsolationSegmentRequest

	// AssignDefaultIsolationSegmentExecute executes the request
	//  @return map[string]interface{}
	AssignDefaultIsolationSegmentExecute(r ApiAssignDefaultIsolationSegmentRequest) (map[string]interface{}, *http.Response, error)

	/*
	CreateOrganization Create an Organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateOrganizationRequest
	*/
	CreateOrganization(ctx context.Context) ApiCreateOrganizationRequest

	// CreateOrganizationExecute executes the request
	//  @return Organization
	CreateOrganizationExecute(r ApiCreateOrganizationRequest) (*Organization, *http.Response, error)

	/*
	DeleteOrganization Delete an Organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiDeleteOrganizationRequest
	*/
	DeleteOrganization(ctx context.Context, guid string) ApiDeleteOrganizationRequest

	// DeleteOrganizationExecute executes the request
	//  @return map[string]interface{}
	DeleteOrganizationExecute(r ApiDeleteOrganizationRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetDefaultDomain Get Default Domain

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiGetDefaultDomainRequest
	*/
	GetDefaultDomain(ctx context.Context, guid string) ApiGetDefaultDomainRequest

	// GetDefaultDomainExecute executes the request
	//  @return map[string]interface{}
	GetDefaultDomainExecute(r ApiGetDefaultDomainRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetDefaultIsolationSegment Get Default Isolation Segment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiGetDefaultIsolationSegmentRequest
	*/
	GetDefaultIsolationSegment(ctx context.Context, guid string) ApiGetDefaultIsolationSegmentRequest

	// GetDefaultIsolationSegmentExecute executes the request
	//  @return map[string]interface{}
	GetDefaultIsolationSegmentExecute(r ApiGetDefaultIsolationSegmentRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetOrganization Get an Organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiGetOrganizationRequest
	*/
	GetOrganization(ctx context.Context, guid string) ApiGetOrganizationRequest

	// GetOrganizationExecute executes the request
	//  @return Organization
	GetOrganizationExecute(r ApiGetOrganizationRequest) (*Organization, *http.Response, error)

	/*
	GetUsageSummary Get Usage Summary

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiGetUsageSummaryRequest
	*/
	GetUsageSummary(ctx context.Context, guid string) ApiGetUsageSummaryRequest

	// GetUsageSummaryExecute executes the request
	//  @return map[string]interface{}
	GetUsageSummaryExecute(r ApiGetUsageSummaryRequest) (map[string]interface{}, *http.Response, error)

	/*
	ListOrganizations List Organizations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListOrganizationsRequest
	*/
	ListOrganizations(ctx context.Context) ApiListOrganizationsRequest

	// ListOrganizationsExecute executes the request
	//  @return []Organization
	ListOrganizationsExecute(r ApiListOrganizationsRequest) ([]Organization, *http.Response, error)

	/*
	ListUsersForOrganization List Users for an Organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiListUsersForOrganizationRequest
	*/
	ListUsersForOrganization(ctx context.Context, guid string) ApiListUsersForOrganizationRequest

	// ListUsersForOrganizationExecute executes the request
	//  @return []User
	ListUsersForOrganizationExecute(r ApiListUsersForOrganizationRequest) ([]User, *http.Response, error)

	/*
	RootGet Global API Root

	Returns links to the APIs available on a given Cloud Foundry deployment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRootGetRequest
	*/
	RootGet(ctx context.Context) ApiRootGetRequest

	// RootGetExecute executes the request
	//  @return Get200Response
	RootGetExecute(r ApiRootGetRequest) (*Get200Response, *http.Response, error)

	/*
	UpdateOrganization Update an Organization

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiUpdateOrganizationRequest
	*/
	UpdateOrganization(ctx context.Context, guid string) ApiUpdateOrganizationRequest

	// UpdateOrganizationExecute executes the request
	//  @return Organization
	UpdateOrganizationExecute(r ApiUpdateOrganizationRequest) (*Organization, *http.Response, error)

	/*
	V3AppsGuidDropletsGet List droplets for an app

	Retrieve a list of droplets belonging to an app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the app
	@return ApiV3AppsGuidDropletsGetRequest
	*/
	V3AppsGuidDropletsGet(ctx context.Context, guid string) ApiV3AppsGuidDropletsGetRequest

	// V3AppsGuidDropletsGetExecute executes the request
	//  @return V3AppsGuidDropletsGet200Response
	V3AppsGuidDropletsGetExecute(r ApiV3AppsGuidDropletsGetRequest) (*V3AppsGuidDropletsGet200Response, *http.Response, error)

	/*
	V3AppsGuidRevisionsDeployedGet List deployed revisions for an app

	Retrieve deployed revisions for an app the user has access to. Deployed revisions are revisions that are linked to started processes in the app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid Unique identifier for the app
	@return ApiV3AppsGuidRevisionsDeployedGetRequest
	*/
	V3AppsGuidRevisionsDeployedGet(ctx context.Context, guid string) ApiV3AppsGuidRevisionsDeployedGetRequest

	// V3AppsGuidRevisionsDeployedGetExecute executes the request
	//  @return RevisionsList
	V3AppsGuidRevisionsDeployedGetExecute(r ApiV3AppsGuidRevisionsDeployedGetRequest) (*RevisionsList, *http.Response, error)

	/*
	V3AppsGuidRevisionsGet List revisions for an app

	Retrieve revisions for an app the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid Unique identifier for the app
	@return ApiV3AppsGuidRevisionsGetRequest
	*/
	V3AppsGuidRevisionsGet(ctx context.Context, guid string) ApiV3AppsGuidRevisionsGetRequest

	// V3AppsGuidRevisionsGetExecute executes the request
	//  @return RevisionsList
	V3AppsGuidRevisionsGetExecute(r ApiV3AppsGuidRevisionsGetRequest) (*RevisionsList, *http.Response, error)

	/*
	V3AppsGuidTasksPost Create a task

	Create a new task for an app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3AppsGuidTasksPostRequest
	*/
	V3AppsGuidTasksPost(ctx context.Context, guid string) ApiV3AppsGuidTasksPostRequest

	// V3AppsGuidTasksPostExecute executes the request
	//  @return Task
	V3AppsGuidTasksPostExecute(r ApiV3AppsGuidTasksPostRequest) (*Task, *http.Response, error)

	/*
	V3DropletsGet List droplets

	Retrieve all droplets the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3DropletsGetRequest
	*/
	V3DropletsGet(ctx context.Context) ApiV3DropletsGetRequest

	// V3DropletsGetExecute executes the request
	//  @return V3AppsGuidDropletsGet200Response
	V3DropletsGetExecute(r ApiV3DropletsGetRequest) (*V3AppsGuidDropletsGet200Response, *http.Response, error)

	/*
	V3DropletsGuidDelete Delete a droplet

	Delete a specific droplet.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the droplet
	@return ApiV3DropletsGuidDeleteRequest
	*/
	V3DropletsGuidDelete(ctx context.Context, guid string) ApiV3DropletsGuidDeleteRequest

	// V3DropletsGuidDeleteExecute executes the request
	V3DropletsGuidDeleteExecute(r ApiV3DropletsGuidDeleteRequest) (*http.Response, error)

	/*
	V3DropletsGuidGet Get a droplet

	Retrieve a specific droplet.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the droplet
	@return ApiV3DropletsGuidGetRequest
	*/
	V3DropletsGuidGet(ctx context.Context, guid string) ApiV3DropletsGuidGetRequest

	// V3DropletsGuidGetExecute executes the request
	//  @return Droplet
	V3DropletsGuidGetExecute(r ApiV3DropletsGuidGetRequest) (*Droplet, *http.Response, error)

	/*
	V3DropletsGuidPatch Update a droplet

	Update the metadata of a droplet.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the droplet
	@return ApiV3DropletsGuidPatchRequest
	*/
	V3DropletsGuidPatch(ctx context.Context, guid string) ApiV3DropletsGuidPatchRequest

	// V3DropletsGuidPatchExecute executes the request
	//  @return Droplet
	V3DropletsGuidPatchExecute(r ApiV3DropletsGuidPatchRequest) (*Droplet, *http.Response, error)

	/*
	V3DropletsPost Create or copy a droplet

	Create a droplet without a package, or copy a droplet to a different app.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3DropletsPostRequest
	*/
	V3DropletsPost(ctx context.Context) ApiV3DropletsPostRequest

	// V3DropletsPostExecute executes the request
	//  @return Droplet
	V3DropletsPostExecute(r ApiV3DropletsPostRequest) (*Droplet, *http.Response, error)

	/*
	V3Get V3 API Root

	Returns links to all the resources available on the v3 API.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3GetRequest
	*/
	V3Get(ctx context.Context) ApiV3GetRequest

	// V3GetExecute executes the request
	//  @return V3Get200Response
	V3GetExecute(r ApiV3GetRequest) (*V3Get200Response, *http.Response, error)

	/*
	V3InfoGet Get platform info

	Retrieve Cloud Controller configuration information.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3InfoGetRequest
	*/
	V3InfoGet(ctx context.Context) ApiV3InfoGetRequest

	// V3InfoGetExecute executes the request
	//  @return PlatformInfo
	V3InfoGetExecute(r ApiV3InfoGetRequest) (*PlatformInfo, *http.Response, error)

	/*
	V3InfoUsageSummaryGet Get platform usage summary

	Retrieve a high-level summary of usage across the entire Cloud Foundry installation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3InfoUsageSummaryGetRequest
	*/
	V3InfoUsageSummaryGet(ctx context.Context) ApiV3InfoUsageSummaryGetRequest

	// V3InfoUsageSummaryGetExecute executes the request
	//  @return UsageSummary
	V3InfoUsageSummaryGetExecute(r ApiV3InfoUsageSummaryGetRequest) (*UsageSummary, *http.Response, error)

	/*
	V3IsolationSegmentsGet List isolation segments

	Retrieve all isolation segments to which the user has access.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3IsolationSegmentsGetRequest
	*/
	V3IsolationSegmentsGet(ctx context.Context) ApiV3IsolationSegmentsGetRequest

	// V3IsolationSegmentsGetExecute executes the request
	//  @return V3IsolationSegmentsGet200Response
	V3IsolationSegmentsGetExecute(r ApiV3IsolationSegmentsGetRequest) (*V3IsolationSegmentsGet200Response, *http.Response, error)

	/*
	V3IsolationSegmentsGuidDelete Delete an isolation segment

	Delete an isolation segment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the isolation segment
	@return ApiV3IsolationSegmentsGuidDeleteRequest
	*/
	V3IsolationSegmentsGuidDelete(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidDeleteRequest

	// V3IsolationSegmentsGuidDeleteExecute executes the request
	V3IsolationSegmentsGuidDeleteExecute(r ApiV3IsolationSegmentsGuidDeleteRequest) (*http.Response, error)

	/*
	V3IsolationSegmentsGuidGet Get an isolation segment

	Retrieve an isolation segment to which the user has access.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the isolation segment
	@return ApiV3IsolationSegmentsGuidGetRequest
	*/
	V3IsolationSegmentsGuidGet(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidGetRequest

	// V3IsolationSegmentsGuidGetExecute executes the request
	//  @return IsolationSegment
	V3IsolationSegmentsGuidGetExecute(r ApiV3IsolationSegmentsGuidGetRequest) (*IsolationSegment, *http.Response, error)

	/*
	V3IsolationSegmentsGuidPatch Update an isolation segment

	Update the name or metadata of an isolation segment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the isolation segment
	@return ApiV3IsolationSegmentsGuidPatchRequest
	*/
	V3IsolationSegmentsGuidPatch(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidPatchRequest

	// V3IsolationSegmentsGuidPatchExecute executes the request
	//  @return IsolationSegment
	V3IsolationSegmentsGuidPatchExecute(r ApiV3IsolationSegmentsGuidPatchRequest) (*IsolationSegment, *http.Response, error)

	/*
	V3IsolationSegmentsGuidRelationshipsOrganizationsGet List organizations relationship

	List the organizations entitled for the isolation segment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the isolation segment
	@return ApiV3IsolationSegmentsGuidRelationshipsOrganizationsGetRequest
	*/
	V3IsolationSegmentsGuidRelationshipsOrganizationsGet(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidRelationshipsOrganizationsGetRequest

	// V3IsolationSegmentsGuidRelationshipsOrganizationsGetExecute executes the request
	//  @return V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response
	V3IsolationSegmentsGuidRelationshipsOrganizationsGetExecute(r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsGetRequest) (*V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response, *http.Response, error)

	/*
	V3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDelete Revoke entitlement to isolation segment for an organization

	Revoke the entitlement for the specified organization to the isolation segment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the isolation segment
	@param orgGuid The guid of the organization
	@return ApiV3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteRequest
	*/
	V3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDelete(ctx context.Context, guid string, orgGuid string) ApiV3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteRequest

	// V3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteExecute executes the request
	V3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteExecute(r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteRequest) (*http.Response, error)

	/*
	V3IsolationSegmentsGuidRelationshipsOrganizationsPost Entitle organizations for an isolation segment

	Entitle the specified organizations for the isolation segment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the isolation segment
	@return ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest
	*/
	V3IsolationSegmentsGuidRelationshipsOrganizationsPost(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest

	// V3IsolationSegmentsGuidRelationshipsOrganizationsPostExecute executes the request
	//  @return V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response
	V3IsolationSegmentsGuidRelationshipsOrganizationsPostExecute(r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest) (*V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response, *http.Response, error)

	/*
	V3IsolationSegmentsGuidRelationshipsSpacesGet List spaces relationship

	List the spaces to which the isolation segment is assigned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the isolation segment
	@return ApiV3IsolationSegmentsGuidRelationshipsSpacesGetRequest
	*/
	V3IsolationSegmentsGuidRelationshipsSpacesGet(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidRelationshipsSpacesGetRequest

	// V3IsolationSegmentsGuidRelationshipsSpacesGetExecute executes the request
	//  @return V3IsolationSegmentsGuidRelationshipsSpacesGet200Response
	V3IsolationSegmentsGuidRelationshipsSpacesGetExecute(r ApiV3IsolationSegmentsGuidRelationshipsSpacesGetRequest) (*V3IsolationSegmentsGuidRelationshipsSpacesGet200Response, *http.Response, error)

	/*
	V3IsolationSegmentsPost Create an isolation segment

	Create a new isolation segment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3IsolationSegmentsPostRequest
	*/
	V3IsolationSegmentsPost(ctx context.Context) ApiV3IsolationSegmentsPostRequest

	// V3IsolationSegmentsPostExecute executes the request
	//  @return IsolationSegment
	V3IsolationSegmentsPostExecute(r ApiV3IsolationSegmentsPostRequest) (*IsolationSegment, *http.Response, error)

	/*
	V3PackagesGuidDropletsGet List droplets for a package

	Retrieve a list of droplets belonging to a package.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The guid of the package
	@return ApiV3PackagesGuidDropletsGetRequest
	*/
	V3PackagesGuidDropletsGet(ctx context.Context, guid string) ApiV3PackagesGuidDropletsGetRequest

	// V3PackagesGuidDropletsGetExecute executes the request
	//  @return V3AppsGuidDropletsGet200Response
	V3PackagesGuidDropletsGetExecute(r ApiV3PackagesGuidDropletsGetRequest) (*V3AppsGuidDropletsGet200Response, *http.Response, error)

	/*
	V3ResourceMatchesPost Create a resource match

	This endpoint matches given resource SHA-1/file size pairs against the Cloud Controller cache and reports the subset that describes already cached files. This is usually used to avoid uploading duplicate files when pushing an app which has only been partially changed. The path and mode fields are not used when matching.

When uploading package bits, the response from this endpoint should be used as the resources form field. As such, it is useful to include the path and mode fields for each resource even though they are not used when determining a resource match.

Cloud Foundry operators may set minimum/maximum file sizes to match against. If the file size provided is outside this range, it will not be matched against.

If the resource_matching feature flag is disabled, resource matching will always return an empty array.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ResourceMatchesPostRequest
	*/
	V3ResourceMatchesPost(ctx context.Context) ApiV3ResourceMatchesPostRequest

	// V3ResourceMatchesPostExecute executes the request
	//  @return ResourceMatchResponse
	V3ResourceMatchesPostExecute(r ApiV3ResourceMatchesPostRequest) (*ResourceMatchResponse, *http.Response, error)

	/*
	V3RevisionsGuidEnvironmentVariablesGet Get environment variables for a revision

	Retrieve the environment variables associated with the revision.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid Unique identifier for the revision
	@return ApiV3RevisionsGuidEnvironmentVariablesGetRequest
	*/
	V3RevisionsGuidEnvironmentVariablesGet(ctx context.Context, guid string) ApiV3RevisionsGuidEnvironmentVariablesGetRequest

	// V3RevisionsGuidEnvironmentVariablesGetExecute executes the request
	//  @return EnvironmentVariables
	V3RevisionsGuidEnvironmentVariablesGetExecute(r ApiV3RevisionsGuidEnvironmentVariablesGetRequest) (*EnvironmentVariables, *http.Response, error)

	/*
	V3RevisionsGuidGet Get a revision

	Retrieve a specific revision.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid Unique identifier for the revision
	@return ApiV3RevisionsGuidGetRequest
	*/
	V3RevisionsGuidGet(ctx context.Context, guid string) ApiV3RevisionsGuidGetRequest

	// V3RevisionsGuidGetExecute executes the request
	//  @return Revision
	V3RevisionsGuidGetExecute(r ApiV3RevisionsGuidGetRequest) (*Revision, *http.Response, error)

	/*
	V3RevisionsGuidPatch Update a revision

	Update metadata for a specific revision.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid Unique identifier for the revision
	@return ApiV3RevisionsGuidPatchRequest
	*/
	V3RevisionsGuidPatch(ctx context.Context, guid string) ApiV3RevisionsGuidPatchRequest

	// V3RevisionsGuidPatchExecute executes the request
	//  @return Revision
	V3RevisionsGuidPatchExecute(r ApiV3RevisionsGuidPatchRequest) (*Revision, *http.Response, error)

	/*
	V3ServiceBrokersGet List service brokers

	Retrieves the service brokers the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceBrokersGetRequest
	*/
	V3ServiceBrokersGet(ctx context.Context) ApiV3ServiceBrokersGetRequest

	// V3ServiceBrokersGetExecute executes the request
	//  @return V3ServiceBrokersGet200Response
	V3ServiceBrokersGetExecute(r ApiV3ServiceBrokersGetRequest) (*V3ServiceBrokersGet200Response, *http.Response, error)

	/*
	V3ServiceBrokersGuidCatalogPost Sync service broker catalog

	Triggers a synchronization of the service broker's catalog

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceBrokersGuidCatalogPostRequest
	*/
	V3ServiceBrokersGuidCatalogPost(ctx context.Context, guid string) ApiV3ServiceBrokersGuidCatalogPostRequest

	// V3ServiceBrokersGuidCatalogPostExecute executes the request
	V3ServiceBrokersGuidCatalogPostExecute(r ApiV3ServiceBrokersGuidCatalogPostRequest) (*http.Response, error)

	/*
	V3ServiceBrokersGuidDelete Delete a service broker

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceBrokersGuidDeleteRequest
	*/
	V3ServiceBrokersGuidDelete(ctx context.Context, guid string) ApiV3ServiceBrokersGuidDeleteRequest

	// V3ServiceBrokersGuidDeleteExecute executes the request
	V3ServiceBrokersGuidDeleteExecute(r ApiV3ServiceBrokersGuidDeleteRequest) (*http.Response, error)

	/*
	V3ServiceBrokersGuidGet Get a service broker

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceBrokersGuidGetRequest
	*/
	V3ServiceBrokersGuidGet(ctx context.Context, guid string) ApiV3ServiceBrokersGuidGetRequest

	// V3ServiceBrokersGuidGetExecute executes the request
	//  @return ServiceBroker
	V3ServiceBrokersGuidGetExecute(r ApiV3ServiceBrokersGuidGetRequest) (*ServiceBroker, *http.Response, error)

	/*
	V3ServiceBrokersGuidJobsSynchronizationGet Get broker synchronization job status

	Retrieves status of the last catalog synchronization job

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceBrokersGuidJobsSynchronizationGetRequest
	*/
	V3ServiceBrokersGuidJobsSynchronizationGet(ctx context.Context, guid string) ApiV3ServiceBrokersGuidJobsSynchronizationGetRequest

	// V3ServiceBrokersGuidJobsSynchronizationGetExecute executes the request
	//  @return LastOperation
	V3ServiceBrokersGuidJobsSynchronizationGetExecute(r ApiV3ServiceBrokersGuidJobsSynchronizationGetRequest) (*LastOperation, *http.Response, error)

	/*
	V3ServiceBrokersGuidPatch Update a service broker

	Updates a service broker. May trigger catalog sync based on fields updated.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceBrokersGuidPatchRequest
	*/
	V3ServiceBrokersGuidPatch(ctx context.Context, guid string) ApiV3ServiceBrokersGuidPatchRequest

	// V3ServiceBrokersGuidPatchExecute executes the request
	//  @return ServiceBroker
	V3ServiceBrokersGuidPatchExecute(r ApiV3ServiceBrokersGuidPatchRequest) (*ServiceBroker, *http.Response, error)

	/*
	V3ServiceBrokersPost Create a service broker

	Creates a new service broker and syncs with catalog

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceBrokersPostRequest
	*/
	V3ServiceBrokersPost(ctx context.Context) ApiV3ServiceBrokersPostRequest

	// V3ServiceBrokersPostExecute executes the request
	//  @return ServiceBroker
	V3ServiceBrokersPostExecute(r ApiV3ServiceBrokersPostRequest) (*ServiceBroker, *http.Response, error)

	/*
	V3ServiceCredentialBindingsGuidDelete Delete a service credential binding

	This endpoint deletes a service credential binding.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceCredentialBindingsGuidDeleteRequest
	*/
	V3ServiceCredentialBindingsGuidDelete(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidDeleteRequest

	// V3ServiceCredentialBindingsGuidDeleteExecute executes the request
	V3ServiceCredentialBindingsGuidDeleteExecute(r ApiV3ServiceCredentialBindingsGuidDeleteRequest) (*http.Response, error)

	/*
	V3ServiceCredentialBindingsGuidDetailsGet Get a service credential binding details

	This endpoint retrieves the service credential binding details.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceCredentialBindingsGuidDetailsGetRequest
	*/
	V3ServiceCredentialBindingsGuidDetailsGet(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidDetailsGetRequest

	// V3ServiceCredentialBindingsGuidDetailsGetExecute executes the request
	//  @return V3ServiceCredentialBindingsGuidDetailsGet200Response
	V3ServiceCredentialBindingsGuidDetailsGetExecute(r ApiV3ServiceCredentialBindingsGuidDetailsGetRequest) (*V3ServiceCredentialBindingsGuidDetailsGet200Response, *http.Response, error)

	/*
	V3ServiceCredentialBindingsGuidGet Get a service credential binding

	This endpoint retrieves the service credential binding by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceCredentialBindingsGuidGetRequest
	*/
	V3ServiceCredentialBindingsGuidGet(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidGetRequest

	// V3ServiceCredentialBindingsGuidGetExecute executes the request
	//  @return ServiceCredentialBinding
	V3ServiceCredentialBindingsGuidGetExecute(r ApiV3ServiceCredentialBindingsGuidGetRequest) (*ServiceCredentialBinding, *http.Response, error)

	/*
	V3ServiceCredentialBindingsGuidParametersGet Get parameters for a service credential binding

	Queries the Service Broker for the parameters associated with this service credential binding.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceCredentialBindingsGuidParametersGetRequest
	*/
	V3ServiceCredentialBindingsGuidParametersGet(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidParametersGetRequest

	// V3ServiceCredentialBindingsGuidParametersGetExecute executes the request
	//  @return map[string]interface{}
	V3ServiceCredentialBindingsGuidParametersGetExecute(r ApiV3ServiceCredentialBindingsGuidParametersGetRequest) (map[string]interface{}, *http.Response, error)

	/*
	V3ServiceCredentialBindingsGuidPatch Update a service credential binding

	This endpoint updates a service credential binding with labels and annotations.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceCredentialBindingsGuidPatchRequest
	*/
	V3ServiceCredentialBindingsGuidPatch(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidPatchRequest

	// V3ServiceCredentialBindingsGuidPatchExecute executes the request
	//  @return ServiceCredentialBinding
	V3ServiceCredentialBindingsGuidPatchExecute(r ApiV3ServiceCredentialBindingsGuidPatchRequest) (*ServiceCredentialBinding, *http.Response, error)

	/*
	V3ServiceCredentialBindingsPost Create a service credential binding

	This endpoint creates a new service credential binding. Service credential bindings can be of type app or key; key is only valid for managed service instances.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceCredentialBindingsPostRequest
	*/
	V3ServiceCredentialBindingsPost(ctx context.Context) ApiV3ServiceCredentialBindingsPostRequest

	// V3ServiceCredentialBindingsPostExecute executes the request
	//  @return ServiceCredentialBinding
	V3ServiceCredentialBindingsPostExecute(r ApiV3ServiceCredentialBindingsPostRequest) (*ServiceCredentialBinding, *http.Response, error)

	/*
	V3ServiceInstancesGet Retrieve service instances

	Retrieves the service instances the user has access to, including access granted by service instance sharing.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceInstancesGetRequest
	*/
	V3ServiceInstancesGet(ctx context.Context) ApiV3ServiceInstancesGetRequest

	// V3ServiceInstancesGetExecute executes the request
	//  @return V3ServiceInstancesGet200Response
	V3ServiceInstancesGetExecute(r ApiV3ServiceInstancesGetRequest) (*V3ServiceInstancesGet200Response, *http.Response, error)

	/*
	V3ServiceInstancesGuidCredentialsGet Get credentials for a user-provided service instance

	Retrieves the credentials for a user-provided service instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid GUID of the service instance
	@return ApiV3ServiceInstancesGuidCredentialsGetRequest
	*/
	V3ServiceInstancesGuidCredentialsGet(ctx context.Context, guid string) ApiV3ServiceInstancesGuidCredentialsGetRequest

	// V3ServiceInstancesGuidCredentialsGetExecute executes the request
	//  @return map[string]string
	V3ServiceInstancesGuidCredentialsGetExecute(r ApiV3ServiceInstancesGuidCredentialsGetRequest) (map[string]string, *http.Response, error)

	/*
	V3ServiceInstancesGuidDelete Delete a service instance

	Deletes a service instance and any associated service credential bindings or service route bindings.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid GUID of the service instance
	@return ApiV3ServiceInstancesGuidDeleteRequest
	*/
	V3ServiceInstancesGuidDelete(ctx context.Context, guid string) ApiV3ServiceInstancesGuidDeleteRequest

	// V3ServiceInstancesGuidDeleteExecute executes the request
	V3ServiceInstancesGuidDeleteExecute(r ApiV3ServiceInstancesGuidDeleteRequest) (*http.Response, error)

	/*
	V3ServiceInstancesGuidPatch Update a service instance

	Updates a service instance with the provided attributes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid GUID of the service instance
	@return ApiV3ServiceInstancesGuidPatchRequest
	*/
	V3ServiceInstancesGuidPatch(ctx context.Context, guid string) ApiV3ServiceInstancesGuidPatchRequest

	// V3ServiceInstancesGuidPatchExecute executes the request
	//  @return ServiceInstance
	V3ServiceInstancesGuidPatchExecute(r ApiV3ServiceInstancesGuidPatchRequest) (*ServiceInstance, *http.Response, error)

	/*
	V3ServiceInstancesGuidRelationshipsSharedSpacesPost Share a service instance to other spaces

	Shares the service instance with the specified spaces.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid GUID of the service instance
	@return ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest
	*/
	V3ServiceInstancesGuidRelationshipsSharedSpacesPost(ctx context.Context, guid string) ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest

	// V3ServiceInstancesGuidRelationshipsSharedSpacesPostExecute executes the request
	//  @return V3ServiceInstancesGuidRelationshipsSharedSpacesGet200Response
	V3ServiceInstancesGuidRelationshipsSharedSpacesPostExecute(r ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest) (*V3ServiceInstancesGuidRelationshipsSharedSpacesGet200Response, *http.Response, error)

	/*
	V3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDelete Unshare a service instance from another space

	Unshares the service instance from the specified space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid GUID of the service instance
	@param spaceGuid GUID of the space
	@return ApiV3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteRequest
	*/
	V3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDelete(ctx context.Context, guid string, spaceGuid string) ApiV3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteRequest

	// V3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteExecute executes the request
	V3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteExecute(r ApiV3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteRequest) (*http.Response, error)

	/*
	V3ServiceOfferingsGet List service offerings

	Retrieves the service offerings the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceOfferingsGetRequest
	*/
	V3ServiceOfferingsGet(ctx context.Context) ApiV3ServiceOfferingsGetRequest

	// V3ServiceOfferingsGetExecute executes the request
	//  @return ServiceOfferingList
	V3ServiceOfferingsGetExecute(r ApiV3ServiceOfferingsGetRequest) (*ServiceOfferingList, *http.Response, error)

	/*
	V3ServiceOfferingsGuidDelete Delete a service offering

	Deletes a service offering.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The service offering GUID
	@return ApiV3ServiceOfferingsGuidDeleteRequest
	*/
	V3ServiceOfferingsGuidDelete(ctx context.Context, guid string) ApiV3ServiceOfferingsGuidDeleteRequest

	// V3ServiceOfferingsGuidDeleteExecute executes the request
	V3ServiceOfferingsGuidDeleteExecute(r ApiV3ServiceOfferingsGuidDeleteRequest) (*http.Response, error)

	/*
	V3ServiceOfferingsGuidGet Get a service offering

	Retrieves the service offering by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The service offering GUID
	@return ApiV3ServiceOfferingsGuidGetRequest
	*/
	V3ServiceOfferingsGuidGet(ctx context.Context, guid string) ApiV3ServiceOfferingsGuidGetRequest

	// V3ServiceOfferingsGuidGetExecute executes the request
	//  @return ServiceOffering
	V3ServiceOfferingsGuidGetExecute(r ApiV3ServiceOfferingsGuidGetRequest) (*ServiceOffering, *http.Response, error)

	/*
	V3ServiceOfferingsGuidPatch Update a service offering

	Updates a service offering.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The service offering GUID
	@return ApiV3ServiceOfferingsGuidPatchRequest
	*/
	V3ServiceOfferingsGuidPatch(ctx context.Context, guid string) ApiV3ServiceOfferingsGuidPatchRequest

	// V3ServiceOfferingsGuidPatchExecute executes the request
	//  @return ServiceOffering
	V3ServiceOfferingsGuidPatchExecute(r ApiV3ServiceOfferingsGuidPatchRequest) (*ServiceOffering, *http.Response, error)

	/*
	V3ServiceOfferingsPost Create a service offering

	Creates a new service offering.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceOfferingsPostRequest
	*/
	V3ServiceOfferingsPost(ctx context.Context) ApiV3ServiceOfferingsPostRequest

	// V3ServiceOfferingsPostExecute executes the request
	//  @return ServiceOffering
	V3ServiceOfferingsPostExecute(r ApiV3ServiceOfferingsPostRequest) (*ServiceOffering, *http.Response, error)

	/*
	V3ServicePlansGet List service plans

	Retrieves the service plans the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServicePlansGetRequest
	*/
	V3ServicePlansGet(ctx context.Context) ApiV3ServicePlansGetRequest

	// V3ServicePlansGetExecute executes the request
	//  @return ServicePlanList
	V3ServicePlansGetExecute(r ApiV3ServicePlansGetRequest) (*ServicePlanList, *http.Response, error)

	/*
	V3ServicePlansGuidDelete Delete a service plan

	Deletes a service plan.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The service plan GUID
	@return ApiV3ServicePlansGuidDeleteRequest
	*/
	V3ServicePlansGuidDelete(ctx context.Context, guid string) ApiV3ServicePlansGuidDeleteRequest

	// V3ServicePlansGuidDeleteExecute executes the request
	V3ServicePlansGuidDeleteExecute(r ApiV3ServicePlansGuidDeleteRequest) (*http.Response, error)

	/*
	V3ServicePlansGuidGet Get a service plan

	Retrieves the service plan by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The service plan GUID
	@return ApiV3ServicePlansGuidGetRequest
	*/
	V3ServicePlansGuidGet(ctx context.Context, guid string) ApiV3ServicePlansGuidGetRequest

	// V3ServicePlansGuidGetExecute executes the request
	//  @return ServicePlan
	V3ServicePlansGuidGetExecute(r ApiV3ServicePlansGuidGetRequest) (*ServicePlan, *http.Response, error)

	/*
	V3ServicePlansGuidPatch Update a service plan

	Updates a service plan.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The service plan GUID
	@return ApiV3ServicePlansGuidPatchRequest
	*/
	V3ServicePlansGuidPatch(ctx context.Context, guid string) ApiV3ServicePlansGuidPatchRequest

	// V3ServicePlansGuidPatchExecute executes the request
	//  @return ServicePlan
	V3ServicePlansGuidPatchExecute(r ApiV3ServicePlansGuidPatchRequest) (*ServicePlan, *http.Response, error)

	/*
	V3ServicePlansPost Create a service plan

	Creates a new service plan.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServicePlansPostRequest
	*/
	V3ServicePlansPost(ctx context.Context) ApiV3ServicePlansPostRequest

	// V3ServicePlansPostExecute executes the request
	//  @return ServicePlan
	V3ServicePlansPostExecute(r ApiV3ServicePlansPostRequest) (*ServicePlan, *http.Response, error)

	/*
	V3ServiceRouteBindingsGet List service route bindings

	Retrieves the service route bindings the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceRouteBindingsGetRequest
	*/
	V3ServiceRouteBindingsGet(ctx context.Context) ApiV3ServiceRouteBindingsGetRequest

	// V3ServiceRouteBindingsGetExecute executes the request
	//  @return V3ServiceRouteBindingsGet200Response
	V3ServiceRouteBindingsGetExecute(r ApiV3ServiceRouteBindingsGetRequest) (*V3ServiceRouteBindingsGet200Response, *http.Response, error)

	/*
	V3ServiceRouteBindingsGuidDelete Delete a service route binding

	Deletes a service route binding. When deleting route bindings originating from user-provided service instances, the delete operation does not require interactions with service brokers, therefore the API will respond synchronously to the delete request.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceRouteBindingsGuidDeleteRequest
	*/
	V3ServiceRouteBindingsGuidDelete(ctx context.Context, guid string) ApiV3ServiceRouteBindingsGuidDeleteRequest

	// V3ServiceRouteBindingsGuidDeleteExecute executes the request
	V3ServiceRouteBindingsGuidDeleteExecute(r ApiV3ServiceRouteBindingsGuidDeleteRequest) (*http.Response, error)

	/*
	V3ServiceRouteBindingsGuidGet Get a service route binding

	Retrieves the service route binding by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceRouteBindingsGuidGetRequest
	*/
	V3ServiceRouteBindingsGuidGet(ctx context.Context, guid string) ApiV3ServiceRouteBindingsGuidGetRequest

	// V3ServiceRouteBindingsGuidGetExecute executes the request
	//  @return ServiceRouteBinding
	V3ServiceRouteBindingsGuidGetExecute(r ApiV3ServiceRouteBindingsGuidGetRequest) (*ServiceRouteBinding, *http.Response, error)

	/*
	V3ServiceRouteBindingsGuidParametersGet Get parameters for a route binding

	Queries the Service Broker for the parameters associated with this service route binding. This endpoint is not available for User-Provided Service Instances.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceRouteBindingsGuidParametersGetRequest
	*/
	V3ServiceRouteBindingsGuidParametersGet(ctx context.Context, guid string) ApiV3ServiceRouteBindingsGuidParametersGetRequest

	// V3ServiceRouteBindingsGuidParametersGetExecute executes the request
	//  @return map[string]string
	V3ServiceRouteBindingsGuidParametersGetExecute(r ApiV3ServiceRouteBindingsGuidParametersGetRequest) (map[string]string, *http.Response, error)

	/*
	V3ServiceRouteBindingsGuidPatch Update a service route binding

	Updates a service route binding with labels and annotations.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceRouteBindingsGuidPatchRequest
	*/
	V3ServiceRouteBindingsGuidPatch(ctx context.Context, guid string) ApiV3ServiceRouteBindingsGuidPatchRequest

	// V3ServiceRouteBindingsGuidPatchExecute executes the request
	//  @return ServiceRouteBinding
	V3ServiceRouteBindingsGuidPatchExecute(r ApiV3ServiceRouteBindingsGuidPatchRequest) (*ServiceRouteBinding, *http.Response, error)

	/*
	V3ServiceRouteBindingsPost Create a service route binding

	Creates a new route service binding. The service instance and the route must be in the same space.
To bind a route to a user-provided service instance, the service instance must have the route_service_url property set.
To bind a route to a managed service instance, the service offering must be bindable, and the service offering must have route_forwarding set in the requires property.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceRouteBindingsPostRequest
	*/
	V3ServiceRouteBindingsPost(ctx context.Context) ApiV3ServiceRouteBindingsPostRequest

	// V3ServiceRouteBindingsPostExecute executes the request
	//  @return ServiceRouteBinding
	V3ServiceRouteBindingsPostExecute(r ApiV3ServiceRouteBindingsPostRequest) (*ServiceRouteBinding, *http.Response, error)

	/*
	V3ServiceUsageEventsGet List service usage events

	Retrieve all service usage events the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceUsageEventsGetRequest
	*/
	V3ServiceUsageEventsGet(ctx context.Context) ApiV3ServiceUsageEventsGetRequest

	// V3ServiceUsageEventsGetExecute executes the request
	//  @return V3ServiceUsageEventsGet200Response
	V3ServiceUsageEventsGetExecute(r ApiV3ServiceUsageEventsGetRequest) (*V3ServiceUsageEventsGet200Response, *http.Response, error)

	/*
	V3ServiceUsageEventsGuidGet Get a service usage event

	Retrieve a service usage event by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3ServiceUsageEventsGuidGetRequest
	*/
	V3ServiceUsageEventsGuidGet(ctx context.Context, guid string) ApiV3ServiceUsageEventsGuidGetRequest

	// V3ServiceUsageEventsGuidGetExecute executes the request
	//  @return ServiceUsageEvent
	V3ServiceUsageEventsGuidGetExecute(r ApiV3ServiceUsageEventsGuidGetRequest) (*ServiceUsageEvent, *http.Response, error)

	/*
	V3ServiceUsageEventsPost Purge and seed service usage events

	Destroys all existing events. Populates new usage events, one for each existing service instance.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3ServiceUsageEventsPostRequest
	*/
	V3ServiceUsageEventsPost(ctx context.Context) ApiV3ServiceUsageEventsPostRequest

	// V3ServiceUsageEventsPostExecute executes the request
	V3ServiceUsageEventsPostExecute(r ApiV3ServiceUsageEventsPostRequest) (*http.Response, error)

	/*
	V3SpacesGet List spaces

	Retrieve all spaces the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3SpacesGetRequest
	*/
	V3SpacesGet(ctx context.Context) ApiV3SpacesGetRequest

	// V3SpacesGetExecute executes the request
	//  @return V3SpacesGet200Response
	V3SpacesGetExecute(r ApiV3SpacesGetRequest) (*V3SpacesGet200Response, *http.Response, error)

	/*
	V3SpacesGuidDelete Delete a space

	Delete a space by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3SpacesGuidDeleteRequest
	*/
	V3SpacesGuidDelete(ctx context.Context, guid string) ApiV3SpacesGuidDeleteRequest

	// V3SpacesGuidDeleteExecute executes the request
	V3SpacesGuidDeleteExecute(r ApiV3SpacesGuidDeleteRequest) (*http.Response, error)

	/*
	V3SpacesGuidGet Get a space

	Retrieve a space by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3SpacesGuidGetRequest
	*/
	V3SpacesGuidGet(ctx context.Context, guid string) ApiV3SpacesGuidGetRequest

	// V3SpacesGuidGetExecute executes the request
	//  @return Space
	V3SpacesGuidGetExecute(r ApiV3SpacesGuidGetRequest) (*Space, *http.Response, error)

	/*
	V3SpacesGuidPatch Update a space

	Update a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3SpacesGuidPatchRequest
	*/
	V3SpacesGuidPatch(ctx context.Context, guid string) ApiV3SpacesGuidPatchRequest

	// V3SpacesGuidPatchExecute executes the request
	//  @return Space
	V3SpacesGuidPatchExecute(r ApiV3SpacesGuidPatchRequest) (*Space, *http.Response, error)

	/*
	V3SpacesGuidRelationshipsIsolationSegmentGet Get assigned isolation segment

	Retrieve the isolation segment assigned to the space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3SpacesGuidRelationshipsIsolationSegmentGetRequest
	*/
	V3SpacesGuidRelationshipsIsolationSegmentGet(ctx context.Context, guid string) ApiV3SpacesGuidRelationshipsIsolationSegmentGetRequest

	// V3SpacesGuidRelationshipsIsolationSegmentGetExecute executes the request
	//  @return AssignDefaultIsolationSegmentRequest
	V3SpacesGuidRelationshipsIsolationSegmentGetExecute(r ApiV3SpacesGuidRelationshipsIsolationSegmentGetRequest) (*AssignDefaultIsolationSegmentRequest, *http.Response, error)

	/*
	V3SpacesGuidRelationshipsIsolationSegmentPatch Manage isolation segment

	Assign or unassign an isolation segment to a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest
	*/
	V3SpacesGuidRelationshipsIsolationSegmentPatch(ctx context.Context, guid string) ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest

	// V3SpacesGuidRelationshipsIsolationSegmentPatchExecute executes the request
	//  @return AssignDefaultIsolationSegmentRequest
	V3SpacesGuidRelationshipsIsolationSegmentPatchExecute(r ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest) (*AssignDefaultIsolationSegmentRequest, *http.Response, error)

	/*
	V3SpacesGuidUsersGet List users for a space

	Retrieve all users with a role in the specified space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3SpacesGuidUsersGetRequest
	*/
	V3SpacesGuidUsersGet(ctx context.Context, guid string) ApiV3SpacesGuidUsersGetRequest

	// V3SpacesGuidUsersGetExecute executes the request
	//  @return V3SpacesGuidUsersGet200Response
	V3SpacesGuidUsersGetExecute(r ApiV3SpacesGuidUsersGetRequest) (*V3SpacesGuidUsersGet200Response, *http.Response, error)

	/*
	V3SpacesPost Create a space

	Create a space.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3SpacesPostRequest
	*/
	V3SpacesPost(ctx context.Context) ApiV3SpacesPostRequest

	// V3SpacesPostExecute executes the request
	//  @return Space
	V3SpacesPostExecute(r ApiV3SpacesPostRequest) (*Space, *http.Response, error)

	/*
	V3StacksGet List all stacks

	Retrieve all stacks.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3StacksGetRequest
	*/
	V3StacksGet(ctx context.Context) ApiV3StacksGetRequest

	// V3StacksGetExecute executes the request
	//  @return V3StacksGet200Response
	V3StacksGetExecute(r ApiV3StacksGetRequest) (*V3StacksGet200Response, *http.Response, error)

	/*
	V3StacksGuidAppsGet List apps on a stack

	Retrieve all apps using a given stack.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3StacksGuidAppsGetRequest
	*/
	V3StacksGuidAppsGet(ctx context.Context, guid string) ApiV3StacksGuidAppsGetRequest

	// V3StacksGuidAppsGetExecute executes the request
	//  @return V3StacksGuidAppsGet200Response
	V3StacksGuidAppsGetExecute(r ApiV3StacksGuidAppsGetRequest) (*V3StacksGuidAppsGet200Response, *http.Response, error)

	/*
	V3StacksGuidDelete Delete a stack

	Delete a stack by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3StacksGuidDeleteRequest
	*/
	V3StacksGuidDelete(ctx context.Context, guid string) ApiV3StacksGuidDeleteRequest

	// V3StacksGuidDeleteExecute executes the request
	V3StacksGuidDeleteExecute(r ApiV3StacksGuidDeleteRequest) (*http.Response, error)

	/*
	V3StacksGuidGet Get a stack by GUID

	Retrieve a stack by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3StacksGuidGetRequest
	*/
	V3StacksGuidGet(ctx context.Context, guid string) ApiV3StacksGuidGetRequest

	// V3StacksGuidGetExecute executes the request
	//  @return Stack
	V3StacksGuidGetExecute(r ApiV3StacksGuidGetRequest) (*Stack, *http.Response, error)

	/*
	V3StacksGuidPatch Update a stack

	Update the specified parameters of a stack.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3StacksGuidPatchRequest
	*/
	V3StacksGuidPatch(ctx context.Context, guid string) ApiV3StacksGuidPatchRequest

	// V3StacksGuidPatchExecute executes the request
	//  @return Stack
	V3StacksGuidPatchExecute(r ApiV3StacksGuidPatchRequest) (*Stack, *http.Response, error)

	/*
	V3StacksPost Create a stack

	Create a new stack.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3StacksPostRequest
	*/
	V3StacksPost(ctx context.Context) ApiV3StacksPostRequest

	// V3StacksPostExecute executes the request
	//  @return Stack
	V3StacksPostExecute(r ApiV3StacksPostRequest) (*Stack, *http.Response, error)

	/*
	V3TasksGet List all tasks

	Retrieve all tasks the user has access to.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3TasksGetRequest
	*/
	V3TasksGet(ctx context.Context) ApiV3TasksGetRequest

	// V3TasksGetExecute executes the request
	//  @return V3TasksGet200Response
	V3TasksGetExecute(r ApiV3TasksGetRequest) (*V3TasksGet200Response, *http.Response, error)

	/*
	V3TasksGuidGet Get a task

	Retrieve a specific task by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3TasksGuidGetRequest
	*/
	V3TasksGuidGet(ctx context.Context, guid string) ApiV3TasksGuidGetRequest

	// V3TasksGuidGetExecute executes the request
	//  @return Task
	V3TasksGuidGetExecute(r ApiV3TasksGuidGetRequest) (*Task, *http.Response, error)

	/*
	V3TasksGuidPatch Update a task

	Update the specified parameters of a task.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3TasksGuidPatchRequest
	*/
	V3TasksGuidPatch(ctx context.Context, guid string) ApiV3TasksGuidPatchRequest

	// V3TasksGuidPatchExecute executes the request
	//  @return Task
	V3TasksGuidPatchExecute(r ApiV3TasksGuidPatchRequest) (*Task, *http.Response, error)

	/*
	V3TasksGuidPost Cancel a task

	Cancels a running task.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid
	@return ApiV3TasksGuidPostRequest
	*/
	V3TasksGuidPost(ctx context.Context, guid string) ApiV3TasksGuidPostRequest

	// V3TasksGuidPostExecute executes the request
	//  @return Task
	V3TasksGuidPostExecute(r ApiV3TasksGuidPostRequest) (*Task, *http.Response, error)

	/*
	V3UsersGet List users

	Retrieve all users that the current user can see.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3UsersGetRequest
	*/
	V3UsersGet(ctx context.Context) ApiV3UsersGetRequest

	// V3UsersGetExecute executes the request
	//  @return V3UsersGet200Response
	V3UsersGetExecute(r ApiV3UsersGetRequest) (*V3UsersGet200Response, *http.Response, error)

	/*
	V3UsersGuidDelete Delete a user

	Delete a user by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid Unique identifier for the user
	@return ApiV3UsersGuidDeleteRequest
	*/
	V3UsersGuidDelete(ctx context.Context, guid string) ApiV3UsersGuidDeleteRequest

	// V3UsersGuidDeleteExecute executes the request
	V3UsersGuidDeleteExecute(r ApiV3UsersGuidDeleteRequest) (*http.Response, error)

	/*
	V3UsersGuidGet Get a user

	Retrieve a user by GUID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid Unique identifier for the user
	@return ApiV3UsersGuidGetRequest
	*/
	V3UsersGuidGet(ctx context.Context, guid string) ApiV3UsersGuidGetRequest

	// V3UsersGuidGetExecute executes the request
	//  @return User
	V3UsersGuidGetExecute(r ApiV3UsersGuidGetRequest) (*User, *http.Response, error)

	/*
	V3UsersGuidPatch Update a user

	Update a user’s metadata.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid Unique identifier for the user
	@return ApiV3UsersGuidPatchRequest
	*/
	V3UsersGuidPatch(ctx context.Context, guid string) ApiV3UsersGuidPatchRequest

	// V3UsersGuidPatchExecute executes the request
	//  @return User
	V3UsersGuidPatchExecute(r ApiV3UsersGuidPatchRequest) (*User, *http.Response, error)

	/*
	V3UsersPost Create a user

	Creates a user in the Cloud Controller database.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3UsersPostRequest
	*/
	V3UsersPost(ctx context.Context) ApiV3UsersPostRequest

	// V3UsersPostExecute executes the request
	//  @return User
	V3UsersPostExecute(r ApiV3UsersPostRequest) (*User, *http.Response, error)
}

// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiAssignDefaultIsolationSegmentRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	assignDefaultIsolationSegmentRequest *AssignDefaultIsolationSegmentRequest
}

func (r ApiAssignDefaultIsolationSegmentRequest) AssignDefaultIsolationSegmentRequest(assignDefaultIsolationSegmentRequest AssignDefaultIsolationSegmentRequest) ApiAssignDefaultIsolationSegmentRequest {
	r.assignDefaultIsolationSegmentRequest = &assignDefaultIsolationSegmentRequest
	return r
}

func (r ApiAssignDefaultIsolationSegmentRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.AssignDefaultIsolationSegmentExecute(r)
}

/*
AssignDefaultIsolationSegment Assign Default Isolation Segment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiAssignDefaultIsolationSegmentRequest
*/
func (a *DefaultAPIService) AssignDefaultIsolationSegment(ctx context.Context, guid string) ApiAssignDefaultIsolationSegmentRequest {
	return ApiAssignDefaultIsolationSegmentRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) AssignDefaultIsolationSegmentExecute(r ApiAssignDefaultIsolationSegmentRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.AssignDefaultIsolationSegment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations/{guid}/relationships/default_isolation_segment"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.assignDefaultIsolationSegmentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrganizationRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	createOrganizationRequest *CreateOrganizationRequest
}

func (r ApiCreateOrganizationRequest) CreateOrganizationRequest(createOrganizationRequest CreateOrganizationRequest) ApiCreateOrganizationRequest {
	r.createOrganizationRequest = &createOrganizationRequest
	return r
}

func (r ApiCreateOrganizationRequest) Execute() (*Organization, *http.Response, error) {
	return r.ApiService.CreateOrganizationExecute(r)
}

/*
CreateOrganization Create an Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrganizationRequest
*/
func (a *DefaultAPIService) CreateOrganization(ctx context.Context) ApiCreateOrganizationRequest {
	return ApiCreateOrganizationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Organization
func (a *DefaultAPIService) CreateOrganizationExecute(r ApiCreateOrganizationRequest) (*Organization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CreateOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrganizationRequest == nil {
		return localVarReturnValue, nil, reportError("createOrganizationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrganizationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOrganizationRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiDeleteOrganizationRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteOrganizationExecute(r)
}

/*
DeleteOrganization Delete an Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiDeleteOrganizationRequest
*/
func (a *DefaultAPIService) DeleteOrganization(ctx context.Context, guid string) ApiDeleteOrganizationRequest {
	return ApiDeleteOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) DeleteOrganizationExecute(r ApiDeleteOrganizationRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DeleteOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDefaultDomainRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiGetDefaultDomainRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDefaultDomainExecute(r)
}

/*
GetDefaultDomain Get Default Domain

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiGetDefaultDomainRequest
*/
func (a *DefaultAPIService) GetDefaultDomain(ctx context.Context, guid string) ApiGetDefaultDomainRequest {
	return ApiGetDefaultDomainRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) GetDefaultDomainExecute(r ApiGetDefaultDomainRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetDefaultDomain")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations/{guid}/domains/default"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDefaultIsolationSegmentRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiGetDefaultIsolationSegmentRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetDefaultIsolationSegmentExecute(r)
}

/*
GetDefaultIsolationSegment Get Default Isolation Segment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiGetDefaultIsolationSegmentRequest
*/
func (a *DefaultAPIService) GetDefaultIsolationSegment(ctx context.Context, guid string) ApiGetDefaultIsolationSegmentRequest {
	return ApiGetDefaultIsolationSegmentRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) GetDefaultIsolationSegmentExecute(r ApiGetDefaultIsolationSegmentRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetDefaultIsolationSegment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations/{guid}/relationships/default_isolation_segment"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrganizationRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiGetOrganizationRequest) Execute() (*Organization, *http.Response, error) {
	return r.ApiService.GetOrganizationExecute(r)
}

/*
GetOrganization Get an Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiGetOrganizationRequest
*/
func (a *DefaultAPIService) GetOrganization(ctx context.Context, guid string) ApiGetOrganizationRequest {
	return ApiGetOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Organization
func (a *DefaultAPIService) GetOrganizationExecute(r ApiGetOrganizationRequest) (*Organization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsageSummaryRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiGetUsageSummaryRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUsageSummaryExecute(r)
}

/*
GetUsageSummary Get Usage Summary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiGetUsageSummaryRequest
*/
func (a *DefaultAPIService) GetUsageSummary(ctx context.Context, guid string) ApiGetUsageSummaryRequest {
	return ApiGetUsageSummaryRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) GetUsageSummaryExecute(r ApiGetUsageSummaryRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.GetUsageSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations/{guid}/usage_summary"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOrganizationsRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	names *string
	guids *string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

func (r ApiListOrganizationsRequest) Names(names string) ApiListOrganizationsRequest {
	r.names = &names
	return r
}

func (r ApiListOrganizationsRequest) Guids(guids string) ApiListOrganizationsRequest {
	r.guids = &guids
	return r
}

func (r ApiListOrganizationsRequest) Page(page int32) ApiListOrganizationsRequest {
	r.page = &page
	return r
}

func (r ApiListOrganizationsRequest) PerPage(perPage int32) ApiListOrganizationsRequest {
	r.perPage = &perPage
	return r
}

func (r ApiListOrganizationsRequest) OrderBy(orderBy string) ApiListOrganizationsRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiListOrganizationsRequest) LabelSelector(labelSelector string) ApiListOrganizationsRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiListOrganizationsRequest) CreatedAts(createdAts string) ApiListOrganizationsRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiListOrganizationsRequest) UpdatedAts(updatedAts string) ApiListOrganizationsRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiListOrganizationsRequest) Execute() ([]Organization, *http.Response, error) {
	return r.ApiService.ListOrganizationsExecute(r)
}

/*
ListOrganizations List Organizations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListOrganizationsRequest
*/
func (a *DefaultAPIService) ListOrganizations(ctx context.Context) ApiListOrganizationsRequest {
	return ApiListOrganizationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Organization
func (a *DefaultAPIService) ListOrganizationsExecute(r ApiListOrganizationsRequest) ([]Organization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListOrganizations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.names != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "names", r.names, "form", "")
	}
	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUsersForOrganizationRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	guids *string
	usernames *string
	partialUsernames *string
	origins *string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

func (r ApiListUsersForOrganizationRequest) Guids(guids string) ApiListUsersForOrganizationRequest {
	r.guids = &guids
	return r
}

func (r ApiListUsersForOrganizationRequest) Usernames(usernames string) ApiListUsersForOrganizationRequest {
	r.usernames = &usernames
	return r
}

func (r ApiListUsersForOrganizationRequest) PartialUsernames(partialUsernames string) ApiListUsersForOrganizationRequest {
	r.partialUsernames = &partialUsernames
	return r
}

func (r ApiListUsersForOrganizationRequest) Origins(origins string) ApiListUsersForOrganizationRequest {
	r.origins = &origins
	return r
}

func (r ApiListUsersForOrganizationRequest) Page(page int32) ApiListUsersForOrganizationRequest {
	r.page = &page
	return r
}

func (r ApiListUsersForOrganizationRequest) PerPage(perPage int32) ApiListUsersForOrganizationRequest {
	r.perPage = &perPage
	return r
}

func (r ApiListUsersForOrganizationRequest) OrderBy(orderBy string) ApiListUsersForOrganizationRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiListUsersForOrganizationRequest) LabelSelector(labelSelector string) ApiListUsersForOrganizationRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiListUsersForOrganizationRequest) CreatedAts(createdAts string) ApiListUsersForOrganizationRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiListUsersForOrganizationRequest) UpdatedAts(updatedAts string) ApiListUsersForOrganizationRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiListUsersForOrganizationRequest) Execute() ([]User, *http.Response, error) {
	return r.ApiService.ListUsersForOrganizationExecute(r)
}

/*
ListUsersForOrganization List Users for an Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiListUsersForOrganizationRequest
*/
func (a *DefaultAPIService) ListUsersForOrganization(ctx context.Context, guid string) ApiListUsersForOrganizationRequest {
	return ApiListUsersForOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return []User
func (a *DefaultAPIService) ListUsersForOrganizationExecute(r ApiListUsersForOrganizationRequest) ([]User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ListUsersForOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations/{guid}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "")
	}
	if r.usernames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usernames", r.usernames, "form", "")
	}
	if r.partialUsernames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partial_usernames", r.partialUsernames, "form", "")
	}
	if r.origins != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origins", r.origins, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRootGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiRootGetRequest) Execute() (*Get200Response, *http.Response, error) {
	return r.ApiService.RootGetExecute(r)
}

/*
RootGet Global API Root

Returns links to the APIs available on a given Cloud Foundry deployment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRootGetRequest
*/
func (a *DefaultAPIService) RootGet(ctx context.Context) ApiRootGetRequest {
	return ApiRootGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Get200Response
func (a *DefaultAPIService) RootGetExecute(r ApiRootGetRequest) (*Get200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Get200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RootGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOrganizationRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	updateOrganizationRequest *UpdateOrganizationRequest
}

func (r ApiUpdateOrganizationRequest) UpdateOrganizationRequest(updateOrganizationRequest UpdateOrganizationRequest) ApiUpdateOrganizationRequest {
	r.updateOrganizationRequest = &updateOrganizationRequest
	return r
}

func (r ApiUpdateOrganizationRequest) Execute() (*Organization, *http.Response, error) {
	return r.ApiService.UpdateOrganizationExecute(r)
}

/*
UpdateOrganization Update an Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiUpdateOrganizationRequest
*/
func (a *DefaultAPIService) UpdateOrganization(ctx context.Context, guid string) ApiUpdateOrganizationRequest {
	return ApiUpdateOrganizationRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Organization
func (a *DefaultAPIService) UpdateOrganizationExecute(r ApiUpdateOrganizationRequest) (*Organization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UpdateOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/organizations/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateOrganizationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidDropletsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	guids *[]string
	states *[]string
	current *bool
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
}

// Comma-delimited list of droplet guids to filter by
func (r ApiV3AppsGuidDropletsGetRequest) Guids(guids []string) ApiV3AppsGuidDropletsGetRequest {
	r.guids = &guids
	return r
}

// Comma-delimited list of droplet states to filter by
func (r ApiV3AppsGuidDropletsGetRequest) States(states []string) ApiV3AppsGuidDropletsGetRequest {
	r.states = &states
	return r
}

// If true, only include the droplet currently assigned to the app
func (r ApiV3AppsGuidDropletsGetRequest) Current(current bool) ApiV3AppsGuidDropletsGetRequest {
	r.current = &current
	return r
}

// Page to display
func (r ApiV3AppsGuidDropletsGetRequest) Page(page int32) ApiV3AppsGuidDropletsGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3AppsGuidDropletsGetRequest) PerPage(perPage int32) ApiV3AppsGuidDropletsGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by
func (r ApiV3AppsGuidDropletsGetRequest) OrderBy(orderBy string) ApiV3AppsGuidDropletsGetRequest {
	r.orderBy = &orderBy
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3AppsGuidDropletsGetRequest) LabelSelector(labelSelector string) ApiV3AppsGuidDropletsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3AppsGuidDropletsGetRequest) Execute() (*V3AppsGuidDropletsGet200Response, *http.Response, error) {
	return r.ApiService.V3AppsGuidDropletsGetExecute(r)
}

/*
V3AppsGuidDropletsGet List droplets for an app

Retrieve a list of droplets belonging to an app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the app
 @return ApiV3AppsGuidDropletsGetRequest
*/
func (a *DefaultAPIService) V3AppsGuidDropletsGet(ctx context.Context, guid string) ApiV3AppsGuidDropletsGetRequest {
	return ApiV3AppsGuidDropletsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidDropletsGet200Response
func (a *DefaultAPIService) V3AppsGuidDropletsGetExecute(r ApiV3AppsGuidDropletsGetRequest) (*V3AppsGuidDropletsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidDropletsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidDropletsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/droplets"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		t := *r.guids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guids", t, "form", "multi")
		}
	}
	if r.states != nil {
		t := *r.states
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "states", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "states", t, "form", "multi")
		}
	}
	if r.current != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "current", r.current, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidRevisionsDeployedGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	page *int32
	perPage *int32
	orderBy *string
}

// Page to display; valid values are integers &gt;&#x3D; 1
func (r ApiV3AppsGuidRevisionsDeployedGetRequest) Page(page int32) ApiV3AppsGuidRevisionsDeployedGetRequest {
	r.page = &page
	return r
}

// Number of results per page; valid values are 1 through 5000
func (r ApiV3AppsGuidRevisionsDeployedGetRequest) PerPage(perPage int32) ApiV3AppsGuidRevisionsDeployedGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by. Defaults to ascending; prepend with - to sort descending.
func (r ApiV3AppsGuidRevisionsDeployedGetRequest) OrderBy(orderBy string) ApiV3AppsGuidRevisionsDeployedGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3AppsGuidRevisionsDeployedGetRequest) Execute() (*RevisionsList, *http.Response, error) {
	return r.ApiService.V3AppsGuidRevisionsDeployedGetExecute(r)
}

/*
V3AppsGuidRevisionsDeployedGet List deployed revisions for an app

Retrieve deployed revisions for an app the user has access to. Deployed revisions are revisions that are linked to started processes in the app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid Unique identifier for the app
 @return ApiV3AppsGuidRevisionsDeployedGetRequest
*/
func (a *DefaultAPIService) V3AppsGuidRevisionsDeployedGet(ctx context.Context, guid string) ApiV3AppsGuidRevisionsDeployedGetRequest {
	return ApiV3AppsGuidRevisionsDeployedGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return RevisionsList
func (a *DefaultAPIService) V3AppsGuidRevisionsDeployedGetExecute(r ApiV3AppsGuidRevisionsDeployedGetRequest) (*RevisionsList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RevisionsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidRevisionsDeployedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/revisions/deployed"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidRevisionsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	versions *[]string
	labelSelector *string
	page *int32
	perPage *int32
	orderBy *string
	createdAts *string
	updatedAts *string
}

// Comma-delimited list of revision versions to filter by
func (r ApiV3AppsGuidRevisionsGetRequest) Versions(versions []string) ApiV3AppsGuidRevisionsGetRequest {
	r.versions = &versions
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3AppsGuidRevisionsGetRequest) LabelSelector(labelSelector string) ApiV3AppsGuidRevisionsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Page to display; valid values are integers &gt;&#x3D; 1
func (r ApiV3AppsGuidRevisionsGetRequest) Page(page int32) ApiV3AppsGuidRevisionsGetRequest {
	r.page = &page
	return r
}

// Number of results per page; valid values are 1 through 5000
func (r ApiV3AppsGuidRevisionsGetRequest) PerPage(perPage int32) ApiV3AppsGuidRevisionsGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by. Defaults to ascending; prepend with - to sort descending.
func (r ApiV3AppsGuidRevisionsGetRequest) OrderBy(orderBy string) ApiV3AppsGuidRevisionsGetRequest {
	r.orderBy = &orderBy
	return r
}

// Timestamp to filter by; supports filtering with relational operators
func (r ApiV3AppsGuidRevisionsGetRequest) CreatedAts(createdAts string) ApiV3AppsGuidRevisionsGetRequest {
	r.createdAts = &createdAts
	return r
}

// Timestamp to filter by; supports filtering with relational operators
func (r ApiV3AppsGuidRevisionsGetRequest) UpdatedAts(updatedAts string) ApiV3AppsGuidRevisionsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3AppsGuidRevisionsGetRequest) Execute() (*RevisionsList, *http.Response, error) {
	return r.ApiService.V3AppsGuidRevisionsGetExecute(r)
}

/*
V3AppsGuidRevisionsGet List revisions for an app

Retrieve revisions for an app the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid Unique identifier for the app
 @return ApiV3AppsGuidRevisionsGetRequest
*/
func (a *DefaultAPIService) V3AppsGuidRevisionsGet(ctx context.Context, guid string) ApiV3AppsGuidRevisionsGetRequest {
	return ApiV3AppsGuidRevisionsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return RevisionsList
func (a *DefaultAPIService) V3AppsGuidRevisionsGetExecute(r ApiV3AppsGuidRevisionsGetRequest) (*RevisionsList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RevisionsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidRevisionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/revisions"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.versions != nil {
		t := *r.versions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "versions", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "versions", t, "form", "multi")
		}
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidTasksPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3AppsGuidTasksPostRequest *V3AppsGuidTasksPostRequest
}

func (r ApiV3AppsGuidTasksPostRequest) V3AppsGuidTasksPostRequest(v3AppsGuidTasksPostRequest V3AppsGuidTasksPostRequest) ApiV3AppsGuidTasksPostRequest {
	r.v3AppsGuidTasksPostRequest = &v3AppsGuidTasksPostRequest
	return r
}

func (r ApiV3AppsGuidTasksPostRequest) Execute() (*Task, *http.Response, error) {
	return r.ApiService.V3AppsGuidTasksPostExecute(r)
}

/*
V3AppsGuidTasksPost Create a task

Create a new task for an app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3AppsGuidTasksPostRequest
*/
func (a *DefaultAPIService) V3AppsGuidTasksPost(ctx context.Context, guid string) ApiV3AppsGuidTasksPostRequest {
	return ApiV3AppsGuidTasksPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Task
func (a *DefaultAPIService) V3AppsGuidTasksPostExecute(r ApiV3AppsGuidTasksPostRequest) (*Task, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Task
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3AppsGuidTasksPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3AppsGuidTasksPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3AppsGuidTasksPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3AppsGuidTasksPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3DropletsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guids *[]string
	states *[]string
	appGuids *[]string
	spaceGuids *[]string
	organizationGuids *[]string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *time.Time
	updatedAts *time.Time
}

// Comma-delimited list of droplet guids to filter by
func (r ApiV3DropletsGetRequest) Guids(guids []string) ApiV3DropletsGetRequest {
	r.guids = &guids
	return r
}

// Comma-delimited list of droplet states to filter by
func (r ApiV3DropletsGetRequest) States(states []string) ApiV3DropletsGetRequest {
	r.states = &states
	return r
}

// Comma-delimited list of app guids to filter by
func (r ApiV3DropletsGetRequest) AppGuids(appGuids []string) ApiV3DropletsGetRequest {
	r.appGuids = &appGuids
	return r
}

// Comma-delimited list of space guids to filter by
func (r ApiV3DropletsGetRequest) SpaceGuids(spaceGuids []string) ApiV3DropletsGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

// Comma-delimited list of organization guids to filter by
func (r ApiV3DropletsGetRequest) OrganizationGuids(organizationGuids []string) ApiV3DropletsGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

// Page to display
func (r ApiV3DropletsGetRequest) Page(page int32) ApiV3DropletsGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3DropletsGetRequest) PerPage(perPage int32) ApiV3DropletsGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by
func (r ApiV3DropletsGetRequest) OrderBy(orderBy string) ApiV3DropletsGetRequest {
	r.orderBy = &orderBy
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3DropletsGetRequest) LabelSelector(labelSelector string) ApiV3DropletsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Timestamp to filter by
func (r ApiV3DropletsGetRequest) CreatedAts(createdAts time.Time) ApiV3DropletsGetRequest {
	r.createdAts = &createdAts
	return r
}

// Timestamp to filter by
func (r ApiV3DropletsGetRequest) UpdatedAts(updatedAts time.Time) ApiV3DropletsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3DropletsGetRequest) Execute() (*V3AppsGuidDropletsGet200Response, *http.Response, error) {
	return r.ApiService.V3DropletsGetExecute(r)
}

/*
V3DropletsGet List droplets

Retrieve all droplets the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3DropletsGetRequest
*/
func (a *DefaultAPIService) V3DropletsGet(ctx context.Context) ApiV3DropletsGetRequest {
	return ApiV3DropletsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3AppsGuidDropletsGet200Response
func (a *DefaultAPIService) V3DropletsGetExecute(r ApiV3DropletsGetRequest) (*V3AppsGuidDropletsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidDropletsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3DropletsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/droplets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		t := *r.guids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guids", t, "form", "multi")
		}
	}
	if r.states != nil {
		t := *r.states
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "states", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "states", t, "form", "multi")
		}
	}
	if r.appGuids != nil {
		t := *r.appGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "app_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "app_guids", t, "form", "multi")
		}
	}
	if r.spaceGuids != nil {
		t := *r.spaceGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", t, "form", "multi")
		}
	}
	if r.organizationGuids != nil {
		t := *r.organizationGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", t, "form", "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3DropletsGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3DropletsGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3DropletsGuidDeleteExecute(r)
}

/*
V3DropletsGuidDelete Delete a droplet

Delete a specific droplet.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the droplet
 @return ApiV3DropletsGuidDeleteRequest
*/
func (a *DefaultAPIService) V3DropletsGuidDelete(ctx context.Context, guid string) ApiV3DropletsGuidDeleteRequest {
	return ApiV3DropletsGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3DropletsGuidDeleteExecute(r ApiV3DropletsGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3DropletsGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/droplets/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3DropletsGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3DropletsGuidGetRequest) Execute() (*Droplet, *http.Response, error) {
	return r.ApiService.V3DropletsGuidGetExecute(r)
}

/*
V3DropletsGuidGet Get a droplet

Retrieve a specific droplet.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the droplet
 @return ApiV3DropletsGuidGetRequest
*/
func (a *DefaultAPIService) V3DropletsGuidGet(ctx context.Context, guid string) ApiV3DropletsGuidGetRequest {
	return ApiV3DropletsGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Droplet
func (a *DefaultAPIService) V3DropletsGuidGetExecute(r ApiV3DropletsGuidGetRequest) (*Droplet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Droplet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3DropletsGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/droplets/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3DropletsGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3DropletsGuidPatchRequest *V3DropletsGuidPatchRequest
}

func (r ApiV3DropletsGuidPatchRequest) V3DropletsGuidPatchRequest(v3DropletsGuidPatchRequest V3DropletsGuidPatchRequest) ApiV3DropletsGuidPatchRequest {
	r.v3DropletsGuidPatchRequest = &v3DropletsGuidPatchRequest
	return r
}

func (r ApiV3DropletsGuidPatchRequest) Execute() (*Droplet, *http.Response, error) {
	return r.ApiService.V3DropletsGuidPatchExecute(r)
}

/*
V3DropletsGuidPatch Update a droplet

Update the metadata of a droplet.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the droplet
 @return ApiV3DropletsGuidPatchRequest
*/
func (a *DefaultAPIService) V3DropletsGuidPatch(ctx context.Context, guid string) ApiV3DropletsGuidPatchRequest {
	return ApiV3DropletsGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Droplet
func (a *DefaultAPIService) V3DropletsGuidPatchExecute(r ApiV3DropletsGuidPatchRequest) (*Droplet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Droplet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3DropletsGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/droplets/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3DropletsGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3DropletsGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3DropletsGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3DropletsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	v3DropletsPostRequest *V3DropletsPostRequest
	sourceGuid *string
}

func (r ApiV3DropletsPostRequest) V3DropletsPostRequest(v3DropletsPostRequest V3DropletsPostRequest) ApiV3DropletsPostRequest {
	r.v3DropletsPostRequest = &v3DropletsPostRequest
	return r
}

// Source guid of the droplet to be copied (for copy operation)
func (r ApiV3DropletsPostRequest) SourceGuid(sourceGuid string) ApiV3DropletsPostRequest {
	r.sourceGuid = &sourceGuid
	return r
}

func (r ApiV3DropletsPostRequest) Execute() (*Droplet, *http.Response, error) {
	return r.ApiService.V3DropletsPostExecute(r)
}

/*
V3DropletsPost Create or copy a droplet

Create a droplet without a package, or copy a droplet to a different app.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3DropletsPostRequest
*/
func (a *DefaultAPIService) V3DropletsPost(ctx context.Context) ApiV3DropletsPostRequest {
	return ApiV3DropletsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Droplet
func (a *DefaultAPIService) V3DropletsPostExecute(r ApiV3DropletsPostRequest) (*Droplet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Droplet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3DropletsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/droplets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3DropletsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3DropletsPostRequest is required and must be specified")
	}

	if r.sourceGuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source_guid", r.sourceGuid, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3DropletsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3GetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiV3GetRequest) Execute() (*V3Get200Response, *http.Response, error) {
	return r.ApiService.V3GetExecute(r)
}

/*
V3Get V3 API Root

Returns links to all the resources available on the v3 API.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3GetRequest
*/
func (a *DefaultAPIService) V3Get(ctx context.Context) ApiV3GetRequest {
	return ApiV3GetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3Get200Response
func (a *DefaultAPIService) V3GetExecute(r ApiV3GetRequest) (*V3Get200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3Get200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3Get")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3InfoGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiV3InfoGetRequest) Execute() (*PlatformInfo, *http.Response, error) {
	return r.ApiService.V3InfoGetExecute(r)
}

/*
V3InfoGet Get platform info

Retrieve Cloud Controller configuration information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3InfoGetRequest
*/
func (a *DefaultAPIService) V3InfoGet(ctx context.Context) ApiV3InfoGetRequest {
	return ApiV3InfoGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PlatformInfo
func (a *DefaultAPIService) V3InfoGetExecute(r ApiV3InfoGetRequest) (*PlatformInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlatformInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3InfoGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3InfoUsageSummaryGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiV3InfoUsageSummaryGetRequest) Execute() (*UsageSummary, *http.Response, error) {
	return r.ApiService.V3InfoUsageSummaryGetExecute(r)
}

/*
V3InfoUsageSummaryGet Get platform usage summary

Retrieve a high-level summary of usage across the entire Cloud Foundry installation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3InfoUsageSummaryGetRequest
*/
func (a *DefaultAPIService) V3InfoUsageSummaryGet(ctx context.Context) ApiV3InfoUsageSummaryGetRequest {
	return ApiV3InfoUsageSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsageSummary
func (a *DefaultAPIService) V3InfoUsageSummaryGetExecute(r ApiV3InfoUsageSummaryGetRequest) (*UsageSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsageSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3InfoUsageSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/info/usage_summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3IsolationSegmentsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guids *[]string
	names *[]string
	organizationGuids *[]string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *time.Time
	updatedAts *time.Time
}

// Comma-delimited list of isolation segment guids to filter by
func (r ApiV3IsolationSegmentsGetRequest) Guids(guids []string) ApiV3IsolationSegmentsGetRequest {
	r.guids = &guids
	return r
}

// Comma-delimited list of isolation segment names to filter by
func (r ApiV3IsolationSegmentsGetRequest) Names(names []string) ApiV3IsolationSegmentsGetRequest {
	r.names = &names
	return r
}

// Comma-delimited list of organization guids to filter by
func (r ApiV3IsolationSegmentsGetRequest) OrganizationGuids(organizationGuids []string) ApiV3IsolationSegmentsGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

// Page to display
func (r ApiV3IsolationSegmentsGetRequest) Page(page int32) ApiV3IsolationSegmentsGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3IsolationSegmentsGetRequest) PerPage(perPage int32) ApiV3IsolationSegmentsGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by; defaults to ascending. Prepend with - to sort descending
func (r ApiV3IsolationSegmentsGetRequest) OrderBy(orderBy string) ApiV3IsolationSegmentsGetRequest {
	r.orderBy = &orderBy
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3IsolationSegmentsGetRequest) LabelSelector(labelSelector string) ApiV3IsolationSegmentsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Timestamp to filter by
func (r ApiV3IsolationSegmentsGetRequest) CreatedAts(createdAts time.Time) ApiV3IsolationSegmentsGetRequest {
	r.createdAts = &createdAts
	return r
}

// Timestamp to filter by
func (r ApiV3IsolationSegmentsGetRequest) UpdatedAts(updatedAts time.Time) ApiV3IsolationSegmentsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3IsolationSegmentsGetRequest) Execute() (*V3IsolationSegmentsGet200Response, *http.Response, error) {
	return r.ApiService.V3IsolationSegmentsGetExecute(r)
}

/*
V3IsolationSegmentsGet List isolation segments

Retrieve all isolation segments to which the user has access.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3IsolationSegmentsGetRequest
*/
func (a *DefaultAPIService) V3IsolationSegmentsGet(ctx context.Context) ApiV3IsolationSegmentsGetRequest {
	return ApiV3IsolationSegmentsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3IsolationSegmentsGet200Response
func (a *DefaultAPIService) V3IsolationSegmentsGetExecute(r ApiV3IsolationSegmentsGetRequest) (*V3IsolationSegmentsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3IsolationSegmentsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3IsolationSegmentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/isolation_segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		t := *r.guids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guids", t, "form", "multi")
		}
	}
	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.organizationGuids != nil {
		t := *r.organizationGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", t, "form", "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3IsolationSegmentsGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3IsolationSegmentsGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3IsolationSegmentsGuidDeleteExecute(r)
}

/*
V3IsolationSegmentsGuidDelete Delete an isolation segment

Delete an isolation segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the isolation segment
 @return ApiV3IsolationSegmentsGuidDeleteRequest
*/
func (a *DefaultAPIService) V3IsolationSegmentsGuidDelete(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidDeleteRequest {
	return ApiV3IsolationSegmentsGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3IsolationSegmentsGuidDeleteExecute(r ApiV3IsolationSegmentsGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3IsolationSegmentsGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/isolation_segments/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3IsolationSegmentsGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3IsolationSegmentsGuidGetRequest) Execute() (*IsolationSegment, *http.Response, error) {
	return r.ApiService.V3IsolationSegmentsGuidGetExecute(r)
}

/*
V3IsolationSegmentsGuidGet Get an isolation segment

Retrieve an isolation segment to which the user has access.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the isolation segment
 @return ApiV3IsolationSegmentsGuidGetRequest
*/
func (a *DefaultAPIService) V3IsolationSegmentsGuidGet(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidGetRequest {
	return ApiV3IsolationSegmentsGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return IsolationSegment
func (a *DefaultAPIService) V3IsolationSegmentsGuidGetExecute(r ApiV3IsolationSegmentsGuidGetRequest) (*IsolationSegment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IsolationSegment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3IsolationSegmentsGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/isolation_segments/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3IsolationSegmentsGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	isolationSegment *IsolationSegment
}

func (r ApiV3IsolationSegmentsGuidPatchRequest) IsolationSegment(isolationSegment IsolationSegment) ApiV3IsolationSegmentsGuidPatchRequest {
	r.isolationSegment = &isolationSegment
	return r
}

func (r ApiV3IsolationSegmentsGuidPatchRequest) Execute() (*IsolationSegment, *http.Response, error) {
	return r.ApiService.V3IsolationSegmentsGuidPatchExecute(r)
}

/*
V3IsolationSegmentsGuidPatch Update an isolation segment

Update the name or metadata of an isolation segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the isolation segment
 @return ApiV3IsolationSegmentsGuidPatchRequest
*/
func (a *DefaultAPIService) V3IsolationSegmentsGuidPatch(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidPatchRequest {
	return ApiV3IsolationSegmentsGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return IsolationSegment
func (a *DefaultAPIService) V3IsolationSegmentsGuidPatchExecute(r ApiV3IsolationSegmentsGuidPatchRequest) (*IsolationSegment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IsolationSegment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3IsolationSegmentsGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/isolation_segments/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.isolationSegment == nil {
		return localVarReturnValue, nil, reportError("isolationSegment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.isolationSegment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3IsolationSegmentsGuidRelationshipsOrganizationsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsGetRequest) Execute() (*V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response, *http.Response, error) {
	return r.ApiService.V3IsolationSegmentsGuidRelationshipsOrganizationsGetExecute(r)
}

/*
V3IsolationSegmentsGuidRelationshipsOrganizationsGet List organizations relationship

List the organizations entitled for the isolation segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the isolation segment
 @return ApiV3IsolationSegmentsGuidRelationshipsOrganizationsGetRequest
*/
func (a *DefaultAPIService) V3IsolationSegmentsGuidRelationshipsOrganizationsGet(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidRelationshipsOrganizationsGetRequest {
	return ApiV3IsolationSegmentsGuidRelationshipsOrganizationsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response
func (a *DefaultAPIService) V3IsolationSegmentsGuidRelationshipsOrganizationsGetExecute(r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsGetRequest) (*V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3IsolationSegmentsGuidRelationshipsOrganizationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/isolation_segments/{guid}/relationships/organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	orgGuid string
}

func (r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteExecute(r)
}

/*
V3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDelete Revoke entitlement to isolation segment for an organization

Revoke the entitlement for the specified organization to the isolation segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the isolation segment
 @param orgGuid The guid of the organization
 @return ApiV3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteRequest
*/
func (a *DefaultAPIService) V3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDelete(ctx context.Context, guid string, orgGuid string) ApiV3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteRequest {
	return ApiV3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
		orgGuid: orgGuid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteExecute(r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3IsolationSegmentsGuidRelationshipsOrganizationsOrgGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/isolation_segments/{guid}/relationships/organizations/{org_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"org_guid"+"}", url.PathEscape(parameterValueToString(r.orgGuid, "orgGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest *V3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest
}

func (r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest) V3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest(v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest V3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest) ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest {
	r.v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest = &v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest
	return r
}

func (r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest) Execute() (*V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response, *http.Response, error) {
	return r.ApiService.V3IsolationSegmentsGuidRelationshipsOrganizationsPostExecute(r)
}

/*
V3IsolationSegmentsGuidRelationshipsOrganizationsPost Entitle organizations for an isolation segment

Entitle the specified organizations for the isolation segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the isolation segment
 @return ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest
*/
func (a *DefaultAPIService) V3IsolationSegmentsGuidRelationshipsOrganizationsPost(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest {
	return ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response
func (a *DefaultAPIService) V3IsolationSegmentsGuidRelationshipsOrganizationsPostExecute(r ApiV3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest) (*V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3IsolationSegmentsGuidRelationshipsOrganizationsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3IsolationSegmentsGuidRelationshipsOrganizationsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/isolation_segments/{guid}/relationships/organizations"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3IsolationSegmentsGuidRelationshipsOrganizationsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3IsolationSegmentsGuidRelationshipsSpacesGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3IsolationSegmentsGuidRelationshipsSpacesGetRequest) Execute() (*V3IsolationSegmentsGuidRelationshipsSpacesGet200Response, *http.Response, error) {
	return r.ApiService.V3IsolationSegmentsGuidRelationshipsSpacesGetExecute(r)
}

/*
V3IsolationSegmentsGuidRelationshipsSpacesGet List spaces relationship

List the spaces to which the isolation segment is assigned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the isolation segment
 @return ApiV3IsolationSegmentsGuidRelationshipsSpacesGetRequest
*/
func (a *DefaultAPIService) V3IsolationSegmentsGuidRelationshipsSpacesGet(ctx context.Context, guid string) ApiV3IsolationSegmentsGuidRelationshipsSpacesGetRequest {
	return ApiV3IsolationSegmentsGuidRelationshipsSpacesGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3IsolationSegmentsGuidRelationshipsSpacesGet200Response
func (a *DefaultAPIService) V3IsolationSegmentsGuidRelationshipsSpacesGetExecute(r ApiV3IsolationSegmentsGuidRelationshipsSpacesGetRequest) (*V3IsolationSegmentsGuidRelationshipsSpacesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3IsolationSegmentsGuidRelationshipsSpacesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3IsolationSegmentsGuidRelationshipsSpacesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/isolation_segments/{guid}/relationships/spaces"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3IsolationSegmentsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	isolationSegment *IsolationSegment
}

func (r ApiV3IsolationSegmentsPostRequest) IsolationSegment(isolationSegment IsolationSegment) ApiV3IsolationSegmentsPostRequest {
	r.isolationSegment = &isolationSegment
	return r
}

func (r ApiV3IsolationSegmentsPostRequest) Execute() (*IsolationSegment, *http.Response, error) {
	return r.ApiService.V3IsolationSegmentsPostExecute(r)
}

/*
V3IsolationSegmentsPost Create an isolation segment

Create a new isolation segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3IsolationSegmentsPostRequest
*/
func (a *DefaultAPIService) V3IsolationSegmentsPost(ctx context.Context) ApiV3IsolationSegmentsPostRequest {
	return ApiV3IsolationSegmentsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IsolationSegment
func (a *DefaultAPIService) V3IsolationSegmentsPostExecute(r ApiV3IsolationSegmentsPostRequest) (*IsolationSegment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IsolationSegment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3IsolationSegmentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/isolation_segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.isolationSegment == nil {
		return localVarReturnValue, nil, reportError("isolationSegment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.isolationSegment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3PackagesGuidDropletsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	guids *[]string
	states *[]string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
}

// Comma-delimited list of droplet guids to filter by
func (r ApiV3PackagesGuidDropletsGetRequest) Guids(guids []string) ApiV3PackagesGuidDropletsGetRequest {
	r.guids = &guids
	return r
}

// Comma-delimited list of droplet states to filter by
func (r ApiV3PackagesGuidDropletsGetRequest) States(states []string) ApiV3PackagesGuidDropletsGetRequest {
	r.states = &states
	return r
}

// Page to display
func (r ApiV3PackagesGuidDropletsGetRequest) Page(page int32) ApiV3PackagesGuidDropletsGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3PackagesGuidDropletsGetRequest) PerPage(perPage int32) ApiV3PackagesGuidDropletsGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by
func (r ApiV3PackagesGuidDropletsGetRequest) OrderBy(orderBy string) ApiV3PackagesGuidDropletsGetRequest {
	r.orderBy = &orderBy
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3PackagesGuidDropletsGetRequest) LabelSelector(labelSelector string) ApiV3PackagesGuidDropletsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3PackagesGuidDropletsGetRequest) Execute() (*V3AppsGuidDropletsGet200Response, *http.Response, error) {
	return r.ApiService.V3PackagesGuidDropletsGetExecute(r)
}

/*
V3PackagesGuidDropletsGet List droplets for a package

Retrieve a list of droplets belonging to a package.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The guid of the package
 @return ApiV3PackagesGuidDropletsGetRequest
*/
func (a *DefaultAPIService) V3PackagesGuidDropletsGet(ctx context.Context, guid string) ApiV3PackagesGuidDropletsGetRequest {
	return ApiV3PackagesGuidDropletsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidDropletsGet200Response
func (a *DefaultAPIService) V3PackagesGuidDropletsGetExecute(r ApiV3PackagesGuidDropletsGetRequest) (*V3AppsGuidDropletsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidDropletsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3PackagesGuidDropletsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/packages/{guid}/droplets"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		t := *r.guids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guids", t, "form", "multi")
		}
	}
	if r.states != nil {
		t := *r.states
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "states", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "states", t, "form", "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ResourceMatchesPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	resourceMatchRequest *ResourceMatchRequest
}

func (r ApiV3ResourceMatchesPostRequest) ResourceMatchRequest(resourceMatchRequest ResourceMatchRequest) ApiV3ResourceMatchesPostRequest {
	r.resourceMatchRequest = &resourceMatchRequest
	return r
}

func (r ApiV3ResourceMatchesPostRequest) Execute() (*ResourceMatchResponse, *http.Response, error) {
	return r.ApiService.V3ResourceMatchesPostExecute(r)
}

/*
V3ResourceMatchesPost Create a resource match

This endpoint matches given resource SHA-1/file size pairs against the Cloud Controller cache and reports the subset that describes already cached files. This is usually used to avoid uploading duplicate files when pushing an app which has only been partially changed. The path and mode fields are not used when matching.

When uploading package bits, the response from this endpoint should be used as the resources form field. As such, it is useful to include the path and mode fields for each resource even though they are not used when determining a resource match.

Cloud Foundry operators may set minimum/maximum file sizes to match against. If the file size provided is outside this range, it will not be matched against.

If the resource_matching feature flag is disabled, resource matching will always return an empty array.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ResourceMatchesPostRequest
*/
func (a *DefaultAPIService) V3ResourceMatchesPost(ctx context.Context) ApiV3ResourceMatchesPostRequest {
	return ApiV3ResourceMatchesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResourceMatchResponse
func (a *DefaultAPIService) V3ResourceMatchesPostExecute(r ApiV3ResourceMatchesPostRequest) (*ResourceMatchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResourceMatchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ResourceMatchesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/resource_matches"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.resourceMatchRequest == nil {
		return localVarReturnValue, nil, reportError("resourceMatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resourceMatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3RevisionsGuidEnvironmentVariablesGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3RevisionsGuidEnvironmentVariablesGetRequest) Execute() (*EnvironmentVariables, *http.Response, error) {
	return r.ApiService.V3RevisionsGuidEnvironmentVariablesGetExecute(r)
}

/*
V3RevisionsGuidEnvironmentVariablesGet Get environment variables for a revision

Retrieve the environment variables associated with the revision.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid Unique identifier for the revision
 @return ApiV3RevisionsGuidEnvironmentVariablesGetRequest
*/
func (a *DefaultAPIService) V3RevisionsGuidEnvironmentVariablesGet(ctx context.Context, guid string) ApiV3RevisionsGuidEnvironmentVariablesGetRequest {
	return ApiV3RevisionsGuidEnvironmentVariablesGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return EnvironmentVariables
func (a *DefaultAPIService) V3RevisionsGuidEnvironmentVariablesGetExecute(r ApiV3RevisionsGuidEnvironmentVariablesGetRequest) (*EnvironmentVariables, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvironmentVariables
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3RevisionsGuidEnvironmentVariablesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/revisions/{guid}/environment_variables"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3RevisionsGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3RevisionsGuidGetRequest) Execute() (*Revision, *http.Response, error) {
	return r.ApiService.V3RevisionsGuidGetExecute(r)
}

/*
V3RevisionsGuidGet Get a revision

Retrieve a specific revision.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid Unique identifier for the revision
 @return ApiV3RevisionsGuidGetRequest
*/
func (a *DefaultAPIService) V3RevisionsGuidGet(ctx context.Context, guid string) ApiV3RevisionsGuidGetRequest {
	return ApiV3RevisionsGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Revision
func (a *DefaultAPIService) V3RevisionsGuidGetExecute(r ApiV3RevisionsGuidGetRequest) (*Revision, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Revision
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3RevisionsGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/revisions/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3RevisionsGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3DeploymentsGuidPatchRequest *V3DeploymentsGuidPatchRequest
}

func (r ApiV3RevisionsGuidPatchRequest) V3DeploymentsGuidPatchRequest(v3DeploymentsGuidPatchRequest V3DeploymentsGuidPatchRequest) ApiV3RevisionsGuidPatchRequest {
	r.v3DeploymentsGuidPatchRequest = &v3DeploymentsGuidPatchRequest
	return r
}

func (r ApiV3RevisionsGuidPatchRequest) Execute() (*Revision, *http.Response, error) {
	return r.ApiService.V3RevisionsGuidPatchExecute(r)
}

/*
V3RevisionsGuidPatch Update a revision

Update metadata for a specific revision.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid Unique identifier for the revision
 @return ApiV3RevisionsGuidPatchRequest
*/
func (a *DefaultAPIService) V3RevisionsGuidPatch(ctx context.Context, guid string) ApiV3RevisionsGuidPatchRequest {
	return ApiV3RevisionsGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Revision
func (a *DefaultAPIService) V3RevisionsGuidPatchExecute(r ApiV3RevisionsGuidPatchRequest) (*Revision, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Revision
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3RevisionsGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/revisions/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3DeploymentsGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceBrokersGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	names *[]string
	spaceGuids *[]string
	orderBy *string
	page *int32
	perPage *int32
	labelSelector *string
	createdAts *string
	updatedAts *string
}

// Comma-delimited list of service broker names to filter by
func (r ApiV3ServiceBrokersGetRequest) Names(names []string) ApiV3ServiceBrokersGetRequest {
	r.names = &names
	return r
}

// Comma-delimited list of space GUIDs to filter by
func (r ApiV3ServiceBrokersGetRequest) SpaceGuids(spaceGuids []string) ApiV3ServiceBrokersGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

// Value to sort by
func (r ApiV3ServiceBrokersGetRequest) OrderBy(orderBy string) ApiV3ServiceBrokersGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3ServiceBrokersGetRequest) Page(page int32) ApiV3ServiceBrokersGetRequest {
	r.page = &page
	return r
}

func (r ApiV3ServiceBrokersGetRequest) PerPage(perPage int32) ApiV3ServiceBrokersGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3ServiceBrokersGetRequest) LabelSelector(labelSelector string) ApiV3ServiceBrokersGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3ServiceBrokersGetRequest) CreatedAts(createdAts string) ApiV3ServiceBrokersGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3ServiceBrokersGetRequest) UpdatedAts(updatedAts string) ApiV3ServiceBrokersGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3ServiceBrokersGetRequest) Execute() (*V3ServiceBrokersGet200Response, *http.Response, error) {
	return r.ApiService.V3ServiceBrokersGetExecute(r)
}

/*
V3ServiceBrokersGet List service brokers

Retrieves the service brokers the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceBrokersGetRequest
*/
func (a *DefaultAPIService) V3ServiceBrokersGet(ctx context.Context) ApiV3ServiceBrokersGetRequest {
	return ApiV3ServiceBrokersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3ServiceBrokersGet200Response
func (a *DefaultAPIService) V3ServiceBrokersGetExecute(r ApiV3ServiceBrokersGetRequest) (*V3ServiceBrokersGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3ServiceBrokersGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceBrokersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_brokers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.spaceGuids != nil {
		t := *r.spaceGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", t, "form", "multi")
		}
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceBrokersGuidCatalogPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceBrokersGuidCatalogPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3ServiceBrokersGuidCatalogPostExecute(r)
}

/*
V3ServiceBrokersGuidCatalogPost Sync service broker catalog

Triggers a synchronization of the service broker's catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceBrokersGuidCatalogPostRequest
*/
func (a *DefaultAPIService) V3ServiceBrokersGuidCatalogPost(ctx context.Context, guid string) ApiV3ServiceBrokersGuidCatalogPostRequest {
	return ApiV3ServiceBrokersGuidCatalogPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3ServiceBrokersGuidCatalogPostExecute(r ApiV3ServiceBrokersGuidCatalogPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceBrokersGuidCatalogPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_brokers/{guid}/catalog"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3ServiceBrokersGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceBrokersGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3ServiceBrokersGuidDeleteExecute(r)
}

/*
V3ServiceBrokersGuidDelete Delete a service broker

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceBrokersGuidDeleteRequest
*/
func (a *DefaultAPIService) V3ServiceBrokersGuidDelete(ctx context.Context, guid string) ApiV3ServiceBrokersGuidDeleteRequest {
	return ApiV3ServiceBrokersGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3ServiceBrokersGuidDeleteExecute(r ApiV3ServiceBrokersGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceBrokersGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_brokers/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3ServiceBrokersGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceBrokersGuidGetRequest) Execute() (*ServiceBroker, *http.Response, error) {
	return r.ApiService.V3ServiceBrokersGuidGetExecute(r)
}

/*
V3ServiceBrokersGuidGet Get a service broker

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceBrokersGuidGetRequest
*/
func (a *DefaultAPIService) V3ServiceBrokersGuidGet(ctx context.Context, guid string) ApiV3ServiceBrokersGuidGetRequest {
	return ApiV3ServiceBrokersGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceBroker
func (a *DefaultAPIService) V3ServiceBrokersGuidGetExecute(r ApiV3ServiceBrokersGuidGetRequest) (*ServiceBroker, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceBroker
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceBrokersGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_brokers/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceBrokersGuidJobsSynchronizationGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceBrokersGuidJobsSynchronizationGetRequest) Execute() (*LastOperation, *http.Response, error) {
	return r.ApiService.V3ServiceBrokersGuidJobsSynchronizationGetExecute(r)
}

/*
V3ServiceBrokersGuidJobsSynchronizationGet Get broker synchronization job status

Retrieves status of the last catalog synchronization job

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceBrokersGuidJobsSynchronizationGetRequest
*/
func (a *DefaultAPIService) V3ServiceBrokersGuidJobsSynchronizationGet(ctx context.Context, guid string) ApiV3ServiceBrokersGuidJobsSynchronizationGetRequest {
	return ApiV3ServiceBrokersGuidJobsSynchronizationGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return LastOperation
func (a *DefaultAPIService) V3ServiceBrokersGuidJobsSynchronizationGetExecute(r ApiV3ServiceBrokersGuidJobsSynchronizationGetRequest) (*LastOperation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LastOperation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceBrokersGuidJobsSynchronizationGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_brokers/{guid}/jobs/synchronization"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceBrokersGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3ServiceBrokersGuidPatchRequest *V3ServiceBrokersGuidPatchRequest
}

func (r ApiV3ServiceBrokersGuidPatchRequest) V3ServiceBrokersGuidPatchRequest(v3ServiceBrokersGuidPatchRequest V3ServiceBrokersGuidPatchRequest) ApiV3ServiceBrokersGuidPatchRequest {
	r.v3ServiceBrokersGuidPatchRequest = &v3ServiceBrokersGuidPatchRequest
	return r
}

func (r ApiV3ServiceBrokersGuidPatchRequest) Execute() (*ServiceBroker, *http.Response, error) {
	return r.ApiService.V3ServiceBrokersGuidPatchExecute(r)
}

/*
V3ServiceBrokersGuidPatch Update a service broker

Updates a service broker. May trigger catalog sync based on fields updated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceBrokersGuidPatchRequest
*/
func (a *DefaultAPIService) V3ServiceBrokersGuidPatch(ctx context.Context, guid string) ApiV3ServiceBrokersGuidPatchRequest {
	return ApiV3ServiceBrokersGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceBroker
func (a *DefaultAPIService) V3ServiceBrokersGuidPatchExecute(r ApiV3ServiceBrokersGuidPatchRequest) (*ServiceBroker, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceBroker
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceBrokersGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_brokers/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3ServiceBrokersGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3ServiceBrokersGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3ServiceBrokersGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceBrokersPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	v3ServiceBrokersPostRequest *V3ServiceBrokersPostRequest
}

func (r ApiV3ServiceBrokersPostRequest) V3ServiceBrokersPostRequest(v3ServiceBrokersPostRequest V3ServiceBrokersPostRequest) ApiV3ServiceBrokersPostRequest {
	r.v3ServiceBrokersPostRequest = &v3ServiceBrokersPostRequest
	return r
}

func (r ApiV3ServiceBrokersPostRequest) Execute() (*ServiceBroker, *http.Response, error) {
	return r.ApiService.V3ServiceBrokersPostExecute(r)
}

/*
V3ServiceBrokersPost Create a service broker

Creates a new service broker and syncs with catalog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceBrokersPostRequest
*/
func (a *DefaultAPIService) V3ServiceBrokersPost(ctx context.Context) ApiV3ServiceBrokersPostRequest {
	return ApiV3ServiceBrokersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceBroker
func (a *DefaultAPIService) V3ServiceBrokersPostExecute(r ApiV3ServiceBrokersPostRequest) (*ServiceBroker, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceBroker
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceBrokersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_brokers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3ServiceBrokersPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3ServiceBrokersPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3ServiceBrokersPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceCredentialBindingsGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceCredentialBindingsGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3ServiceCredentialBindingsGuidDeleteExecute(r)
}

/*
V3ServiceCredentialBindingsGuidDelete Delete a service credential binding

This endpoint deletes a service credential binding.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceCredentialBindingsGuidDeleteRequest
*/
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidDelete(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidDeleteRequest {
	return ApiV3ServiceCredentialBindingsGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidDeleteExecute(r ApiV3ServiceCredentialBindingsGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceCredentialBindingsGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_credential_bindings/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3ServiceCredentialBindingsGuidDetailsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceCredentialBindingsGuidDetailsGetRequest) Execute() (*V3ServiceCredentialBindingsGuidDetailsGet200Response, *http.Response, error) {
	return r.ApiService.V3ServiceCredentialBindingsGuidDetailsGetExecute(r)
}

/*
V3ServiceCredentialBindingsGuidDetailsGet Get a service credential binding details

This endpoint retrieves the service credential binding details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceCredentialBindingsGuidDetailsGetRequest
*/
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidDetailsGet(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidDetailsGetRequest {
	return ApiV3ServiceCredentialBindingsGuidDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3ServiceCredentialBindingsGuidDetailsGet200Response
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidDetailsGetExecute(r ApiV3ServiceCredentialBindingsGuidDetailsGetRequest) (*V3ServiceCredentialBindingsGuidDetailsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3ServiceCredentialBindingsGuidDetailsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceCredentialBindingsGuidDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_credential_bindings/{guid}/details"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceCredentialBindingsGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	include *[]string
}

func (r ApiV3ServiceCredentialBindingsGuidGetRequest) Include(include []string) ApiV3ServiceCredentialBindingsGuidGetRequest {
	r.include = &include
	return r
}

func (r ApiV3ServiceCredentialBindingsGuidGetRequest) Execute() (*ServiceCredentialBinding, *http.Response, error) {
	return r.ApiService.V3ServiceCredentialBindingsGuidGetExecute(r)
}

/*
V3ServiceCredentialBindingsGuidGet Get a service credential binding

This endpoint retrieves the service credential binding by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceCredentialBindingsGuidGetRequest
*/
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidGet(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidGetRequest {
	return ApiV3ServiceCredentialBindingsGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceCredentialBinding
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidGetExecute(r ApiV3ServiceCredentialBindingsGuidGetRequest) (*ServiceCredentialBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceCredentialBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceCredentialBindingsGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_credential_bindings/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		t := *r.include
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "include", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "include", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceCredentialBindingsGuidParametersGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceCredentialBindingsGuidParametersGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V3ServiceCredentialBindingsGuidParametersGetExecute(r)
}

/*
V3ServiceCredentialBindingsGuidParametersGet Get parameters for a service credential binding

Queries the Service Broker for the parameters associated with this service credential binding.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceCredentialBindingsGuidParametersGetRequest
*/
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidParametersGet(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidParametersGetRequest {
	return ApiV3ServiceCredentialBindingsGuidParametersGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidParametersGetExecute(r ApiV3ServiceCredentialBindingsGuidParametersGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceCredentialBindingsGuidParametersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_credential_bindings/{guid}/parameters"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceCredentialBindingsGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3DropletsGuidPatchRequest *V3DropletsGuidPatchRequest
}

func (r ApiV3ServiceCredentialBindingsGuidPatchRequest) V3DropletsGuidPatchRequest(v3DropletsGuidPatchRequest V3DropletsGuidPatchRequest) ApiV3ServiceCredentialBindingsGuidPatchRequest {
	r.v3DropletsGuidPatchRequest = &v3DropletsGuidPatchRequest
	return r
}

func (r ApiV3ServiceCredentialBindingsGuidPatchRequest) Execute() (*ServiceCredentialBinding, *http.Response, error) {
	return r.ApiService.V3ServiceCredentialBindingsGuidPatchExecute(r)
}

/*
V3ServiceCredentialBindingsGuidPatch Update a service credential binding

This endpoint updates a service credential binding with labels and annotations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceCredentialBindingsGuidPatchRequest
*/
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidPatch(ctx context.Context, guid string) ApiV3ServiceCredentialBindingsGuidPatchRequest {
	return ApiV3ServiceCredentialBindingsGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceCredentialBinding
func (a *DefaultAPIService) V3ServiceCredentialBindingsGuidPatchExecute(r ApiV3ServiceCredentialBindingsGuidPatchRequest) (*ServiceCredentialBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceCredentialBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceCredentialBindingsGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_credential_bindings/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3DropletsGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3DropletsGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3DropletsGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceCredentialBindingsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	v3ServiceCredentialBindingsPostRequest *V3ServiceCredentialBindingsPostRequest
}

func (r ApiV3ServiceCredentialBindingsPostRequest) V3ServiceCredentialBindingsPostRequest(v3ServiceCredentialBindingsPostRequest V3ServiceCredentialBindingsPostRequest) ApiV3ServiceCredentialBindingsPostRequest {
	r.v3ServiceCredentialBindingsPostRequest = &v3ServiceCredentialBindingsPostRequest
	return r
}

func (r ApiV3ServiceCredentialBindingsPostRequest) Execute() (*ServiceCredentialBinding, *http.Response, error) {
	return r.ApiService.V3ServiceCredentialBindingsPostExecute(r)
}

/*
V3ServiceCredentialBindingsPost Create a service credential binding

This endpoint creates a new service credential binding. Service credential bindings can be of type app or key; key is only valid for managed service instances.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceCredentialBindingsPostRequest
*/
func (a *DefaultAPIService) V3ServiceCredentialBindingsPost(ctx context.Context) ApiV3ServiceCredentialBindingsPostRequest {
	return ApiV3ServiceCredentialBindingsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceCredentialBinding
func (a *DefaultAPIService) V3ServiceCredentialBindingsPostExecute(r ApiV3ServiceCredentialBindingsPostRequest) (*ServiceCredentialBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceCredentialBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceCredentialBindingsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_credential_bindings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3ServiceCredentialBindingsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3ServiceCredentialBindingsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3ServiceCredentialBindingsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceInstancesGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	names *[]string
	guids *[]string
	type_ *string
	spaceGuids *[]string
	organizationGuids *[]string
	servicePlanGuids *[]string
	servicePlanNames *[]string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *[]time.Time
	updatedAts *[]time.Time
}

// Comma-delimited list of service instance names to filter by
func (r ApiV3ServiceInstancesGetRequest) Names(names []string) ApiV3ServiceInstancesGetRequest {
	r.names = &names
	return r
}

// Comma-delimited list of service instance guids to filter by
func (r ApiV3ServiceInstancesGetRequest) Guids(guids []string) ApiV3ServiceInstancesGetRequest {
	r.guids = &guids
	return r
}

// Filter by type
func (r ApiV3ServiceInstancesGetRequest) Type_(type_ string) ApiV3ServiceInstancesGetRequest {
	r.type_ = &type_
	return r
}

// Comma-delimited list of space guids to filter by
func (r ApiV3ServiceInstancesGetRequest) SpaceGuids(spaceGuids []string) ApiV3ServiceInstancesGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

// Comma-delimited list of organization guids to filter by
func (r ApiV3ServiceInstancesGetRequest) OrganizationGuids(organizationGuids []string) ApiV3ServiceInstancesGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

// Comma-delimited list of service plan guids to filter by
func (r ApiV3ServiceInstancesGetRequest) ServicePlanGuids(servicePlanGuids []string) ApiV3ServiceInstancesGetRequest {
	r.servicePlanGuids = &servicePlanGuids
	return r
}

// Comma-delimited list of service plan names to filter by
func (r ApiV3ServiceInstancesGetRequest) ServicePlanNames(servicePlanNames []string) ApiV3ServiceInstancesGetRequest {
	r.servicePlanNames = &servicePlanNames
	return r
}

// Page to display
func (r ApiV3ServiceInstancesGetRequest) Page(page int32) ApiV3ServiceInstancesGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3ServiceInstancesGetRequest) PerPage(perPage int32) ApiV3ServiceInstancesGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by
func (r ApiV3ServiceInstancesGetRequest) OrderBy(orderBy string) ApiV3ServiceInstancesGetRequest {
	r.orderBy = &orderBy
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3ServiceInstancesGetRequest) LabelSelector(labelSelector string) ApiV3ServiceInstancesGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Timestamp to filter by
func (r ApiV3ServiceInstancesGetRequest) CreatedAts(createdAts []time.Time) ApiV3ServiceInstancesGetRequest {
	r.createdAts = &createdAts
	return r
}

// Timestamp to filter by
func (r ApiV3ServiceInstancesGetRequest) UpdatedAts(updatedAts []time.Time) ApiV3ServiceInstancesGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3ServiceInstancesGetRequest) Execute() (*V3ServiceInstancesGet200Response, *http.Response, error) {
	return r.ApiService.V3ServiceInstancesGetExecute(r)
}

/*
V3ServiceInstancesGet Retrieve service instances

Retrieves the service instances the user has access to, including access granted by service instance sharing.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceInstancesGetRequest
*/
func (a *DefaultAPIService) V3ServiceInstancesGet(ctx context.Context) ApiV3ServiceInstancesGetRequest {
	return ApiV3ServiceInstancesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3ServiceInstancesGet200Response
func (a *DefaultAPIService) V3ServiceInstancesGetExecute(r ApiV3ServiceInstancesGetRequest) (*V3ServiceInstancesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3ServiceInstancesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceInstancesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.guids != nil {
		t := *r.guids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "guids", t, "form", "multi")
		}
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.spaceGuids != nil {
		t := *r.spaceGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", t, "form", "multi")
		}
	}
	if r.organizationGuids != nil {
		t := *r.organizationGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", t, "form", "multi")
		}
	}
	if r.servicePlanGuids != nil {
		t := *r.servicePlanGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_plan_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_plan_guids", t, "form", "multi")
		}
	}
	if r.servicePlanNames != nil {
		t := *r.servicePlanNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_plan_names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_plan_names", t, "form", "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		t := *r.createdAts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", t, "form", "multi")
		}
	}
	if r.updatedAts != nil {
		t := *r.updatedAts
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceInstancesGuidCredentialsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceInstancesGuidCredentialsGetRequest) Execute() (map[string]string, *http.Response, error) {
	return r.ApiService.V3ServiceInstancesGuidCredentialsGetExecute(r)
}

/*
V3ServiceInstancesGuidCredentialsGet Get credentials for a user-provided service instance

Retrieves the credentials for a user-provided service instance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid GUID of the service instance
 @return ApiV3ServiceInstancesGuidCredentialsGetRequest
*/
func (a *DefaultAPIService) V3ServiceInstancesGuidCredentialsGet(ctx context.Context, guid string) ApiV3ServiceInstancesGuidCredentialsGetRequest {
	return ApiV3ServiceInstancesGuidCredentialsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return map[string]string
func (a *DefaultAPIService) V3ServiceInstancesGuidCredentialsGetExecute(r ApiV3ServiceInstancesGuidCredentialsGetRequest) (map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceInstancesGuidCredentialsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_instances/{guid}/credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceInstancesGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	purge *bool
}

// If true, deletes the service instance and all associated resources without any interaction with the service broker
func (r ApiV3ServiceInstancesGuidDeleteRequest) Purge(purge bool) ApiV3ServiceInstancesGuidDeleteRequest {
	r.purge = &purge
	return r
}

func (r ApiV3ServiceInstancesGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3ServiceInstancesGuidDeleteExecute(r)
}

/*
V3ServiceInstancesGuidDelete Delete a service instance

Deletes a service instance and any associated service credential bindings or service route bindings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid GUID of the service instance
 @return ApiV3ServiceInstancesGuidDeleteRequest
*/
func (a *DefaultAPIService) V3ServiceInstancesGuidDelete(ctx context.Context, guid string) ApiV3ServiceInstancesGuidDeleteRequest {
	return ApiV3ServiceInstancesGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3ServiceInstancesGuidDeleteExecute(r ApiV3ServiceInstancesGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceInstancesGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_instances/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.purge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purge", r.purge, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3ServiceInstancesGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3ServiceInstancesGuidPatchRequest *V3ServiceInstancesGuidPatchRequest
}

func (r ApiV3ServiceInstancesGuidPatchRequest) V3ServiceInstancesGuidPatchRequest(v3ServiceInstancesGuidPatchRequest V3ServiceInstancesGuidPatchRequest) ApiV3ServiceInstancesGuidPatchRequest {
	r.v3ServiceInstancesGuidPatchRequest = &v3ServiceInstancesGuidPatchRequest
	return r
}

func (r ApiV3ServiceInstancesGuidPatchRequest) Execute() (*ServiceInstance, *http.Response, error) {
	return r.ApiService.V3ServiceInstancesGuidPatchExecute(r)
}

/*
V3ServiceInstancesGuidPatch Update a service instance

Updates a service instance with the provided attributes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid GUID of the service instance
 @return ApiV3ServiceInstancesGuidPatchRequest
*/
func (a *DefaultAPIService) V3ServiceInstancesGuidPatch(ctx context.Context, guid string) ApiV3ServiceInstancesGuidPatchRequest {
	return ApiV3ServiceInstancesGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceInstance
func (a *DefaultAPIService) V3ServiceInstancesGuidPatchExecute(r ApiV3ServiceInstancesGuidPatchRequest) (*ServiceInstance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceInstancesGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_instances/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3ServiceInstancesGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3ServiceInstancesGuidRelationshipsSharedSpacesGet200Response *V3ServiceInstancesGuidRelationshipsSharedSpacesGet200Response
}

func (r ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest) V3ServiceInstancesGuidRelationshipsSharedSpacesGet200Response(v3ServiceInstancesGuidRelationshipsSharedSpacesGet200Response V3ServiceInstancesGuidRelationshipsSharedSpacesGet200Response) ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest {
	r.v3ServiceInstancesGuidRelationshipsSharedSpacesGet200Response = &v3ServiceInstancesGuidRelationshipsSharedSpacesGet200Response
	return r
}

func (r ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest) Execute() (*V3ServiceInstancesGuidRelationshipsSharedSpacesGet200Response, *http.Response, error) {
	return r.ApiService.V3ServiceInstancesGuidRelationshipsSharedSpacesPostExecute(r)
}

/*
V3ServiceInstancesGuidRelationshipsSharedSpacesPost Share a service instance to other spaces

Shares the service instance with the specified spaces.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid GUID of the service instance
 @return ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest
*/
func (a *DefaultAPIService) V3ServiceInstancesGuidRelationshipsSharedSpacesPost(ctx context.Context, guid string) ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest {
	return ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3ServiceInstancesGuidRelationshipsSharedSpacesGet200Response
func (a *DefaultAPIService) V3ServiceInstancesGuidRelationshipsSharedSpacesPostExecute(r ApiV3ServiceInstancesGuidRelationshipsSharedSpacesPostRequest) (*V3ServiceInstancesGuidRelationshipsSharedSpacesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3ServiceInstancesGuidRelationshipsSharedSpacesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceInstancesGuidRelationshipsSharedSpacesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_instances/{guid}/relationships/shared_spaces"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3ServiceInstancesGuidRelationshipsSharedSpacesGet200Response
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	spaceGuid string
}

func (r ApiV3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteExecute(r)
}

/*
V3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDelete Unshare a service instance from another space

Unshares the service instance from the specified space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid GUID of the service instance
 @param spaceGuid GUID of the space
 @return ApiV3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteRequest
*/
func (a *DefaultAPIService) V3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDelete(ctx context.Context, guid string, spaceGuid string) ApiV3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteRequest {
	return ApiV3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
		spaceGuid: spaceGuid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteExecute(r ApiV3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceInstancesGuidRelationshipsSharedSpacesSpaceGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_instances/{guid}/relationships/shared_spaces/{space_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"space_guid"+"}", url.PathEscape(parameterValueToString(r.spaceGuid, "spaceGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3ServiceOfferingsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	names *[]string
	available *bool
	serviceBrokerGuids *[]string
	serviceBrokerNames *[]string
	spaceGuids *[]string
	organizationGuids *[]string
	labelSelector *string
	orderBy *string
	page *int32
	perPage *int32
	createdAts *string
	updatedAts *string
}

// Comma-delimited list of names to filter by
func (r ApiV3ServiceOfferingsGetRequest) Names(names []string) ApiV3ServiceOfferingsGetRequest {
	r.names = &names
	return r
}

// Filter by the available property; valid values are true or false
func (r ApiV3ServiceOfferingsGetRequest) Available(available bool) ApiV3ServiceOfferingsGetRequest {
	r.available = &available
	return r
}

// Comma-delimited list of service broker GUIDs to filter by
func (r ApiV3ServiceOfferingsGetRequest) ServiceBrokerGuids(serviceBrokerGuids []string) ApiV3ServiceOfferingsGetRequest {
	r.serviceBrokerGuids = &serviceBrokerGuids
	return r
}

// Comma-delimited list of service broker names to filter by
func (r ApiV3ServiceOfferingsGetRequest) ServiceBrokerNames(serviceBrokerNames []string) ApiV3ServiceOfferingsGetRequest {
	r.serviceBrokerNames = &serviceBrokerNames
	return r
}

// Comma-delimited list of space GUIDs to filter by
func (r ApiV3ServiceOfferingsGetRequest) SpaceGuids(spaceGuids []string) ApiV3ServiceOfferingsGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

// Comma-delimited list of organization GUIDs to filter by
func (r ApiV3ServiceOfferingsGetRequest) OrganizationGuids(organizationGuids []string) ApiV3ServiceOfferingsGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3ServiceOfferingsGetRequest) LabelSelector(labelSelector string) ApiV3ServiceOfferingsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Value to sort by. Defaults to ascending; prepend with - to sort descending. Valid values are created_at, updated_at, name
func (r ApiV3ServiceOfferingsGetRequest) OrderBy(orderBy string) ApiV3ServiceOfferingsGetRequest {
	r.orderBy = &orderBy
	return r
}

// Page to display; valid values are integers &gt;&#x3D; 1
func (r ApiV3ServiceOfferingsGetRequest) Page(page int32) ApiV3ServiceOfferingsGetRequest {
	r.page = &page
	return r
}

// Number of results per page; valid values are 1 through 5000
func (r ApiV3ServiceOfferingsGetRequest) PerPage(perPage int32) ApiV3ServiceOfferingsGetRequest {
	r.perPage = &perPage
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3ServiceOfferingsGetRequest) CreatedAts(createdAts string) ApiV3ServiceOfferingsGetRequest {
	r.createdAts = &createdAts
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3ServiceOfferingsGetRequest) UpdatedAts(updatedAts string) ApiV3ServiceOfferingsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3ServiceOfferingsGetRequest) Execute() (*ServiceOfferingList, *http.Response, error) {
	return r.ApiService.V3ServiceOfferingsGetExecute(r)
}

/*
V3ServiceOfferingsGet List service offerings

Retrieves the service offerings the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceOfferingsGetRequest
*/
func (a *DefaultAPIService) V3ServiceOfferingsGet(ctx context.Context) ApiV3ServiceOfferingsGetRequest {
	return ApiV3ServiceOfferingsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceOfferingList
func (a *DefaultAPIService) V3ServiceOfferingsGetExecute(r ApiV3ServiceOfferingsGetRequest) (*ServiceOfferingList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceOfferingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceOfferingsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_offerings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.available != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "available", r.available, "form", "")
	}
	if r.serviceBrokerGuids != nil {
		t := *r.serviceBrokerGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_broker_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_broker_guids", t, "form", "multi")
		}
	}
	if r.serviceBrokerNames != nil {
		t := *r.serviceBrokerNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_broker_names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_broker_names", t, "form", "multi")
		}
	}
	if r.spaceGuids != nil {
		t := *r.spaceGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", t, "form", "multi")
		}
	}
	if r.organizationGuids != nil {
		t := *r.organizationGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", t, "form", "multi")
		}
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceOfferingsGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	purge *bool
}

// If true, any service plans, instances, and bindings associated with this service offering will also be deleted
func (r ApiV3ServiceOfferingsGuidDeleteRequest) Purge(purge bool) ApiV3ServiceOfferingsGuidDeleteRequest {
	r.purge = &purge
	return r
}

func (r ApiV3ServiceOfferingsGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3ServiceOfferingsGuidDeleteExecute(r)
}

/*
V3ServiceOfferingsGuidDelete Delete a service offering

Deletes a service offering.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The service offering GUID
 @return ApiV3ServiceOfferingsGuidDeleteRequest
*/
func (a *DefaultAPIService) V3ServiceOfferingsGuidDelete(ctx context.Context, guid string) ApiV3ServiceOfferingsGuidDeleteRequest {
	return ApiV3ServiceOfferingsGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3ServiceOfferingsGuidDeleteExecute(r ApiV3ServiceOfferingsGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceOfferingsGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_offerings/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.purge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purge", r.purge, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3ServiceOfferingsGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceOfferingsGuidGetRequest) Execute() (*ServiceOffering, *http.Response, error) {
	return r.ApiService.V3ServiceOfferingsGuidGetExecute(r)
}

/*
V3ServiceOfferingsGuidGet Get a service offering

Retrieves the service offering by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The service offering GUID
 @return ApiV3ServiceOfferingsGuidGetRequest
*/
func (a *DefaultAPIService) V3ServiceOfferingsGuidGet(ctx context.Context, guid string) ApiV3ServiceOfferingsGuidGetRequest {
	return ApiV3ServiceOfferingsGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceOffering
func (a *DefaultAPIService) V3ServiceOfferingsGuidGetExecute(r ApiV3ServiceOfferingsGuidGetRequest) (*ServiceOffering, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceOffering
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceOfferingsGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_offerings/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceOfferingsGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	serviceOfferingUpdate *ServiceOfferingUpdate
}

func (r ApiV3ServiceOfferingsGuidPatchRequest) ServiceOfferingUpdate(serviceOfferingUpdate ServiceOfferingUpdate) ApiV3ServiceOfferingsGuidPatchRequest {
	r.serviceOfferingUpdate = &serviceOfferingUpdate
	return r
}

func (r ApiV3ServiceOfferingsGuidPatchRequest) Execute() (*ServiceOffering, *http.Response, error) {
	return r.ApiService.V3ServiceOfferingsGuidPatchExecute(r)
}

/*
V3ServiceOfferingsGuidPatch Update a service offering

Updates a service offering.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The service offering GUID
 @return ApiV3ServiceOfferingsGuidPatchRequest
*/
func (a *DefaultAPIService) V3ServiceOfferingsGuidPatch(ctx context.Context, guid string) ApiV3ServiceOfferingsGuidPatchRequest {
	return ApiV3ServiceOfferingsGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceOffering
func (a *DefaultAPIService) V3ServiceOfferingsGuidPatchExecute(r ApiV3ServiceOfferingsGuidPatchRequest) (*ServiceOffering, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceOffering
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceOfferingsGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_offerings/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceOfferingUpdate == nil {
		return localVarReturnValue, nil, reportError("serviceOfferingUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serviceOfferingUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceOfferingsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	serviceOfferingCreate *ServiceOfferingCreate
}

func (r ApiV3ServiceOfferingsPostRequest) ServiceOfferingCreate(serviceOfferingCreate ServiceOfferingCreate) ApiV3ServiceOfferingsPostRequest {
	r.serviceOfferingCreate = &serviceOfferingCreate
	return r
}

func (r ApiV3ServiceOfferingsPostRequest) Execute() (*ServiceOffering, *http.Response, error) {
	return r.ApiService.V3ServiceOfferingsPostExecute(r)
}

/*
V3ServiceOfferingsPost Create a service offering

Creates a new service offering.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceOfferingsPostRequest
*/
func (a *DefaultAPIService) V3ServiceOfferingsPost(ctx context.Context) ApiV3ServiceOfferingsPostRequest {
	return ApiV3ServiceOfferingsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceOffering
func (a *DefaultAPIService) V3ServiceOfferingsPostExecute(r ApiV3ServiceOfferingsPostRequest) (*ServiceOffering, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceOffering
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceOfferingsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_offerings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.serviceOfferingCreate == nil {
		return localVarReturnValue, nil, reportError("serviceOfferingCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.serviceOfferingCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServicePlansGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	names *[]string
	available *bool
	brokerCatalogIds *[]string
	spaceGuids *[]string
	organizationGuids *[]string
	serviceBrokerGuids *[]string
	serviceBrokerNames *[]string
	serviceOfferingGuids *[]string
	serviceOfferingNames *[]string
	serviceInstanceGuids *[]string
	include *[]string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	fields *string
	createdAts *string
	updatedAts *string
}

// Comma-delimited list of names to filter by
func (r ApiV3ServicePlansGetRequest) Names(names []string) ApiV3ServicePlansGetRequest {
	r.names = &names
	return r
}

// Filter by the available property; valid values are true or false
func (r ApiV3ServicePlansGetRequest) Available(available bool) ApiV3ServicePlansGetRequest {
	r.available = &available
	return r
}

// Comma-delimited list of IDs provided by the service broker for the service plan to filter by
func (r ApiV3ServicePlansGetRequest) BrokerCatalogIds(brokerCatalogIds []string) ApiV3ServicePlansGetRequest {
	r.brokerCatalogIds = &brokerCatalogIds
	return r
}

// Comma-delimited list of space GUIDs to filter by
func (r ApiV3ServicePlansGetRequest) SpaceGuids(spaceGuids []string) ApiV3ServicePlansGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

// Comma-delimited list of organization GUIDs to filter by
func (r ApiV3ServicePlansGetRequest) OrganizationGuids(organizationGuids []string) ApiV3ServicePlansGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

// Comma-delimited list of service broker GUIDs to filter by
func (r ApiV3ServicePlansGetRequest) ServiceBrokerGuids(serviceBrokerGuids []string) ApiV3ServicePlansGetRequest {
	r.serviceBrokerGuids = &serviceBrokerGuids
	return r
}

// Comma-delimited list of service broker names to filter by
func (r ApiV3ServicePlansGetRequest) ServiceBrokerNames(serviceBrokerNames []string) ApiV3ServicePlansGetRequest {
	r.serviceBrokerNames = &serviceBrokerNames
	return r
}

// Comma-delimited list of service Offering GUIDs to filter by
func (r ApiV3ServicePlansGetRequest) ServiceOfferingGuids(serviceOfferingGuids []string) ApiV3ServicePlansGetRequest {
	r.serviceOfferingGuids = &serviceOfferingGuids
	return r
}

// Comma-delimited list of service Offering names to filter by
func (r ApiV3ServicePlansGetRequest) ServiceOfferingNames(serviceOfferingNames []string) ApiV3ServicePlansGetRequest {
	r.serviceOfferingNames = &serviceOfferingNames
	return r
}

// Comma-delimited list of service Instance GUIDs to filter by
func (r ApiV3ServicePlansGetRequest) ServiceInstanceGuids(serviceInstanceGuids []string) ApiV3ServicePlansGetRequest {
	r.serviceInstanceGuids = &serviceInstanceGuids
	return r
}

// Optionally include a list of related resources in the response; valid values are space.organization and service_offering
func (r ApiV3ServicePlansGetRequest) Include(include []string) ApiV3ServicePlansGetRequest {
	r.include = &include
	return r
}

// Page to display; valid values are integers &gt;&#x3D; 1
func (r ApiV3ServicePlansGetRequest) Page(page int32) ApiV3ServicePlansGetRequest {
	r.page = &page
	return r
}

// Number of results per page; valid values are 1 through 5000
func (r ApiV3ServicePlansGetRequest) PerPage(perPage int32) ApiV3ServicePlansGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by. Defaults to ascending; prepend with - to sort descending. Valid values are created_at, updated_at, name
func (r ApiV3ServicePlansGetRequest) OrderBy(orderBy string) ApiV3ServicePlansGetRequest {
	r.orderBy = &orderBy
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3ServicePlansGetRequest) LabelSelector(labelSelector string) ApiV3ServicePlansGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Allowed values for fields
func (r ApiV3ServicePlansGetRequest) Fields(fields string) ApiV3ServicePlansGetRequest {
	r.fields = &fields
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3ServicePlansGetRequest) CreatedAts(createdAts string) ApiV3ServicePlansGetRequest {
	r.createdAts = &createdAts
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3ServicePlansGetRequest) UpdatedAts(updatedAts string) ApiV3ServicePlansGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3ServicePlansGetRequest) Execute() (*ServicePlanList, *http.Response, error) {
	return r.ApiService.V3ServicePlansGetExecute(r)
}

/*
V3ServicePlansGet List service plans

Retrieves the service plans the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServicePlansGetRequest
*/
func (a *DefaultAPIService) V3ServicePlansGet(ctx context.Context) ApiV3ServicePlansGetRequest {
	return ApiV3ServicePlansGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServicePlanList
func (a *DefaultAPIService) V3ServicePlansGetExecute(r ApiV3ServicePlansGetRequest) (*ServicePlanList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServicePlanList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServicePlansGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_plans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.names != nil {
		t := *r.names
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "names", t, "form", "multi")
		}
	}
	if r.available != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "available", r.available, "form", "")
	}
	if r.brokerCatalogIds != nil {
		t := *r.brokerCatalogIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "broker_catalog_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "broker_catalog_ids", t, "form", "multi")
		}
	}
	if r.spaceGuids != nil {
		t := *r.spaceGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", t, "form", "multi")
		}
	}
	if r.organizationGuids != nil {
		t := *r.organizationGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", t, "form", "multi")
		}
	}
	if r.serviceBrokerGuids != nil {
		t := *r.serviceBrokerGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_broker_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_broker_guids", t, "form", "multi")
		}
	}
	if r.serviceBrokerNames != nil {
		t := *r.serviceBrokerNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_broker_names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_broker_names", t, "form", "multi")
		}
	}
	if r.serviceOfferingGuids != nil {
		t := *r.serviceOfferingGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_offering_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_offering_guids", t, "form", "multi")
		}
	}
	if r.serviceOfferingNames != nil {
		t := *r.serviceOfferingNames
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_offering_names", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_offering_names", t, "form", "multi")
		}
	}
	if r.serviceInstanceGuids != nil {
		t := *r.serviceInstanceGuids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "service_instance_guids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "service_instance_guids", t, "form", "multi")
		}
	}
	if r.include != nil {
		t := *r.include
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "include", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "include", t, "form", "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServicePlansGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	purge *bool
}

// If true, any service plans, instances, and bindings associated with this service plan will also be deleted
func (r ApiV3ServicePlansGuidDeleteRequest) Purge(purge bool) ApiV3ServicePlansGuidDeleteRequest {
	r.purge = &purge
	return r
}

func (r ApiV3ServicePlansGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3ServicePlansGuidDeleteExecute(r)
}

/*
V3ServicePlansGuidDelete Delete a service plan

Deletes a service plan.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The service plan GUID
 @return ApiV3ServicePlansGuidDeleteRequest
*/
func (a *DefaultAPIService) V3ServicePlansGuidDelete(ctx context.Context, guid string) ApiV3ServicePlansGuidDeleteRequest {
	return ApiV3ServicePlansGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3ServicePlansGuidDeleteExecute(r ApiV3ServicePlansGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServicePlansGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_plans/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.purge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "purge", r.purge, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3ServicePlansGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServicePlansGuidGetRequest) Execute() (*ServicePlan, *http.Response, error) {
	return r.ApiService.V3ServicePlansGuidGetExecute(r)
}

/*
V3ServicePlansGuidGet Get a service plan

Retrieves the service plan by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The service plan GUID
 @return ApiV3ServicePlansGuidGetRequest
*/
func (a *DefaultAPIService) V3ServicePlansGuidGet(ctx context.Context, guid string) ApiV3ServicePlansGuidGetRequest {
	return ApiV3ServicePlansGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServicePlan
func (a *DefaultAPIService) V3ServicePlansGuidGetExecute(r ApiV3ServicePlansGuidGetRequest) (*ServicePlan, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServicePlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServicePlansGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_plans/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServicePlansGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	servicePlanUpdate *ServicePlanUpdate
}

func (r ApiV3ServicePlansGuidPatchRequest) ServicePlanUpdate(servicePlanUpdate ServicePlanUpdate) ApiV3ServicePlansGuidPatchRequest {
	r.servicePlanUpdate = &servicePlanUpdate
	return r
}

func (r ApiV3ServicePlansGuidPatchRequest) Execute() (*ServicePlan, *http.Response, error) {
	return r.ApiService.V3ServicePlansGuidPatchExecute(r)
}

/*
V3ServicePlansGuidPatch Update a service plan

Updates a service plan.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The service plan GUID
 @return ApiV3ServicePlansGuidPatchRequest
*/
func (a *DefaultAPIService) V3ServicePlansGuidPatch(ctx context.Context, guid string) ApiV3ServicePlansGuidPatchRequest {
	return ApiV3ServicePlansGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServicePlan
func (a *DefaultAPIService) V3ServicePlansGuidPatchExecute(r ApiV3ServicePlansGuidPatchRequest) (*ServicePlan, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServicePlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServicePlansGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_plans/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.servicePlanUpdate == nil {
		return localVarReturnValue, nil, reportError("servicePlanUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.servicePlanUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServicePlansPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	servicePlanCreate *ServicePlanCreate
}

func (r ApiV3ServicePlansPostRequest) ServicePlanCreate(servicePlanCreate ServicePlanCreate) ApiV3ServicePlansPostRequest {
	r.servicePlanCreate = &servicePlanCreate
	return r
}

func (r ApiV3ServicePlansPostRequest) Execute() (*ServicePlan, *http.Response, error) {
	return r.ApiService.V3ServicePlansPostExecute(r)
}

/*
V3ServicePlansPost Create a service plan

Creates a new service plan.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServicePlansPostRequest
*/
func (a *DefaultAPIService) V3ServicePlansPost(ctx context.Context) ApiV3ServicePlansPostRequest {
	return ApiV3ServicePlansPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServicePlan
func (a *DefaultAPIService) V3ServicePlansPostExecute(r ApiV3ServicePlansPostRequest) (*ServicePlan, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServicePlan
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServicePlansPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_plans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.servicePlanCreate == nil {
		return localVarReturnValue, nil, reportError("servicePlanCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.servicePlanCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceRouteBindingsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	routeGuids *[]string
	serviceInstanceGuids *[]string
	serviceInstanceNames *[]string
	labelSelector *string
	guids *[]string
	createdAts *string
	updatedAts *string
	include *[]string
	page *int32
	perPage *int32
	orderBy *string
}

func (r ApiV3ServiceRouteBindingsGetRequest) RouteGuids(routeGuids []string) ApiV3ServiceRouteBindingsGetRequest {
	r.routeGuids = &routeGuids
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) ServiceInstanceGuids(serviceInstanceGuids []string) ApiV3ServiceRouteBindingsGetRequest {
	r.serviceInstanceGuids = &serviceInstanceGuids
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) ServiceInstanceNames(serviceInstanceNames []string) ApiV3ServiceRouteBindingsGetRequest {
	r.serviceInstanceNames = &serviceInstanceNames
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) LabelSelector(labelSelector string) ApiV3ServiceRouteBindingsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) Guids(guids []string) ApiV3ServiceRouteBindingsGetRequest {
	r.guids = &guids
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) CreatedAts(createdAts string) ApiV3ServiceRouteBindingsGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) UpdatedAts(updatedAts string) ApiV3ServiceRouteBindingsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) Include(include []string) ApiV3ServiceRouteBindingsGetRequest {
	r.include = &include
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) Page(page int32) ApiV3ServiceRouteBindingsGetRequest {
	r.page = &page
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) PerPage(perPage int32) ApiV3ServiceRouteBindingsGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) OrderBy(orderBy string) ApiV3ServiceRouteBindingsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3ServiceRouteBindingsGetRequest) Execute() (*V3ServiceRouteBindingsGet200Response, *http.Response, error) {
	return r.ApiService.V3ServiceRouteBindingsGetExecute(r)
}

/*
V3ServiceRouteBindingsGet List service route bindings

Retrieves the service route bindings the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceRouteBindingsGetRequest
*/
func (a *DefaultAPIService) V3ServiceRouteBindingsGet(ctx context.Context) ApiV3ServiceRouteBindingsGetRequest {
	return ApiV3ServiceRouteBindingsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3ServiceRouteBindingsGet200Response
func (a *DefaultAPIService) V3ServiceRouteBindingsGetExecute(r ApiV3ServiceRouteBindingsGetRequest) (*V3ServiceRouteBindingsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3ServiceRouteBindingsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceRouteBindingsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_route_bindings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.routeGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "route_guids", r.routeGuids, "form", "csv")
	}
	if r.serviceInstanceGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "service_instance_guids", r.serviceInstanceGuids, "form", "csv")
	}
	if r.serviceInstanceNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "service_instance_names", r.serviceInstanceNames, "form", "csv")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "csv")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceRouteBindingsGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceRouteBindingsGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3ServiceRouteBindingsGuidDeleteExecute(r)
}

/*
V3ServiceRouteBindingsGuidDelete Delete a service route binding

Deletes a service route binding. When deleting route bindings originating from user-provided service instances, the delete operation does not require interactions with service brokers, therefore the API will respond synchronously to the delete request.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceRouteBindingsGuidDeleteRequest
*/
func (a *DefaultAPIService) V3ServiceRouteBindingsGuidDelete(ctx context.Context, guid string) ApiV3ServiceRouteBindingsGuidDeleteRequest {
	return ApiV3ServiceRouteBindingsGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3ServiceRouteBindingsGuidDeleteExecute(r ApiV3ServiceRouteBindingsGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceRouteBindingsGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_route_bindings/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3ServiceRouteBindingsGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	include *[]string
}

func (r ApiV3ServiceRouteBindingsGuidGetRequest) Include(include []string) ApiV3ServiceRouteBindingsGuidGetRequest {
	r.include = &include
	return r
}

func (r ApiV3ServiceRouteBindingsGuidGetRequest) Execute() (*ServiceRouteBinding, *http.Response, error) {
	return r.ApiService.V3ServiceRouteBindingsGuidGetExecute(r)
}

/*
V3ServiceRouteBindingsGuidGet Get a service route binding

Retrieves the service route binding by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceRouteBindingsGuidGetRequest
*/
func (a *DefaultAPIService) V3ServiceRouteBindingsGuidGet(ctx context.Context, guid string) ApiV3ServiceRouteBindingsGuidGetRequest {
	return ApiV3ServiceRouteBindingsGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceRouteBinding
func (a *DefaultAPIService) V3ServiceRouteBindingsGuidGetExecute(r ApiV3ServiceRouteBindingsGuidGetRequest) (*ServiceRouteBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceRouteBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceRouteBindingsGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_route_bindings/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.include != nil {
		t := *r.include
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "include", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "include", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceRouteBindingsGuidParametersGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceRouteBindingsGuidParametersGetRequest) Execute() (map[string]string, *http.Response, error) {
	return r.ApiService.V3ServiceRouteBindingsGuidParametersGetExecute(r)
}

/*
V3ServiceRouteBindingsGuidParametersGet Get parameters for a route binding

Queries the Service Broker for the parameters associated with this service route binding. This endpoint is not available for User-Provided Service Instances.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceRouteBindingsGuidParametersGetRequest
*/
func (a *DefaultAPIService) V3ServiceRouteBindingsGuidParametersGet(ctx context.Context, guid string) ApiV3ServiceRouteBindingsGuidParametersGetRequest {
	return ApiV3ServiceRouteBindingsGuidParametersGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return map[string]string
func (a *DefaultAPIService) V3ServiceRouteBindingsGuidParametersGetExecute(r ApiV3ServiceRouteBindingsGuidParametersGetRequest) (map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceRouteBindingsGuidParametersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_route_bindings/{guid}/parameters"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceRouteBindingsGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3ServiceRouteBindingsGuidPatchRequest *V3ServiceRouteBindingsGuidPatchRequest
}

func (r ApiV3ServiceRouteBindingsGuidPatchRequest) V3ServiceRouteBindingsGuidPatchRequest(v3ServiceRouteBindingsGuidPatchRequest V3ServiceRouteBindingsGuidPatchRequest) ApiV3ServiceRouteBindingsGuidPatchRequest {
	r.v3ServiceRouteBindingsGuidPatchRequest = &v3ServiceRouteBindingsGuidPatchRequest
	return r
}

func (r ApiV3ServiceRouteBindingsGuidPatchRequest) Execute() (*ServiceRouteBinding, *http.Response, error) {
	return r.ApiService.V3ServiceRouteBindingsGuidPatchExecute(r)
}

/*
V3ServiceRouteBindingsGuidPatch Update a service route binding

Updates a service route binding with labels and annotations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceRouteBindingsGuidPatchRequest
*/
func (a *DefaultAPIService) V3ServiceRouteBindingsGuidPatch(ctx context.Context, guid string) ApiV3ServiceRouteBindingsGuidPatchRequest {
	return ApiV3ServiceRouteBindingsGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceRouteBinding
func (a *DefaultAPIService) V3ServiceRouteBindingsGuidPatchExecute(r ApiV3ServiceRouteBindingsGuidPatchRequest) (*ServiceRouteBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceRouteBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceRouteBindingsGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_route_bindings/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3ServiceRouteBindingsGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3ServiceRouteBindingsGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3ServiceRouteBindingsGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceRouteBindingsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	v3ServiceRouteBindingsPostRequest *V3ServiceRouteBindingsPostRequest
}

func (r ApiV3ServiceRouteBindingsPostRequest) V3ServiceRouteBindingsPostRequest(v3ServiceRouteBindingsPostRequest V3ServiceRouteBindingsPostRequest) ApiV3ServiceRouteBindingsPostRequest {
	r.v3ServiceRouteBindingsPostRequest = &v3ServiceRouteBindingsPostRequest
	return r
}

func (r ApiV3ServiceRouteBindingsPostRequest) Execute() (*ServiceRouteBinding, *http.Response, error) {
	return r.ApiService.V3ServiceRouteBindingsPostExecute(r)
}

/*
V3ServiceRouteBindingsPost Create a service route binding

Creates a new route service binding. The service instance and the route must be in the same space.
To bind a route to a user-provided service instance, the service instance must have the route_service_url property set.
To bind a route to a managed service instance, the service offering must be bindable, and the service offering must have route_forwarding set in the requires property.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceRouteBindingsPostRequest
*/
func (a *DefaultAPIService) V3ServiceRouteBindingsPost(ctx context.Context) ApiV3ServiceRouteBindingsPostRequest {
	return ApiV3ServiceRouteBindingsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceRouteBinding
func (a *DefaultAPIService) V3ServiceRouteBindingsPostExecute(r ApiV3ServiceRouteBindingsPostRequest) (*ServiceRouteBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceRouteBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceRouteBindingsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_route_bindings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3ServiceRouteBindingsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3ServiceRouteBindingsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3ServiceRouteBindingsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceUsageEventsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	page *int32
	perPage *int32
	orderBy *string
	afterGuid *string
	guids *[]string
	serviceInstanceTypes *[]string
	serviceOfferingGuids *[]string
	createdAts *string
	updatedAts *string
}

func (r ApiV3ServiceUsageEventsGetRequest) Page(page int32) ApiV3ServiceUsageEventsGetRequest {
	r.page = &page
	return r
}

func (r ApiV3ServiceUsageEventsGetRequest) PerPage(perPage int32) ApiV3ServiceUsageEventsGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3ServiceUsageEventsGetRequest) OrderBy(orderBy string) ApiV3ServiceUsageEventsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3ServiceUsageEventsGetRequest) AfterGuid(afterGuid string) ApiV3ServiceUsageEventsGetRequest {
	r.afterGuid = &afterGuid
	return r
}

func (r ApiV3ServiceUsageEventsGetRequest) Guids(guids []string) ApiV3ServiceUsageEventsGetRequest {
	r.guids = &guids
	return r
}

func (r ApiV3ServiceUsageEventsGetRequest) ServiceInstanceTypes(serviceInstanceTypes []string) ApiV3ServiceUsageEventsGetRequest {
	r.serviceInstanceTypes = &serviceInstanceTypes
	return r
}

func (r ApiV3ServiceUsageEventsGetRequest) ServiceOfferingGuids(serviceOfferingGuids []string) ApiV3ServiceUsageEventsGetRequest {
	r.serviceOfferingGuids = &serviceOfferingGuids
	return r
}

func (r ApiV3ServiceUsageEventsGetRequest) CreatedAts(createdAts string) ApiV3ServiceUsageEventsGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3ServiceUsageEventsGetRequest) UpdatedAts(updatedAts string) ApiV3ServiceUsageEventsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3ServiceUsageEventsGetRequest) Execute() (*V3ServiceUsageEventsGet200Response, *http.Response, error) {
	return r.ApiService.V3ServiceUsageEventsGetExecute(r)
}

/*
V3ServiceUsageEventsGet List service usage events

Retrieve all service usage events the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceUsageEventsGetRequest
*/
func (a *DefaultAPIService) V3ServiceUsageEventsGet(ctx context.Context) ApiV3ServiceUsageEventsGetRequest {
	return ApiV3ServiceUsageEventsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3ServiceUsageEventsGet200Response
func (a *DefaultAPIService) V3ServiceUsageEventsGetExecute(r ApiV3ServiceUsageEventsGetRequest) (*V3ServiceUsageEventsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3ServiceUsageEventsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceUsageEventsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_usage_events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.afterGuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after_guid", r.afterGuid, "form", "")
	}
	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "csv")
	}
	if r.serviceInstanceTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "service_instance_types", r.serviceInstanceTypes, "form", "csv")
	}
	if r.serviceOfferingGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "service_offering_guids", r.serviceOfferingGuids, "form", "csv")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceUsageEventsGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3ServiceUsageEventsGuidGetRequest) Execute() (*ServiceUsageEvent, *http.Response, error) {
	return r.ApiService.V3ServiceUsageEventsGuidGetExecute(r)
}

/*
V3ServiceUsageEventsGuidGet Get a service usage event

Retrieve a service usage event by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3ServiceUsageEventsGuidGetRequest
*/
func (a *DefaultAPIService) V3ServiceUsageEventsGuidGet(ctx context.Context, guid string) ApiV3ServiceUsageEventsGuidGetRequest {
	return ApiV3ServiceUsageEventsGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return ServiceUsageEvent
func (a *DefaultAPIService) V3ServiceUsageEventsGuidGetExecute(r ApiV3ServiceUsageEventsGuidGetRequest) (*ServiceUsageEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceUsageEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceUsageEventsGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_usage_events/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ServiceUsageEventsPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
}

func (r ApiV3ServiceUsageEventsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3ServiceUsageEventsPostExecute(r)
}

/*
V3ServiceUsageEventsPost Purge and seed service usage events

Destroys all existing events. Populates new usage events, one for each existing service instance.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3ServiceUsageEventsPostRequest
*/
func (a *DefaultAPIService) V3ServiceUsageEventsPost(ctx context.Context) ApiV3ServiceUsageEventsPostRequest {
	return ApiV3ServiceUsageEventsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3ServiceUsageEventsPostExecute(r ApiV3ServiceUsageEventsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3ServiceUsageEventsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/service_usage_events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3SpacesGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	names *string
	guids *string
	organizationGuids *string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	include *string
	createdAts *string
	updatedAts *string
}

func (r ApiV3SpacesGetRequest) Names(names string) ApiV3SpacesGetRequest {
	r.names = &names
	return r
}

func (r ApiV3SpacesGetRequest) Guids(guids string) ApiV3SpacesGetRequest {
	r.guids = &guids
	return r
}

func (r ApiV3SpacesGetRequest) OrganizationGuids(organizationGuids string) ApiV3SpacesGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

func (r ApiV3SpacesGetRequest) Page(page int32) ApiV3SpacesGetRequest {
	r.page = &page
	return r
}

func (r ApiV3SpacesGetRequest) PerPage(perPage int32) ApiV3SpacesGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3SpacesGetRequest) OrderBy(orderBy string) ApiV3SpacesGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3SpacesGetRequest) LabelSelector(labelSelector string) ApiV3SpacesGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3SpacesGetRequest) Include(include string) ApiV3SpacesGetRequest {
	r.include = &include
	return r
}

func (r ApiV3SpacesGetRequest) CreatedAts(createdAts string) ApiV3SpacesGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3SpacesGetRequest) UpdatedAts(updatedAts string) ApiV3SpacesGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3SpacesGetRequest) Execute() (*V3SpacesGet200Response, *http.Response, error) {
	return r.ApiService.V3SpacesGetExecute(r)
}

/*
V3SpacesGet List spaces

Retrieve all spaces the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3SpacesGetRequest
*/
func (a *DefaultAPIService) V3SpacesGet(ctx context.Context) ApiV3SpacesGetRequest {
	return ApiV3SpacesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3SpacesGet200Response
func (a *DefaultAPIService) V3SpacesGetExecute(r ApiV3SpacesGetRequest) (*V3SpacesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3SpacesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpacesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/spaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.names != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "names", r.names, "form", "")
	}
	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "")
	}
	if r.organizationGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", r.organizationGuids, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpacesGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3SpacesGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3SpacesGuidDeleteExecute(r)
}

/*
V3SpacesGuidDelete Delete a space

Delete a space by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3SpacesGuidDeleteRequest
*/
func (a *DefaultAPIService) V3SpacesGuidDelete(ctx context.Context, guid string) ApiV3SpacesGuidDeleteRequest {
	return ApiV3SpacesGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3SpacesGuidDeleteExecute(r ApiV3SpacesGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpacesGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/spaces/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3SpacesGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3SpacesGuidGetRequest) Execute() (*Space, *http.Response, error) {
	return r.ApiService.V3SpacesGuidGetExecute(r)
}

/*
V3SpacesGuidGet Get a space

Retrieve a space by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3SpacesGuidGetRequest
*/
func (a *DefaultAPIService) V3SpacesGuidGet(ctx context.Context, guid string) ApiV3SpacesGuidGetRequest {
	return ApiV3SpacesGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Space
func (a *DefaultAPIService) V3SpacesGuidGetExecute(r ApiV3SpacesGuidGetRequest) (*Space, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Space
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpacesGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/spaces/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpacesGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3SpacesGuidPatchRequest *V3SpacesGuidPatchRequest
}

func (r ApiV3SpacesGuidPatchRequest) V3SpacesGuidPatchRequest(v3SpacesGuidPatchRequest V3SpacesGuidPatchRequest) ApiV3SpacesGuidPatchRequest {
	r.v3SpacesGuidPatchRequest = &v3SpacesGuidPatchRequest
	return r
}

func (r ApiV3SpacesGuidPatchRequest) Execute() (*Space, *http.Response, error) {
	return r.ApiService.V3SpacesGuidPatchExecute(r)
}

/*
V3SpacesGuidPatch Update a space

Update a space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3SpacesGuidPatchRequest
*/
func (a *DefaultAPIService) V3SpacesGuidPatch(ctx context.Context, guid string) ApiV3SpacesGuidPatchRequest {
	return ApiV3SpacesGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Space
func (a *DefaultAPIService) V3SpacesGuidPatchExecute(r ApiV3SpacesGuidPatchRequest) (*Space, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Space
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpacesGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/spaces/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3SpacesGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3SpacesGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3SpacesGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpacesGuidRelationshipsIsolationSegmentGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3SpacesGuidRelationshipsIsolationSegmentGetRequest) Execute() (*AssignDefaultIsolationSegmentRequest, *http.Response, error) {
	return r.ApiService.V3SpacesGuidRelationshipsIsolationSegmentGetExecute(r)
}

/*
V3SpacesGuidRelationshipsIsolationSegmentGet Get assigned isolation segment

Retrieve the isolation segment assigned to the space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3SpacesGuidRelationshipsIsolationSegmentGetRequest
*/
func (a *DefaultAPIService) V3SpacesGuidRelationshipsIsolationSegmentGet(ctx context.Context, guid string) ApiV3SpacesGuidRelationshipsIsolationSegmentGetRequest {
	return ApiV3SpacesGuidRelationshipsIsolationSegmentGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return AssignDefaultIsolationSegmentRequest
func (a *DefaultAPIService) V3SpacesGuidRelationshipsIsolationSegmentGetExecute(r ApiV3SpacesGuidRelationshipsIsolationSegmentGetRequest) (*AssignDefaultIsolationSegmentRequest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssignDefaultIsolationSegmentRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpacesGuidRelationshipsIsolationSegmentGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/spaces/{guid}/relationships/isolation_segment"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	assignDefaultIsolationSegmentRequest *AssignDefaultIsolationSegmentRequest
}

func (r ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest) AssignDefaultIsolationSegmentRequest(assignDefaultIsolationSegmentRequest AssignDefaultIsolationSegmentRequest) ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest {
	r.assignDefaultIsolationSegmentRequest = &assignDefaultIsolationSegmentRequest
	return r
}

func (r ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest) Execute() (*AssignDefaultIsolationSegmentRequest, *http.Response, error) {
	return r.ApiService.V3SpacesGuidRelationshipsIsolationSegmentPatchExecute(r)
}

/*
V3SpacesGuidRelationshipsIsolationSegmentPatch Manage isolation segment

Assign or unassign an isolation segment to a space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest
*/
func (a *DefaultAPIService) V3SpacesGuidRelationshipsIsolationSegmentPatch(ctx context.Context, guid string) ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest {
	return ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return AssignDefaultIsolationSegmentRequest
func (a *DefaultAPIService) V3SpacesGuidRelationshipsIsolationSegmentPatchExecute(r ApiV3SpacesGuidRelationshipsIsolationSegmentPatchRequest) (*AssignDefaultIsolationSegmentRequest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AssignDefaultIsolationSegmentRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpacesGuidRelationshipsIsolationSegmentPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/spaces/{guid}/relationships/isolation_segment"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.assignDefaultIsolationSegmentRequest == nil {
		return localVarReturnValue, nil, reportError("assignDefaultIsolationSegmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.assignDefaultIsolationSegmentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpacesGuidUsersGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	guids *string
	usernames *string
	partialUsernames *string
	origins *string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

func (r ApiV3SpacesGuidUsersGetRequest) Guids(guids string) ApiV3SpacesGuidUsersGetRequest {
	r.guids = &guids
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) Usernames(usernames string) ApiV3SpacesGuidUsersGetRequest {
	r.usernames = &usernames
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) PartialUsernames(partialUsernames string) ApiV3SpacesGuidUsersGetRequest {
	r.partialUsernames = &partialUsernames
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) Origins(origins string) ApiV3SpacesGuidUsersGetRequest {
	r.origins = &origins
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) Page(page int32) ApiV3SpacesGuidUsersGetRequest {
	r.page = &page
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) PerPage(perPage int32) ApiV3SpacesGuidUsersGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) OrderBy(orderBy string) ApiV3SpacesGuidUsersGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) LabelSelector(labelSelector string) ApiV3SpacesGuidUsersGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) CreatedAts(createdAts string) ApiV3SpacesGuidUsersGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) UpdatedAts(updatedAts string) ApiV3SpacesGuidUsersGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3SpacesGuidUsersGetRequest) Execute() (*V3SpacesGuidUsersGet200Response, *http.Response, error) {
	return r.ApiService.V3SpacesGuidUsersGetExecute(r)
}

/*
V3SpacesGuidUsersGet List users for a space

Retrieve all users with a role in the specified space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3SpacesGuidUsersGetRequest
*/
func (a *DefaultAPIService) V3SpacesGuidUsersGet(ctx context.Context, guid string) ApiV3SpacesGuidUsersGetRequest {
	return ApiV3SpacesGuidUsersGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3SpacesGuidUsersGet200Response
func (a *DefaultAPIService) V3SpacesGuidUsersGetExecute(r ApiV3SpacesGuidUsersGetRequest) (*V3SpacesGuidUsersGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3SpacesGuidUsersGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpacesGuidUsersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/spaces/{guid}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "")
	}
	if r.usernames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usernames", r.usernames, "form", "")
	}
	if r.partialUsernames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partial_usernames", r.partialUsernames, "form", "")
	}
	if r.origins != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origins", r.origins, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SpacesPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	v3SpacesPostRequest *V3SpacesPostRequest
}

func (r ApiV3SpacesPostRequest) V3SpacesPostRequest(v3SpacesPostRequest V3SpacesPostRequest) ApiV3SpacesPostRequest {
	r.v3SpacesPostRequest = &v3SpacesPostRequest
	return r
}

func (r ApiV3SpacesPostRequest) Execute() (*Space, *http.Response, error) {
	return r.ApiService.V3SpacesPostExecute(r)
}

/*
V3SpacesPost Create a space

Create a space.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3SpacesPostRequest
*/
func (a *DefaultAPIService) V3SpacesPost(ctx context.Context) ApiV3SpacesPostRequest {
	return ApiV3SpacesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Space
func (a *DefaultAPIService) V3SpacesPostExecute(r ApiV3SpacesPostRequest) (*Space, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Space
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3SpacesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/spaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3SpacesPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3SpacesPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3SpacesPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3StacksGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	names *string
	default_ *bool
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

func (r ApiV3StacksGetRequest) Names(names string) ApiV3StacksGetRequest {
	r.names = &names
	return r
}

func (r ApiV3StacksGetRequest) Default_(default_ bool) ApiV3StacksGetRequest {
	r.default_ = &default_
	return r
}

func (r ApiV3StacksGetRequest) Page(page int32) ApiV3StacksGetRequest {
	r.page = &page
	return r
}

func (r ApiV3StacksGetRequest) PerPage(perPage int32) ApiV3StacksGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3StacksGetRequest) OrderBy(orderBy string) ApiV3StacksGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3StacksGetRequest) LabelSelector(labelSelector string) ApiV3StacksGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3StacksGetRequest) CreatedAts(createdAts string) ApiV3StacksGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3StacksGetRequest) UpdatedAts(updatedAts string) ApiV3StacksGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3StacksGetRequest) Execute() (*V3StacksGet200Response, *http.Response, error) {
	return r.ApiService.V3StacksGetExecute(r)
}

/*
V3StacksGet List all stacks

Retrieve all stacks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3StacksGetRequest
*/
func (a *DefaultAPIService) V3StacksGet(ctx context.Context) ApiV3StacksGetRequest {
	return ApiV3StacksGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3StacksGet200Response
func (a *DefaultAPIService) V3StacksGetExecute(r ApiV3StacksGetRequest) (*V3StacksGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3StacksGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3StacksGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/stacks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.names != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "names", r.names, "form", "")
	}
	if r.default_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default", r.default_, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	} else {
		var defaultValue int32 = 50
		r.perPage = &defaultValue
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3StacksGuidAppsGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

func (r ApiV3StacksGuidAppsGetRequest) Page(page int32) ApiV3StacksGuidAppsGetRequest {
	r.page = &page
	return r
}

func (r ApiV3StacksGuidAppsGetRequest) PerPage(perPage int32) ApiV3StacksGuidAppsGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3StacksGuidAppsGetRequest) OrderBy(orderBy string) ApiV3StacksGuidAppsGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3StacksGuidAppsGetRequest) LabelSelector(labelSelector string) ApiV3StacksGuidAppsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3StacksGuidAppsGetRequest) CreatedAts(createdAts string) ApiV3StacksGuidAppsGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3StacksGuidAppsGetRequest) UpdatedAts(updatedAts string) ApiV3StacksGuidAppsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3StacksGuidAppsGetRequest) Execute() (*V3StacksGuidAppsGet200Response, *http.Response, error) {
	return r.ApiService.V3StacksGuidAppsGetExecute(r)
}

/*
V3StacksGuidAppsGet List apps on a stack

Retrieve all apps using a given stack.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3StacksGuidAppsGetRequest
*/
func (a *DefaultAPIService) V3StacksGuidAppsGet(ctx context.Context, guid string) ApiV3StacksGuidAppsGetRequest {
	return ApiV3StacksGuidAppsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3StacksGuidAppsGet200Response
func (a *DefaultAPIService) V3StacksGuidAppsGetExecute(r ApiV3StacksGuidAppsGetRequest) (*V3StacksGuidAppsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3StacksGuidAppsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3StacksGuidAppsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/stacks/{guid}/apps"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	} else {
		var defaultValue int32 = 50
		r.perPage = &defaultValue
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3StacksGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3StacksGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3StacksGuidDeleteExecute(r)
}

/*
V3StacksGuidDelete Delete a stack

Delete a stack by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3StacksGuidDeleteRequest
*/
func (a *DefaultAPIService) V3StacksGuidDelete(ctx context.Context, guid string) ApiV3StacksGuidDeleteRequest {
	return ApiV3StacksGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3StacksGuidDeleteExecute(r ApiV3StacksGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3StacksGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/stacks/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3StacksGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3StacksGuidGetRequest) Execute() (*Stack, *http.Response, error) {
	return r.ApiService.V3StacksGuidGetExecute(r)
}

/*
V3StacksGuidGet Get a stack by GUID

Retrieve a stack by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3StacksGuidGetRequest
*/
func (a *DefaultAPIService) V3StacksGuidGet(ctx context.Context, guid string) ApiV3StacksGuidGetRequest {
	return ApiV3StacksGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Stack
func (a *DefaultAPIService) V3StacksGuidGetExecute(r ApiV3StacksGuidGetRequest) (*Stack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Stack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3StacksGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/stacks/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3StacksGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3DeploymentsGuidPatchRequest *V3DeploymentsGuidPatchRequest
}

func (r ApiV3StacksGuidPatchRequest) V3DeploymentsGuidPatchRequest(v3DeploymentsGuidPatchRequest V3DeploymentsGuidPatchRequest) ApiV3StacksGuidPatchRequest {
	r.v3DeploymentsGuidPatchRequest = &v3DeploymentsGuidPatchRequest
	return r
}

func (r ApiV3StacksGuidPatchRequest) Execute() (*Stack, *http.Response, error) {
	return r.ApiService.V3StacksGuidPatchExecute(r)
}

/*
V3StacksGuidPatch Update a stack

Update the specified parameters of a stack.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3StacksGuidPatchRequest
*/
func (a *DefaultAPIService) V3StacksGuidPatch(ctx context.Context, guid string) ApiV3StacksGuidPatchRequest {
	return ApiV3StacksGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Stack
func (a *DefaultAPIService) V3StacksGuidPatchExecute(r ApiV3StacksGuidPatchRequest) (*Stack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Stack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3StacksGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/stacks/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3DeploymentsGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3DeploymentsGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3DeploymentsGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3StacksPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	v3StacksPostRequest *V3StacksPostRequest
}

func (r ApiV3StacksPostRequest) V3StacksPostRequest(v3StacksPostRequest V3StacksPostRequest) ApiV3StacksPostRequest {
	r.v3StacksPostRequest = &v3StacksPostRequest
	return r
}

func (r ApiV3StacksPostRequest) Execute() (*Stack, *http.Response, error) {
	return r.ApiService.V3StacksPostExecute(r)
}

/*
V3StacksPost Create a stack

Create a new stack.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3StacksPostRequest
*/
func (a *DefaultAPIService) V3StacksPost(ctx context.Context) ApiV3StacksPostRequest {
	return ApiV3StacksPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Stack
func (a *DefaultAPIService) V3StacksPostExecute(r ApiV3StacksPostRequest) (*Stack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Stack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3StacksPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/stacks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3StacksPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3StacksPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3StacksPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3TasksGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guids *string
	names *string
	states *string
	appGuids *string
	spaceGuids *string
	organizationGuids *string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

func (r ApiV3TasksGetRequest) Guids(guids string) ApiV3TasksGetRequest {
	r.guids = &guids
	return r
}

func (r ApiV3TasksGetRequest) Names(names string) ApiV3TasksGetRequest {
	r.names = &names
	return r
}

func (r ApiV3TasksGetRequest) States(states string) ApiV3TasksGetRequest {
	r.states = &states
	return r
}

func (r ApiV3TasksGetRequest) AppGuids(appGuids string) ApiV3TasksGetRequest {
	r.appGuids = &appGuids
	return r
}

func (r ApiV3TasksGetRequest) SpaceGuids(spaceGuids string) ApiV3TasksGetRequest {
	r.spaceGuids = &spaceGuids
	return r
}

func (r ApiV3TasksGetRequest) OrganizationGuids(organizationGuids string) ApiV3TasksGetRequest {
	r.organizationGuids = &organizationGuids
	return r
}

func (r ApiV3TasksGetRequest) Page(page int32) ApiV3TasksGetRequest {
	r.page = &page
	return r
}

func (r ApiV3TasksGetRequest) PerPage(perPage int32) ApiV3TasksGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3TasksGetRequest) OrderBy(orderBy string) ApiV3TasksGetRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiV3TasksGetRequest) LabelSelector(labelSelector string) ApiV3TasksGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3TasksGetRequest) CreatedAts(createdAts string) ApiV3TasksGetRequest {
	r.createdAts = &createdAts
	return r
}

func (r ApiV3TasksGetRequest) UpdatedAts(updatedAts string) ApiV3TasksGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3TasksGetRequest) Execute() (*V3TasksGet200Response, *http.Response, error) {
	return r.ApiService.V3TasksGetExecute(r)
}

/*
V3TasksGet List all tasks

Retrieve all tasks the user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3TasksGetRequest
*/
func (a *DefaultAPIService) V3TasksGet(ctx context.Context) ApiV3TasksGetRequest {
	return ApiV3TasksGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3TasksGet200Response
func (a *DefaultAPIService) V3TasksGetExecute(r ApiV3TasksGetRequest) (*V3TasksGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3TasksGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3TasksGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "")
	}
	if r.names != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "names", r.names, "form", "")
	}
	if r.states != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "states", r.states, "form", "")
	}
	if r.appGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "app_guids", r.appGuids, "form", "")
	}
	if r.spaceGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "space_guids", r.spaceGuids, "form", "")
	}
	if r.organizationGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "organization_guids", r.organizationGuids, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	} else {
		var defaultValue int32 = 50
		r.perPage = &defaultValue
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3TasksGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3TasksGuidGetRequest) Execute() (*Task, *http.Response, error) {
	return r.ApiService.V3TasksGuidGetExecute(r)
}

/*
V3TasksGuidGet Get a task

Retrieve a specific task by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3TasksGuidGetRequest
*/
func (a *DefaultAPIService) V3TasksGuidGet(ctx context.Context, guid string) ApiV3TasksGuidGetRequest {
	return ApiV3TasksGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Task
func (a *DefaultAPIService) V3TasksGuidGetExecute(r ApiV3TasksGuidGetRequest) (*Task, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Task
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3TasksGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/tasks/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3TasksGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3DeploymentsGuidPatchRequest *V3DeploymentsGuidPatchRequest
}

func (r ApiV3TasksGuidPatchRequest) V3DeploymentsGuidPatchRequest(v3DeploymentsGuidPatchRequest V3DeploymentsGuidPatchRequest) ApiV3TasksGuidPatchRequest {
	r.v3DeploymentsGuidPatchRequest = &v3DeploymentsGuidPatchRequest
	return r
}

func (r ApiV3TasksGuidPatchRequest) Execute() (*Task, *http.Response, error) {
	return r.ApiService.V3TasksGuidPatchExecute(r)
}

/*
V3TasksGuidPatch Update a task

Update the specified parameters of a task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3TasksGuidPatchRequest
*/
func (a *DefaultAPIService) V3TasksGuidPatch(ctx context.Context, guid string) ApiV3TasksGuidPatchRequest {
	return ApiV3TasksGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Task
func (a *DefaultAPIService) V3TasksGuidPatchExecute(r ApiV3TasksGuidPatchRequest) (*Task, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Task
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3TasksGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/tasks/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3DeploymentsGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3DeploymentsGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3DeploymentsGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3TasksGuidPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3TasksGuidPostRequest) Execute() (*Task, *http.Response, error) {
	return r.ApiService.V3TasksGuidPostExecute(r)
}

/*
V3TasksGuidPost Cancel a task

Cancels a running task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid
 @return ApiV3TasksGuidPostRequest
*/
func (a *DefaultAPIService) V3TasksGuidPost(ctx context.Context, guid string) ApiV3TasksGuidPostRequest {
	return ApiV3TasksGuidPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Task
func (a *DefaultAPIService) V3TasksGuidPostExecute(r ApiV3TasksGuidPostRequest) (*Task, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Task
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3TasksGuidPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/tasks/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3UsersGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guids *[]string
	usernames *[]string
	partialUsernames *[]string
	origins *[]string
	page *int32
	perPage *int32
	orderBy *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

// Comma-delimited list of user guids to filter by
func (r ApiV3UsersGetRequest) Guids(guids []string) ApiV3UsersGetRequest {
	r.guids = &guids
	return r
}

// Comma-delimited list of usernames to filter by. Mutually exclusive with partial_usernames
func (r ApiV3UsersGetRequest) Usernames(usernames []string) ApiV3UsersGetRequest {
	r.usernames = &usernames
	return r
}

// Comma-delimited list of strings to search by. When using this query parameter, all the users that contain the string provided in their username will be returned. Mutually exclusive with usernames
func (r ApiV3UsersGetRequest) PartialUsernames(partialUsernames []string) ApiV3UsersGetRequest {
	r.partialUsernames = &partialUsernames
	return r
}

// Comma-delimited list of user origins (user stores) to filter by, for example, users authenticated by UAA have the origin “uaa”; users authenticated by an LDAP provider have the origin “ldap”; when filtering by origins, usernames must be included
func (r ApiV3UsersGetRequest) Origins(origins []string) ApiV3UsersGetRequest {
	r.origins = &origins
	return r
}

// Page to display; valid values are integers &gt;&#x3D; 1
func (r ApiV3UsersGetRequest) Page(page int32) ApiV3UsersGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3UsersGetRequest) PerPage(perPage int32) ApiV3UsersGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by. Defaults to ascending; prepend with - to sort descending
func (r ApiV3UsersGetRequest) OrderBy(orderBy string) ApiV3UsersGetRequest {
	r.orderBy = &orderBy
	return r
}

// A query string containing a list of label selector requirements
func (r ApiV3UsersGetRequest) LabelSelector(labelSelector string) ApiV3UsersGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3UsersGetRequest) CreatedAts(createdAts string) ApiV3UsersGetRequest {
	r.createdAts = &createdAts
	return r
}

// Timestamp to filter by. When filtering on equality, several comma-delimited timestamps may be passed. Also supports filtering with relational operators
func (r ApiV3UsersGetRequest) UpdatedAts(updatedAts string) ApiV3UsersGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3UsersGetRequest) Execute() (*V3UsersGet200Response, *http.Response, error) {
	return r.ApiService.V3UsersGetExecute(r)
}

/*
V3UsersGet List users

Retrieve all users that the current user can see.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3UsersGetRequest
*/
func (a *DefaultAPIService) V3UsersGet(ctx context.Context) ApiV3UsersGetRequest {
	return ApiV3UsersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3UsersGet200Response
func (a *DefaultAPIService) V3UsersGetExecute(r ApiV3UsersGetRequest) (*V3UsersGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3UsersGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3UsersGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.guids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "guids", r.guids, "form", "csv")
	}
	if r.usernames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usernames", r.usernames, "form", "csv")
	}
	if r.partialUsernames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partial_usernames", r.partialUsernames, "form", "csv")
	}
	if r.origins != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origins", r.origins, "form", "csv")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3UsersGuidDeleteRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3UsersGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3UsersGuidDeleteExecute(r)
}

/*
V3UsersGuidDelete Delete a user

Delete a user by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid Unique identifier for the user
 @return ApiV3UsersGuidDeleteRequest
*/
func (a *DefaultAPIService) V3UsersGuidDelete(ctx context.Context, guid string) ApiV3UsersGuidDeleteRequest {
	return ApiV3UsersGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V3UsersGuidDeleteExecute(r ApiV3UsersGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3UsersGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/users/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3UsersGuidGetRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
}

func (r ApiV3UsersGuidGetRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.V3UsersGuidGetExecute(r)
}

/*
V3UsersGuidGet Get a user

Retrieve a user by GUID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid Unique identifier for the user
 @return ApiV3UsersGuidGetRequest
*/
func (a *DefaultAPIService) V3UsersGuidGet(ctx context.Context, guid string) ApiV3UsersGuidGetRequest {
	return ApiV3UsersGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return User
func (a *DefaultAPIService) V3UsersGuidGetExecute(r ApiV3UsersGuidGetRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3UsersGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/users/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3UsersGuidPatchRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	guid string
	v3UsersGuidPatchRequest *V3UsersGuidPatchRequest
}

func (r ApiV3UsersGuidPatchRequest) V3UsersGuidPatchRequest(v3UsersGuidPatchRequest V3UsersGuidPatchRequest) ApiV3UsersGuidPatchRequest {
	r.v3UsersGuidPatchRequest = &v3UsersGuidPatchRequest
	return r
}

func (r ApiV3UsersGuidPatchRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.V3UsersGuidPatchExecute(r)
}

/*
V3UsersGuidPatch Update a user

Update a user’s metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid Unique identifier for the user
 @return ApiV3UsersGuidPatchRequest
*/
func (a *DefaultAPIService) V3UsersGuidPatch(ctx context.Context, guid string) ApiV3UsersGuidPatchRequest {
	return ApiV3UsersGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return User
func (a *DefaultAPIService) V3UsersGuidPatchExecute(r ApiV3UsersGuidPatchRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3UsersGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/users/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3UsersGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3UsersGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3UsersGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3UsersPostRequest struct {
	ctx context.Context
	ApiService DefaultAPI
	v3UsersPostRequest *V3UsersPostRequest
}

func (r ApiV3UsersPostRequest) V3UsersPostRequest(v3UsersPostRequest V3UsersPostRequest) ApiV3UsersPostRequest {
	r.v3UsersPostRequest = &v3UsersPostRequest
	return r
}

func (r ApiV3UsersPostRequest) Execute() (*User, *http.Response, error) {
	return r.ApiService.V3UsersPostExecute(r)
}

/*
V3UsersPost Create a user

Creates a user in the Cloud Controller database.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3UsersPostRequest
*/
func (a *DefaultAPIService) V3UsersPost(ctx context.Context) ApiV3UsersPostRequest {
	return ApiV3UsersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return User
func (a *DefaultAPIService) V3UsersPostExecute(r ApiV3UsersPostRequest) (*User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V3UsersPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3UsersPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3UsersPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3UsersPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
