/*
Cloud Foundry API

OpenAPI specification for the Cloud Foundry API.

API version: 3.195.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package capiclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type SidecarsAPI interface {

	/*
	V3AppsGuidSidecarsGet List sidecars for an app

	Retrieves all sidecars associated with an app.

Sidecars are additional processes that run alongside the main app process, providing
supporting functionality like proxies, monitoring agents, or log collectors.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The app GUID
	@return ApiV3AppsGuidSidecarsGetRequest
	*/
	V3AppsGuidSidecarsGet(ctx context.Context, guid string) ApiV3AppsGuidSidecarsGetRequest

	// V3AppsGuidSidecarsGetExecute executes the request
	//  @return V3AppsGuidSidecarsGet200Response
	V3AppsGuidSidecarsGetExecute(r ApiV3AppsGuidSidecarsGetRequest) (*V3AppsGuidSidecarsGet200Response, *http.Response, error)

	/*
	V3AppsGuidSidecarsPost Create a sidecar for an app

	Creates a sidecar associated with an app.

Sidecars are additional processes that run alongside the main app process.
They share the same lifecycle as the app and are restarted when the app is restarted.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The app GUID
	@return ApiV3AppsGuidSidecarsPostRequest
	*/
	V3AppsGuidSidecarsPost(ctx context.Context, guid string) ApiV3AppsGuidSidecarsPostRequest

	// V3AppsGuidSidecarsPostExecute executes the request
	//  @return Sidecar
	V3AppsGuidSidecarsPostExecute(r ApiV3AppsGuidSidecarsPostRequest) (*Sidecar, *http.Response, error)

	/*
	V3ProcessesGuidSidecarsGet List sidecars for a process

	Retrieves all sidecars associated with a specific process type.

This endpoint allows you to see which sidecars are configured to run
alongside a particular process type (e.g., web, worker).


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The process GUID
	@return ApiV3ProcessesGuidSidecarsGetRequest
	*/
	V3ProcessesGuidSidecarsGet(ctx context.Context, guid string) ApiV3ProcessesGuidSidecarsGetRequest

	// V3ProcessesGuidSidecarsGetExecute executes the request
	//  @return V3AppsGuidSidecarsGet200Response
	V3ProcessesGuidSidecarsGetExecute(r ApiV3ProcessesGuidSidecarsGetRequest) (*V3AppsGuidSidecarsGet200Response, *http.Response, error)

	/*
	V3SidecarsGuidDelete Delete a sidecar

	Permanently deletes a sidecar.

The sidecar process will be stopped and removed from the app.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The sidecar GUID
	@return ApiV3SidecarsGuidDeleteRequest
	*/
	V3SidecarsGuidDelete(ctx context.Context, guid string) ApiV3SidecarsGuidDeleteRequest

	// V3SidecarsGuidDeleteExecute executes the request
	V3SidecarsGuidDeleteExecute(r ApiV3SidecarsGuidDeleteRequest) (*http.Response, error)

	/*
	V3SidecarsGuidGet Get a sidecar

	Retrieve detailed information about a specific sidecar.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The sidecar GUID
	@return ApiV3SidecarsGuidGetRequest
	*/
	V3SidecarsGuidGet(ctx context.Context, guid string) ApiV3SidecarsGuidGetRequest

	// V3SidecarsGuidGetExecute executes the request
	//  @return Sidecar
	V3SidecarsGuidGetExecute(r ApiV3SidecarsGuidGetRequest) (*Sidecar, *http.Response, error)

	/*
	V3SidecarsGuidPatch Update a sidecar

	Updates the specified attributes of a sidecar.

Only the provided fields will be updated, all other fields will remain unchanged.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The sidecar GUID
	@return ApiV3SidecarsGuidPatchRequest
	*/
	V3SidecarsGuidPatch(ctx context.Context, guid string) ApiV3SidecarsGuidPatchRequest

	// V3SidecarsGuidPatchExecute executes the request
	//  @return Sidecar
	V3SidecarsGuidPatchExecute(r ApiV3SidecarsGuidPatchRequest) (*Sidecar, *http.Response, error)

	/*
	V3SidecarsGuidProcessesGet List processes for a sidecar

	List all processes associated with a sidecar

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The sidecar GUID
	@return ApiV3SidecarsGuidProcessesGetRequest
	*/
	V3SidecarsGuidProcessesGet(ctx context.Context, guid string) ApiV3SidecarsGuidProcessesGetRequest

	// V3SidecarsGuidProcessesGetExecute executes the request
	//  @return V3AppsGuidProcessesGet200Response
	V3SidecarsGuidProcessesGetExecute(r ApiV3SidecarsGuidProcessesGetRequest) (*V3AppsGuidProcessesGet200Response, *http.Response, error)
}

// SidecarsAPIService SidecarsAPI service
type SidecarsAPIService service

type ApiV3AppsGuidSidecarsGetRequest struct {
	ctx context.Context
	ApiService SidecarsAPI
	guid string
	page *int32
	perPage *int32
	orderBy *string
	names *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

// Page number for pagination
func (r ApiV3AppsGuidSidecarsGetRequest) Page(page int32) ApiV3AppsGuidSidecarsGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3AppsGuidSidecarsGetRequest) PerPage(perPage int32) ApiV3AppsGuidSidecarsGetRequest {
	r.perPage = &perPage
	return r
}

// Sort order for results
func (r ApiV3AppsGuidSidecarsGetRequest) OrderBy(orderBy string) ApiV3AppsGuidSidecarsGetRequest {
	r.orderBy = &orderBy
	return r
}

// Filter by sidecar names (comma-separated)
func (r ApiV3AppsGuidSidecarsGetRequest) Names(names string) ApiV3AppsGuidSidecarsGetRequest {
	r.names = &names
	return r
}

// Filter by label selector
func (r ApiV3AppsGuidSidecarsGetRequest) LabelSelector(labelSelector string) ApiV3AppsGuidSidecarsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Filter by creation time
func (r ApiV3AppsGuidSidecarsGetRequest) CreatedAts(createdAts string) ApiV3AppsGuidSidecarsGetRequest {
	r.createdAts = &createdAts
	return r
}

// Filter by update time
func (r ApiV3AppsGuidSidecarsGetRequest) UpdatedAts(updatedAts string) ApiV3AppsGuidSidecarsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3AppsGuidSidecarsGetRequest) Execute() (*V3AppsGuidSidecarsGet200Response, *http.Response, error) {
	return r.ApiService.V3AppsGuidSidecarsGetExecute(r)
}

/*
V3AppsGuidSidecarsGet List sidecars for an app

Retrieves all sidecars associated with an app.

Sidecars are additional processes that run alongside the main app process, providing
supporting functionality like proxies, monitoring agents, or log collectors.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The app GUID
 @return ApiV3AppsGuidSidecarsGetRequest
*/
func (a *SidecarsAPIService) V3AppsGuidSidecarsGet(ctx context.Context, guid string) ApiV3AppsGuidSidecarsGetRequest {
	return ApiV3AppsGuidSidecarsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidSidecarsGet200Response
func (a *SidecarsAPIService) V3AppsGuidSidecarsGetExecute(r ApiV3AppsGuidSidecarsGetRequest) (*V3AppsGuidSidecarsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidSidecarsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SidecarsAPIService.V3AppsGuidSidecarsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/sidecars"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	} else {
		var defaultValue int32 = 50
		r.perPage = &defaultValue
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	} else {
		var defaultValue string = "created_at"
		r.orderBy = &defaultValue
	}
	if r.names != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "names", r.names, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3AppsGuidSidecarsPostRequest struct {
	ctx context.Context
	ApiService SidecarsAPI
	guid string
	sidecarCreate *SidecarCreate
}

func (r ApiV3AppsGuidSidecarsPostRequest) SidecarCreate(sidecarCreate SidecarCreate) ApiV3AppsGuidSidecarsPostRequest {
	r.sidecarCreate = &sidecarCreate
	return r
}

func (r ApiV3AppsGuidSidecarsPostRequest) Execute() (*Sidecar, *http.Response, error) {
	return r.ApiService.V3AppsGuidSidecarsPostExecute(r)
}

/*
V3AppsGuidSidecarsPost Create a sidecar for an app

Creates a sidecar associated with an app.

Sidecars are additional processes that run alongside the main app process.
They share the same lifecycle as the app and are restarted when the app is restarted.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The app GUID
 @return ApiV3AppsGuidSidecarsPostRequest
*/
func (a *SidecarsAPIService) V3AppsGuidSidecarsPost(ctx context.Context, guid string) ApiV3AppsGuidSidecarsPostRequest {
	return ApiV3AppsGuidSidecarsPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Sidecar
func (a *SidecarsAPIService) V3AppsGuidSidecarsPostExecute(r ApiV3AppsGuidSidecarsPostRequest) (*Sidecar, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Sidecar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SidecarsAPIService.V3AppsGuidSidecarsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/apps/{guid}/sidecars"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sidecarCreate == nil {
		return localVarReturnValue, nil, reportError("sidecarCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sidecarCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3ProcessesGuidSidecarsGetRequest struct {
	ctx context.Context
	ApiService SidecarsAPI
	guid string
	page *int32
	perPage *int32
	orderBy *string
	names *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

// Page number for pagination
func (r ApiV3ProcessesGuidSidecarsGetRequest) Page(page int32) ApiV3ProcessesGuidSidecarsGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3ProcessesGuidSidecarsGetRequest) PerPage(perPage int32) ApiV3ProcessesGuidSidecarsGetRequest {
	r.perPage = &perPage
	return r
}

// Sort order for results
func (r ApiV3ProcessesGuidSidecarsGetRequest) OrderBy(orderBy string) ApiV3ProcessesGuidSidecarsGetRequest {
	r.orderBy = &orderBy
	return r
}

// Filter by sidecar names (comma-separated)
func (r ApiV3ProcessesGuidSidecarsGetRequest) Names(names string) ApiV3ProcessesGuidSidecarsGetRequest {
	r.names = &names
	return r
}

// Filter by label selector
func (r ApiV3ProcessesGuidSidecarsGetRequest) LabelSelector(labelSelector string) ApiV3ProcessesGuidSidecarsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Filter by creation time
func (r ApiV3ProcessesGuidSidecarsGetRequest) CreatedAts(createdAts string) ApiV3ProcessesGuidSidecarsGetRequest {
	r.createdAts = &createdAts
	return r
}

// Filter by update time
func (r ApiV3ProcessesGuidSidecarsGetRequest) UpdatedAts(updatedAts string) ApiV3ProcessesGuidSidecarsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3ProcessesGuidSidecarsGetRequest) Execute() (*V3AppsGuidSidecarsGet200Response, *http.Response, error) {
	return r.ApiService.V3ProcessesGuidSidecarsGetExecute(r)
}

/*
V3ProcessesGuidSidecarsGet List sidecars for a process

Retrieves all sidecars associated with a specific process type.

This endpoint allows you to see which sidecars are configured to run
alongside a particular process type (e.g., web, worker).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The process GUID
 @return ApiV3ProcessesGuidSidecarsGetRequest
*/
func (a *SidecarsAPIService) V3ProcessesGuidSidecarsGet(ctx context.Context, guid string) ApiV3ProcessesGuidSidecarsGetRequest {
	return ApiV3ProcessesGuidSidecarsGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidSidecarsGet200Response
func (a *SidecarsAPIService) V3ProcessesGuidSidecarsGetExecute(r ApiV3ProcessesGuidSidecarsGetRequest) (*V3AppsGuidSidecarsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidSidecarsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SidecarsAPIService.V3ProcessesGuidSidecarsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/processes/{guid}/sidecars"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	} else {
		var defaultValue int32 = 50
		r.perPage = &defaultValue
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	} else {
		var defaultValue string = "created_at"
		r.orderBy = &defaultValue
	}
	if r.names != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "names", r.names, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SidecarsGuidDeleteRequest struct {
	ctx context.Context
	ApiService SidecarsAPI
	guid string
}

func (r ApiV3SidecarsGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3SidecarsGuidDeleteExecute(r)
}

/*
V3SidecarsGuidDelete Delete a sidecar

Permanently deletes a sidecar.

The sidecar process will be stopped and removed from the app.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The sidecar GUID
 @return ApiV3SidecarsGuidDeleteRequest
*/
func (a *SidecarsAPIService) V3SidecarsGuidDelete(ctx context.Context, guid string) ApiV3SidecarsGuidDeleteRequest {
	return ApiV3SidecarsGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *SidecarsAPIService) V3SidecarsGuidDeleteExecute(r ApiV3SidecarsGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SidecarsAPIService.V3SidecarsGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/sidecars/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3SidecarsGuidGetRequest struct {
	ctx context.Context
	ApiService SidecarsAPI
	guid string
}

func (r ApiV3SidecarsGuidGetRequest) Execute() (*Sidecar, *http.Response, error) {
	return r.ApiService.V3SidecarsGuidGetExecute(r)
}

/*
V3SidecarsGuidGet Get a sidecar

Retrieve detailed information about a specific sidecar.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The sidecar GUID
 @return ApiV3SidecarsGuidGetRequest
*/
func (a *SidecarsAPIService) V3SidecarsGuidGet(ctx context.Context, guid string) ApiV3SidecarsGuidGetRequest {
	return ApiV3SidecarsGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Sidecar
func (a *SidecarsAPIService) V3SidecarsGuidGetExecute(r ApiV3SidecarsGuidGetRequest) (*Sidecar, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Sidecar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SidecarsAPIService.V3SidecarsGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/sidecars/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SidecarsGuidPatchRequest struct {
	ctx context.Context
	ApiService SidecarsAPI
	guid string
	sidecarUpdate *SidecarUpdate
}

func (r ApiV3SidecarsGuidPatchRequest) SidecarUpdate(sidecarUpdate SidecarUpdate) ApiV3SidecarsGuidPatchRequest {
	r.sidecarUpdate = &sidecarUpdate
	return r
}

func (r ApiV3SidecarsGuidPatchRequest) Execute() (*Sidecar, *http.Response, error) {
	return r.ApiService.V3SidecarsGuidPatchExecute(r)
}

/*
V3SidecarsGuidPatch Update a sidecar

Updates the specified attributes of a sidecar.

Only the provided fields will be updated, all other fields will remain unchanged.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The sidecar GUID
 @return ApiV3SidecarsGuidPatchRequest
*/
func (a *SidecarsAPIService) V3SidecarsGuidPatch(ctx context.Context, guid string) ApiV3SidecarsGuidPatchRequest {
	return ApiV3SidecarsGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Sidecar
func (a *SidecarsAPIService) V3SidecarsGuidPatchExecute(r ApiV3SidecarsGuidPatchRequest) (*Sidecar, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Sidecar
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SidecarsAPIService.V3SidecarsGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/sidecars/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sidecarUpdate == nil {
		return localVarReturnValue, nil, reportError("sidecarUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sidecarUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3SidecarsGuidProcessesGetRequest struct {
	ctx context.Context
	ApiService SidecarsAPI
	guid string
	page *int32
	perPage *int32
}

// Page number for pagination
func (r ApiV3SidecarsGuidProcessesGetRequest) Page(page int32) ApiV3SidecarsGuidProcessesGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3SidecarsGuidProcessesGetRequest) PerPage(perPage int32) ApiV3SidecarsGuidProcessesGetRequest {
	r.perPage = &perPage
	return r
}

func (r ApiV3SidecarsGuidProcessesGetRequest) Execute() (*V3AppsGuidProcessesGet200Response, *http.Response, error) {
	return r.ApiService.V3SidecarsGuidProcessesGetExecute(r)
}

/*
V3SidecarsGuidProcessesGet List processes for a sidecar

List all processes associated with a sidecar

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The sidecar GUID
 @return ApiV3SidecarsGuidProcessesGetRequest
*/
func (a *SidecarsAPIService) V3SidecarsGuidProcessesGet(ctx context.Context, guid string) ApiV3SidecarsGuidProcessesGetRequest {
	return ApiV3SidecarsGuidProcessesGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return V3AppsGuidProcessesGet200Response
func (a *SidecarsAPIService) V3SidecarsGuidProcessesGetExecute(r ApiV3SidecarsGuidProcessesGetRequest) (*V3AppsGuidProcessesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3AppsGuidProcessesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SidecarsAPIService.V3SidecarsGuidProcessesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/sidecars/{guid}/processes"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
