/*
Cloud Foundry API

OpenAPI specification for the Cloud Foundry API.

API version: 3.195.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package capiclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type BuildpacksAPI interface {

	/*
	V3BuildpacksGet List buildpacks

	Retrieve a paginated list of buildpacks. Buildpacks are used during the staging process to compile and prepare applications for runtime.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3BuildpacksGetRequest
	*/
	V3BuildpacksGet(ctx context.Context) ApiV3BuildpacksGetRequest

	// V3BuildpacksGetExecute executes the request
	//  @return V3BuildpacksGet200Response
	V3BuildpacksGetExecute(r ApiV3BuildpacksGetRequest) (*V3BuildpacksGet200Response, *http.Response, error)

	/*
	V3BuildpacksGuidDelete Delete a buildpack

	Delete a buildpack. Only admins can delete buildpacks.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the buildpack
	@return ApiV3BuildpacksGuidDeleteRequest
	*/
	V3BuildpacksGuidDelete(ctx context.Context, guid string) ApiV3BuildpacksGuidDeleteRequest

	// V3BuildpacksGuidDeleteExecute executes the request
	V3BuildpacksGuidDeleteExecute(r ApiV3BuildpacksGuidDeleteRequest) (*http.Response, error)

	/*
	V3BuildpacksGuidGet Get a buildpack

	Retrieve details of a specific buildpack

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the buildpack
	@return ApiV3BuildpacksGuidGetRequest
	*/
	V3BuildpacksGuidGet(ctx context.Context, guid string) ApiV3BuildpacksGuidGetRequest

	// V3BuildpacksGuidGetExecute executes the request
	//  @return Buildpack
	V3BuildpacksGuidGetExecute(r ApiV3BuildpacksGuidGetRequest) (*Buildpack, *http.Response, error)

	/*
	V3BuildpacksGuidPatch Update a buildpack

	Update an existing buildpack. Only admins can update buildpacks.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the buildpack
	@return ApiV3BuildpacksGuidPatchRequest
	*/
	V3BuildpacksGuidPatch(ctx context.Context, guid string) ApiV3BuildpacksGuidPatchRequest

	// V3BuildpacksGuidPatchExecute executes the request
	//  @return Buildpack
	V3BuildpacksGuidPatchExecute(r ApiV3BuildpacksGuidPatchRequest) (*Buildpack, *http.Response, error)

	/*
	V3BuildpacksGuidUploadPost Upload buildpack bits

	Upload a zip file containing a buildpack. For traditional buildpacks, upload a zip of the buildpack directory. For Cloud Native Buildpacks (experimental), upload the buildpack image or reference.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the buildpack
	@return ApiV3BuildpacksGuidUploadPostRequest
	*/
	V3BuildpacksGuidUploadPost(ctx context.Context, guid string) ApiV3BuildpacksGuidUploadPostRequest

	// V3BuildpacksGuidUploadPostExecute executes the request
	//  @return Job
	V3BuildpacksGuidUploadPostExecute(r ApiV3BuildpacksGuidUploadPostRequest) (*Job, *http.Response, error)

	/*
	V3BuildpacksPost Create a buildpack

	Create a new buildpack. Only admins can create buildpacks.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3BuildpacksPostRequest
	*/
	V3BuildpacksPost(ctx context.Context) ApiV3BuildpacksPostRequest

	// V3BuildpacksPostExecute executes the request
	//  @return Buildpack
	V3BuildpacksPostExecute(r ApiV3BuildpacksPostRequest) (*Buildpack, *http.Response, error)
}

// BuildpacksAPIService BuildpacksAPI service
type BuildpacksAPIService service

type ApiV3BuildpacksGetRequest struct {
	ctx context.Context
	ApiService BuildpacksAPI
	page *int32
	perPage *int32
	orderBy *string
	names *string
	stacks *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

// Page number for pagination
func (r ApiV3BuildpacksGetRequest) Page(page int32) ApiV3BuildpacksGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3BuildpacksGetRequest) PerPage(perPage int32) ApiV3BuildpacksGetRequest {
	r.perPage = &perPage
	return r
}

// Field by which to order results
func (r ApiV3BuildpacksGetRequest) OrderBy(orderBy string) ApiV3BuildpacksGetRequest {
	r.orderBy = &orderBy
	return r
}

// Filter by buildpack names (comma-separated)
func (r ApiV3BuildpacksGetRequest) Names(names string) ApiV3BuildpacksGetRequest {
	r.names = &names
	return r
}

// Filter by stack names (comma-separated)
func (r ApiV3BuildpacksGetRequest) Stacks(stacks string) ApiV3BuildpacksGetRequest {
	r.stacks = &stacks
	return r
}

// Filter by label selector
func (r ApiV3BuildpacksGetRequest) LabelSelector(labelSelector string) ApiV3BuildpacksGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Filter by creation timestamps
func (r ApiV3BuildpacksGetRequest) CreatedAts(createdAts string) ApiV3BuildpacksGetRequest {
	r.createdAts = &createdAts
	return r
}

// Filter by update timestamps
func (r ApiV3BuildpacksGetRequest) UpdatedAts(updatedAts string) ApiV3BuildpacksGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3BuildpacksGetRequest) Execute() (*V3BuildpacksGet200Response, *http.Response, error) {
	return r.ApiService.V3BuildpacksGetExecute(r)
}

/*
V3BuildpacksGet List buildpacks

Retrieve a paginated list of buildpacks. Buildpacks are used during the staging process to compile and prepare applications for runtime.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3BuildpacksGetRequest
*/
func (a *BuildpacksAPIService) V3BuildpacksGet(ctx context.Context) ApiV3BuildpacksGetRequest {
	return ApiV3BuildpacksGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3BuildpacksGet200Response
func (a *BuildpacksAPIService) V3BuildpacksGetExecute(r ApiV3BuildpacksGetRequest) (*V3BuildpacksGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3BuildpacksGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildpacksAPIService.V3BuildpacksGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/buildpacks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.names != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "names", r.names, "form", "")
	}
	if r.stacks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stacks", r.stacks, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3BuildpacksGuidDeleteRequest struct {
	ctx context.Context
	ApiService BuildpacksAPI
	guid string
}

func (r ApiV3BuildpacksGuidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V3BuildpacksGuidDeleteExecute(r)
}

/*
V3BuildpacksGuidDelete Delete a buildpack

Delete a buildpack. Only admins can delete buildpacks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the buildpack
 @return ApiV3BuildpacksGuidDeleteRequest
*/
func (a *BuildpacksAPIService) V3BuildpacksGuidDelete(ctx context.Context, guid string) ApiV3BuildpacksGuidDeleteRequest {
	return ApiV3BuildpacksGuidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
func (a *BuildpacksAPIService) V3BuildpacksGuidDeleteExecute(r ApiV3BuildpacksGuidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildpacksAPIService.V3BuildpacksGuidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/buildpacks/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV3BuildpacksGuidGetRequest struct {
	ctx context.Context
	ApiService BuildpacksAPI
	guid string
}

func (r ApiV3BuildpacksGuidGetRequest) Execute() (*Buildpack, *http.Response, error) {
	return r.ApiService.V3BuildpacksGuidGetExecute(r)
}

/*
V3BuildpacksGuidGet Get a buildpack

Retrieve details of a specific buildpack

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the buildpack
 @return ApiV3BuildpacksGuidGetRequest
*/
func (a *BuildpacksAPIService) V3BuildpacksGuidGet(ctx context.Context, guid string) ApiV3BuildpacksGuidGetRequest {
	return ApiV3BuildpacksGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Buildpack
func (a *BuildpacksAPIService) V3BuildpacksGuidGetExecute(r ApiV3BuildpacksGuidGetRequest) (*Buildpack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Buildpack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildpacksAPIService.V3BuildpacksGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/buildpacks/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3BuildpacksGuidPatchRequest struct {
	ctx context.Context
	ApiService BuildpacksAPI
	guid string
	v3BuildpacksGuidPatchRequest *V3BuildpacksGuidPatchRequest
}

func (r ApiV3BuildpacksGuidPatchRequest) V3BuildpacksGuidPatchRequest(v3BuildpacksGuidPatchRequest V3BuildpacksGuidPatchRequest) ApiV3BuildpacksGuidPatchRequest {
	r.v3BuildpacksGuidPatchRequest = &v3BuildpacksGuidPatchRequest
	return r
}

func (r ApiV3BuildpacksGuidPatchRequest) Execute() (*Buildpack, *http.Response, error) {
	return r.ApiService.V3BuildpacksGuidPatchExecute(r)
}

/*
V3BuildpacksGuidPatch Update a buildpack

Update an existing buildpack. Only admins can update buildpacks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the buildpack
 @return ApiV3BuildpacksGuidPatchRequest
*/
func (a *BuildpacksAPIService) V3BuildpacksGuidPatch(ctx context.Context, guid string) ApiV3BuildpacksGuidPatchRequest {
	return ApiV3BuildpacksGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Buildpack
func (a *BuildpacksAPIService) V3BuildpacksGuidPatchExecute(r ApiV3BuildpacksGuidPatchRequest) (*Buildpack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Buildpack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildpacksAPIService.V3BuildpacksGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/buildpacks/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3BuildpacksGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3BuildpacksGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3BuildpacksGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3BuildpacksGuidUploadPostRequest struct {
	ctx context.Context
	ApiService BuildpacksAPI
	guid string
	v3BuildpacksGuidUploadPostRequest *V3BuildpacksGuidUploadPostRequest
}

func (r ApiV3BuildpacksGuidUploadPostRequest) V3BuildpacksGuidUploadPostRequest(v3BuildpacksGuidUploadPostRequest V3BuildpacksGuidUploadPostRequest) ApiV3BuildpacksGuidUploadPostRequest {
	r.v3BuildpacksGuidUploadPostRequest = &v3BuildpacksGuidUploadPostRequest
	return r
}

func (r ApiV3BuildpacksGuidUploadPostRequest) Execute() (*Job, *http.Response, error) {
	return r.ApiService.V3BuildpacksGuidUploadPostExecute(r)
}

/*
V3BuildpacksGuidUploadPost Upload buildpack bits

Upload a zip file containing a buildpack. For traditional buildpacks, upload a zip of the buildpack directory. For Cloud Native Buildpacks (experimental), upload the buildpack image or reference.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the buildpack
 @return ApiV3BuildpacksGuidUploadPostRequest
*/
func (a *BuildpacksAPIService) V3BuildpacksGuidUploadPost(ctx context.Context, guid string) ApiV3BuildpacksGuidUploadPostRequest {
	return ApiV3BuildpacksGuidUploadPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Job
func (a *BuildpacksAPIService) V3BuildpacksGuidUploadPostExecute(r ApiV3BuildpacksGuidUploadPostRequest) (*Job, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Job
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildpacksAPIService.V3BuildpacksGuidUploadPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/buildpacks/{guid}/upload"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3BuildpacksGuidUploadPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3BuildpacksGuidUploadPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3BuildpacksGuidUploadPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3BuildpacksPostRequest struct {
	ctx context.Context
	ApiService BuildpacksAPI
	v3BuildpacksPostRequest *V3BuildpacksPostRequest
}

func (r ApiV3BuildpacksPostRequest) V3BuildpacksPostRequest(v3BuildpacksPostRequest V3BuildpacksPostRequest) ApiV3BuildpacksPostRequest {
	r.v3BuildpacksPostRequest = &v3BuildpacksPostRequest
	return r
}

func (r ApiV3BuildpacksPostRequest) Execute() (*Buildpack, *http.Response, error) {
	return r.ApiService.V3BuildpacksPostExecute(r)
}

/*
V3BuildpacksPost Create a buildpack

Create a new buildpack. Only admins can create buildpacks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3BuildpacksPostRequest
*/
func (a *BuildpacksAPIService) V3BuildpacksPost(ctx context.Context) ApiV3BuildpacksPostRequest {
	return ApiV3BuildpacksPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Buildpack
func (a *BuildpacksAPIService) V3BuildpacksPostExecute(r ApiV3BuildpacksPostRequest) (*Buildpack, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Buildpack
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildpacksAPIService.V3BuildpacksPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/buildpacks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3BuildpacksPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3BuildpacksPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3BuildpacksPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
