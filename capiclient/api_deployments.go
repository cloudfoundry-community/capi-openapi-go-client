/*
Cloud Foundry API

OpenAPI specification for the Cloud Foundry API.

API version: 3.195.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package capiclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type DeploymentsAPI interface {

	/*
	V3DeploymentsGet List deployments

	Retrieve a paginated list of deployments. Deployments represent updates to applications with zero downtime.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3DeploymentsGetRequest
	*/
	V3DeploymentsGet(ctx context.Context) ApiV3DeploymentsGetRequest

	// V3DeploymentsGetExecute executes the request
	//  @return V3DeploymentsGet200Response
	V3DeploymentsGetExecute(r ApiV3DeploymentsGetRequest) (*V3DeploymentsGet200Response, *http.Response, error)

	/*
	V3DeploymentsGuidActionsCancelPost Cancel a deployment

	Cancel an active deployment. This will stop the deployment process and roll back to the previous version.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the deployment
	@return ApiV3DeploymentsGuidActionsCancelPostRequest
	*/
	V3DeploymentsGuidActionsCancelPost(ctx context.Context, guid string) ApiV3DeploymentsGuidActionsCancelPostRequest

	// V3DeploymentsGuidActionsCancelPostExecute executes the request
	//  @return Deployment
	V3DeploymentsGuidActionsCancelPostExecute(r ApiV3DeploymentsGuidActionsCancelPostRequest) (*Deployment, *http.Response, error)

	/*
	V3DeploymentsGuidActionsContinuePost Continue a deployment

	Continue a paused deployment (e.g., after canary phase)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the deployment
	@return ApiV3DeploymentsGuidActionsContinuePostRequest
	*/
	V3DeploymentsGuidActionsContinuePost(ctx context.Context, guid string) ApiV3DeploymentsGuidActionsContinuePostRequest

	// V3DeploymentsGuidActionsContinuePostExecute executes the request
	//  @return Deployment
	V3DeploymentsGuidActionsContinuePostExecute(r ApiV3DeploymentsGuidActionsContinuePostRequest) (*Deployment, *http.Response, error)

	/*
	V3DeploymentsGuidGet Get a deployment

	Retrieve details of a specific deployment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the deployment
	@return ApiV3DeploymentsGuidGetRequest
	*/
	V3DeploymentsGuidGet(ctx context.Context, guid string) ApiV3DeploymentsGuidGetRequest

	// V3DeploymentsGuidGetExecute executes the request
	//  @return Deployment
	V3DeploymentsGuidGetExecute(r ApiV3DeploymentsGuidGetRequest) (*Deployment, *http.Response, error)

	/*
	V3DeploymentsGuidPatch Update a deployment

	Update metadata for a deployment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param guid The GUID of the deployment
	@return ApiV3DeploymentsGuidPatchRequest
	*/
	V3DeploymentsGuidPatch(ctx context.Context, guid string) ApiV3DeploymentsGuidPatchRequest

	// V3DeploymentsGuidPatchExecute executes the request
	//  @return Deployment
	V3DeploymentsGuidPatchExecute(r ApiV3DeploymentsGuidPatchRequest) (*Deployment, *http.Response, error)

	/*
	V3DeploymentsPost Create a deployment

	Create a new deployment for an app. This will deploy a new droplet and/or update the app's configuration with zero downtime.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3DeploymentsPostRequest
	*/
	V3DeploymentsPost(ctx context.Context) ApiV3DeploymentsPostRequest

	// V3DeploymentsPostExecute executes the request
	//  @return Deployment
	V3DeploymentsPostExecute(r ApiV3DeploymentsPostRequest) (*Deployment, *http.Response, error)
}

// DeploymentsAPIService DeploymentsAPI service
type DeploymentsAPIService service

type ApiV3DeploymentsGetRequest struct {
	ctx context.Context
	ApiService DeploymentsAPI
	page *int32
	perPage *int32
	orderBy *string
	states *string
	appGuids *string
	statusReasons *string
	statusValues *string
	labelSelector *string
	createdAts *string
	updatedAts *string
}

// Page number for pagination
func (r ApiV3DeploymentsGetRequest) Page(page int32) ApiV3DeploymentsGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3DeploymentsGetRequest) PerPage(perPage int32) ApiV3DeploymentsGetRequest {
	r.perPage = &perPage
	return r
}

// Field by which to order results
func (r ApiV3DeploymentsGetRequest) OrderBy(orderBy string) ApiV3DeploymentsGetRequest {
	r.orderBy = &orderBy
	return r
}

// Filter by deployment states (comma-separated)
func (r ApiV3DeploymentsGetRequest) States(states string) ApiV3DeploymentsGetRequest {
	r.states = &states
	return r
}

// Filter by app GUIDs (comma-separated)
func (r ApiV3DeploymentsGetRequest) AppGuids(appGuids string) ApiV3DeploymentsGetRequest {
	r.appGuids = &appGuids
	return r
}

// Filter by status reasons (comma-separated)
func (r ApiV3DeploymentsGetRequest) StatusReasons(statusReasons string) ApiV3DeploymentsGetRequest {
	r.statusReasons = &statusReasons
	return r
}

// Filter by status values (comma-separated)
func (r ApiV3DeploymentsGetRequest) StatusValues(statusValues string) ApiV3DeploymentsGetRequest {
	r.statusValues = &statusValues
	return r
}

// Filter by label selector
func (r ApiV3DeploymentsGetRequest) LabelSelector(labelSelector string) ApiV3DeploymentsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

// Filter by creation timestamps
func (r ApiV3DeploymentsGetRequest) CreatedAts(createdAts string) ApiV3DeploymentsGetRequest {
	r.createdAts = &createdAts
	return r
}

// Filter by update timestamps
func (r ApiV3DeploymentsGetRequest) UpdatedAts(updatedAts string) ApiV3DeploymentsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

func (r ApiV3DeploymentsGetRequest) Execute() (*V3DeploymentsGet200Response, *http.Response, error) {
	return r.ApiService.V3DeploymentsGetExecute(r)
}

/*
V3DeploymentsGet List deployments

Retrieve a paginated list of deployments. Deployments represent updates to applications with zero downtime.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3DeploymentsGetRequest
*/
func (a *DeploymentsAPIService) V3DeploymentsGet(ctx context.Context) ApiV3DeploymentsGetRequest {
	return ApiV3DeploymentsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3DeploymentsGet200Response
func (a *DeploymentsAPIService) V3DeploymentsGetExecute(r ApiV3DeploymentsGetRequest) (*V3DeploymentsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3DeploymentsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsAPIService.V3DeploymentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/deployments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.states != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "states", r.states, "form", "")
	}
	if r.appGuids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "app_guids", r.appGuids, "form", "")
	}
	if r.statusReasons != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status_reasons", r.statusReasons, "form", "")
	}
	if r.statusValues != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status_values", r.statusValues, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	if r.createdAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_ats", r.createdAts, "form", "")
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3DeploymentsGuidActionsCancelPostRequest struct {
	ctx context.Context
	ApiService DeploymentsAPI
	guid string
}

func (r ApiV3DeploymentsGuidActionsCancelPostRequest) Execute() (*Deployment, *http.Response, error) {
	return r.ApiService.V3DeploymentsGuidActionsCancelPostExecute(r)
}

/*
V3DeploymentsGuidActionsCancelPost Cancel a deployment

Cancel an active deployment. This will stop the deployment process and roll back to the previous version.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the deployment
 @return ApiV3DeploymentsGuidActionsCancelPostRequest
*/
func (a *DeploymentsAPIService) V3DeploymentsGuidActionsCancelPost(ctx context.Context, guid string) ApiV3DeploymentsGuidActionsCancelPostRequest {
	return ApiV3DeploymentsGuidActionsCancelPostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Deployment
func (a *DeploymentsAPIService) V3DeploymentsGuidActionsCancelPostExecute(r ApiV3DeploymentsGuidActionsCancelPostRequest) (*Deployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Deployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsAPIService.V3DeploymentsGuidActionsCancelPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/deployments/{guid}/actions/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3DeploymentsGuidActionsContinuePostRequest struct {
	ctx context.Context
	ApiService DeploymentsAPI
	guid string
}

func (r ApiV3DeploymentsGuidActionsContinuePostRequest) Execute() (*Deployment, *http.Response, error) {
	return r.ApiService.V3DeploymentsGuidActionsContinuePostExecute(r)
}

/*
V3DeploymentsGuidActionsContinuePost Continue a deployment

Continue a paused deployment (e.g., after canary phase)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the deployment
 @return ApiV3DeploymentsGuidActionsContinuePostRequest
*/
func (a *DeploymentsAPIService) V3DeploymentsGuidActionsContinuePost(ctx context.Context, guid string) ApiV3DeploymentsGuidActionsContinuePostRequest {
	return ApiV3DeploymentsGuidActionsContinuePostRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Deployment
func (a *DeploymentsAPIService) V3DeploymentsGuidActionsContinuePostExecute(r ApiV3DeploymentsGuidActionsContinuePostRequest) (*Deployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Deployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsAPIService.V3DeploymentsGuidActionsContinuePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/deployments/{guid}/actions/continue"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3DeploymentsGuidGetRequest struct {
	ctx context.Context
	ApiService DeploymentsAPI
	guid string
}

func (r ApiV3DeploymentsGuidGetRequest) Execute() (*Deployment, *http.Response, error) {
	return r.ApiService.V3DeploymentsGuidGetExecute(r)
}

/*
V3DeploymentsGuidGet Get a deployment

Retrieve details of a specific deployment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the deployment
 @return ApiV3DeploymentsGuidGetRequest
*/
func (a *DeploymentsAPIService) V3DeploymentsGuidGet(ctx context.Context, guid string) ApiV3DeploymentsGuidGetRequest {
	return ApiV3DeploymentsGuidGetRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Deployment
func (a *DeploymentsAPIService) V3DeploymentsGuidGetExecute(r ApiV3DeploymentsGuidGetRequest) (*Deployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Deployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsAPIService.V3DeploymentsGuidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/deployments/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3DeploymentsGuidPatchRequest struct {
	ctx context.Context
	ApiService DeploymentsAPI
	guid string
	v3DeploymentsGuidPatchRequest *V3DeploymentsGuidPatchRequest
}

func (r ApiV3DeploymentsGuidPatchRequest) V3DeploymentsGuidPatchRequest(v3DeploymentsGuidPatchRequest V3DeploymentsGuidPatchRequest) ApiV3DeploymentsGuidPatchRequest {
	r.v3DeploymentsGuidPatchRequest = &v3DeploymentsGuidPatchRequest
	return r
}

func (r ApiV3DeploymentsGuidPatchRequest) Execute() (*Deployment, *http.Response, error) {
	return r.ApiService.V3DeploymentsGuidPatchExecute(r)
}

/*
V3DeploymentsGuidPatch Update a deployment

Update metadata for a deployment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param guid The GUID of the deployment
 @return ApiV3DeploymentsGuidPatchRequest
*/
func (a *DeploymentsAPIService) V3DeploymentsGuidPatch(ctx context.Context, guid string) ApiV3DeploymentsGuidPatchRequest {
	return ApiV3DeploymentsGuidPatchRequest{
		ApiService: a,
		ctx: ctx,
		guid: guid,
	}
}

// Execute executes the request
//  @return Deployment
func (a *DeploymentsAPIService) V3DeploymentsGuidPatchExecute(r ApiV3DeploymentsGuidPatchRequest) (*Deployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Deployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsAPIService.V3DeploymentsGuidPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/deployments/{guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"guid"+"}", url.PathEscape(parameterValueToString(r.guid, "guid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3DeploymentsGuidPatchRequest == nil {
		return localVarReturnValue, nil, reportError("v3DeploymentsGuidPatchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3DeploymentsGuidPatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3DeploymentsPostRequest struct {
	ctx context.Context
	ApiService DeploymentsAPI
	v3DeploymentsPostRequest *V3DeploymentsPostRequest
}

func (r ApiV3DeploymentsPostRequest) V3DeploymentsPostRequest(v3DeploymentsPostRequest V3DeploymentsPostRequest) ApiV3DeploymentsPostRequest {
	r.v3DeploymentsPostRequest = &v3DeploymentsPostRequest
	return r
}

func (r ApiV3DeploymentsPostRequest) Execute() (*Deployment, *http.Response, error) {
	return r.ApiService.V3DeploymentsPostExecute(r)
}

/*
V3DeploymentsPost Create a deployment

Create a new deployment for an app. This will deploy a new droplet and/or update the app's configuration with zero downtime.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3DeploymentsPostRequest
*/
func (a *DeploymentsAPIService) V3DeploymentsPost(ctx context.Context) ApiV3DeploymentsPostRequest {
	return ApiV3DeploymentsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Deployment
func (a *DeploymentsAPIService) V3DeploymentsPostExecute(r ApiV3DeploymentsPostRequest) (*Deployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Deployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentsAPIService.V3DeploymentsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/deployments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v3DeploymentsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v3DeploymentsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v3DeploymentsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Errors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
