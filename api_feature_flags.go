/*
Cloud Foundry API

OpenAPI specification for the Cloud Foundry API.

API version: 3.195.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package capiclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type FeatureFlagsAPI interface {

	/*
	V3FeatureFlagsGet List feature flags

	Retrieve all feature flags.

Feature flags are used to enable or disable specific functionality in Cloud Foundry.
They allow administrators to control the availability of features across the platform.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV3FeatureFlagsGetRequest
	*/
	V3FeatureFlagsGet(ctx context.Context) ApiV3FeatureFlagsGetRequest

	// V3FeatureFlagsGetExecute executes the request
	//  @return V3FeatureFlagsGet200Response
	V3FeatureFlagsGetExecute(r ApiV3FeatureFlagsGetRequest) (*V3FeatureFlagsGet200Response, *http.Response, error)

	/*
	V3FeatureFlagsNameGet Get a feature flag

	Retrieve detailed information about a specific feature flag.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name The name of the feature flag
	@return ApiV3FeatureFlagsNameGetRequest
	*/
	V3FeatureFlagsNameGet(ctx context.Context, name string) ApiV3FeatureFlagsNameGetRequest

	// V3FeatureFlagsNameGetExecute executes the request
	//  @return FeatureFlag
	V3FeatureFlagsNameGetExecute(r ApiV3FeatureFlagsNameGetRequest) (*FeatureFlag, *http.Response, error)

	/*
	V3FeatureFlagsNamePatch Update a feature flag

	Update the enabled state or custom error message of a feature flag.

Only administrators can modify feature flags.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name The name of the feature flag
	@return ApiV3FeatureFlagsNamePatchRequest
	*/
	V3FeatureFlagsNamePatch(ctx context.Context, name string) ApiV3FeatureFlagsNamePatchRequest

	// V3FeatureFlagsNamePatchExecute executes the request
	//  @return FeatureFlag
	V3FeatureFlagsNamePatchExecute(r ApiV3FeatureFlagsNamePatchRequest) (*FeatureFlag, *http.Response, error)
}

// FeatureFlagsAPIService FeatureFlagsAPI service
type FeatureFlagsAPIService service

type ApiV3FeatureFlagsGetRequest struct {
	ctx context.Context
	ApiService FeatureFlagsAPI
	page *int32
	perPage *int32
	orderBy *string
	updatedAts *string
	names *string
	labelSelector *string
}

// Page to display
func (r ApiV3FeatureFlagsGetRequest) Page(page int32) ApiV3FeatureFlagsGetRequest {
	r.page = &page
	return r
}

// Number of results per page
func (r ApiV3FeatureFlagsGetRequest) PerPage(perPage int32) ApiV3FeatureFlagsGetRequest {
	r.perPage = &perPage
	return r
}

// Value to sort by
func (r ApiV3FeatureFlagsGetRequest) OrderBy(orderBy string) ApiV3FeatureFlagsGetRequest {
	r.orderBy = &orderBy
	return r
}

// Filter by update time
func (r ApiV3FeatureFlagsGetRequest) UpdatedAts(updatedAts string) ApiV3FeatureFlagsGetRequest {
	r.updatedAts = &updatedAts
	return r
}

// Comma-delimited list of feature flag names to filter by
func (r ApiV3FeatureFlagsGetRequest) Names(names string) ApiV3FeatureFlagsGetRequest {
	r.names = &names
	return r
}

// Filter by label selector
func (r ApiV3FeatureFlagsGetRequest) LabelSelector(labelSelector string) ApiV3FeatureFlagsGetRequest {
	r.labelSelector = &labelSelector
	return r
}

func (r ApiV3FeatureFlagsGetRequest) Execute() (*V3FeatureFlagsGet200Response, *http.Response, error) {
	return r.ApiService.V3FeatureFlagsGetExecute(r)
}

/*
V3FeatureFlagsGet List feature flags

Retrieve all feature flags.

Feature flags are used to enable or disable specific functionality in Cloud Foundry.
They allow administrators to control the availability of features across the platform.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV3FeatureFlagsGetRequest
*/
func (a *FeatureFlagsAPIService) V3FeatureFlagsGet(ctx context.Context) ApiV3FeatureFlagsGetRequest {
	return ApiV3FeatureFlagsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V3FeatureFlagsGet200Response
func (a *FeatureFlagsAPIService) V3FeatureFlagsGetExecute(r ApiV3FeatureFlagsGetRequest) (*V3FeatureFlagsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V3FeatureFlagsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeatureFlagsAPIService.V3FeatureFlagsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/feature_flags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "form", "")
	} else {
		var defaultValue int32 = 50
		r.perPage = &defaultValue
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	} else {
		var defaultValue string = "name"
		r.orderBy = &defaultValue
	}
	if r.updatedAts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_ats", r.updatedAts, "form", "")
	}
	if r.names != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "names", r.names, "form", "")
	}
	if r.labelSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label_selector", r.labelSelector, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3FeatureFlagsNameGetRequest struct {
	ctx context.Context
	ApiService FeatureFlagsAPI
	name string
}

func (r ApiV3FeatureFlagsNameGetRequest) Execute() (*FeatureFlag, *http.Response, error) {
	return r.ApiService.V3FeatureFlagsNameGetExecute(r)
}

/*
V3FeatureFlagsNameGet Get a feature flag

Retrieve detailed information about a specific feature flag.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the feature flag
 @return ApiV3FeatureFlagsNameGetRequest
*/
func (a *FeatureFlagsAPIService) V3FeatureFlagsNameGet(ctx context.Context, name string) ApiV3FeatureFlagsNameGetRequest {
	return ApiV3FeatureFlagsNameGetRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return FeatureFlag
func (a *FeatureFlagsAPIService) V3FeatureFlagsNameGetExecute(r ApiV3FeatureFlagsNameGetRequest) (*FeatureFlag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FeatureFlag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeatureFlagsAPIService.V3FeatureFlagsNameGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/feature_flags/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3FeatureFlagsNamePatchRequest struct {
	ctx context.Context
	ApiService FeatureFlagsAPI
	name string
	featureFlagUpdate *FeatureFlagUpdate
}

func (r ApiV3FeatureFlagsNamePatchRequest) FeatureFlagUpdate(featureFlagUpdate FeatureFlagUpdate) ApiV3FeatureFlagsNamePatchRequest {
	r.featureFlagUpdate = &featureFlagUpdate
	return r
}

func (r ApiV3FeatureFlagsNamePatchRequest) Execute() (*FeatureFlag, *http.Response, error) {
	return r.ApiService.V3FeatureFlagsNamePatchExecute(r)
}

/*
V3FeatureFlagsNamePatch Update a feature flag

Update the enabled state or custom error message of a feature flag.

Only administrators can modify feature flags.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the feature flag
 @return ApiV3FeatureFlagsNamePatchRequest
*/
func (a *FeatureFlagsAPIService) V3FeatureFlagsNamePatch(ctx context.Context, name string) ApiV3FeatureFlagsNamePatchRequest {
	return ApiV3FeatureFlagsNamePatchRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return FeatureFlag
func (a *FeatureFlagsAPIService) V3FeatureFlagsNamePatchExecute(r ApiV3FeatureFlagsNamePatchRequest) (*FeatureFlag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FeatureFlag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeatureFlagsAPIService.V3FeatureFlagsNamePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/feature_flags/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.featureFlagUpdate == nil {
		return localVarReturnValue, nil, reportError("featureFlagUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.featureFlagUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
