/*
Cloud Foundry API

OpenAPI specification for the Cloud Foundry API.

API version: 3.195.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package capiclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type EnvironmentVariableGroupsAPI interface {

	/*
	V3EnvironmentVariableGroupsNameGet Get an environment variable group

	Retrieve a specific environment variable group.

Environment variable groups are system-wide variables that are injected into
all running or staging app containers. The 'running' group is injected into
all running apps, while the 'staging' group is injected during the staging process.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name The name of the environment variable group
	@return ApiV3EnvironmentVariableGroupsNameGetRequest
	*/
	V3EnvironmentVariableGroupsNameGet(ctx context.Context, name string) ApiV3EnvironmentVariableGroupsNameGetRequest

	// V3EnvironmentVariableGroupsNameGetExecute executes the request
	//  @return EnvironmentVariableGroup
	V3EnvironmentVariableGroupsNameGetExecute(r ApiV3EnvironmentVariableGroupsNameGetRequest) (*EnvironmentVariableGroup, *http.Response, error)

	/*
	V3EnvironmentVariableGroupsNamePatch Update environment variable group

	Update the environment variable group.

The variables given in the request will be merged with the existing environment
variable group. Any requested variables with a value of null will be removed
from the group.

Restrictions:
- Environment variable names may not start with VCAP_
- PORT is not a valid environment variable name
- CF_ prefixed variables are reserved for system use


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name The name of the environment variable group
	@return ApiV3EnvironmentVariableGroupsNamePatchRequest
	*/
	V3EnvironmentVariableGroupsNamePatch(ctx context.Context, name string) ApiV3EnvironmentVariableGroupsNamePatchRequest

	// V3EnvironmentVariableGroupsNamePatchExecute executes the request
	//  @return EnvironmentVariableGroup
	V3EnvironmentVariableGroupsNamePatchExecute(r ApiV3EnvironmentVariableGroupsNamePatchRequest) (*EnvironmentVariableGroup, *http.Response, error)
}

// EnvironmentVariableGroupsAPIService EnvironmentVariableGroupsAPI service
type EnvironmentVariableGroupsAPIService service

type ApiV3EnvironmentVariableGroupsNameGetRequest struct {
	ctx context.Context
	ApiService EnvironmentVariableGroupsAPI
	name string
}

func (r ApiV3EnvironmentVariableGroupsNameGetRequest) Execute() (*EnvironmentVariableGroup, *http.Response, error) {
	return r.ApiService.V3EnvironmentVariableGroupsNameGetExecute(r)
}

/*
V3EnvironmentVariableGroupsNameGet Get an environment variable group

Retrieve a specific environment variable group.

Environment variable groups are system-wide variables that are injected into
all running or staging app containers. The 'running' group is injected into
all running apps, while the 'staging' group is injected during the staging process.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the environment variable group
 @return ApiV3EnvironmentVariableGroupsNameGetRequest
*/
func (a *EnvironmentVariableGroupsAPIService) V3EnvironmentVariableGroupsNameGet(ctx context.Context, name string) ApiV3EnvironmentVariableGroupsNameGetRequest {
	return ApiV3EnvironmentVariableGroupsNameGetRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return EnvironmentVariableGroup
func (a *EnvironmentVariableGroupsAPIService) V3EnvironmentVariableGroupsNameGetExecute(r ApiV3EnvironmentVariableGroupsNameGetRequest) (*EnvironmentVariableGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvironmentVariableGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentVariableGroupsAPIService.V3EnvironmentVariableGroupsNameGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/environment_variable_groups/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV3EnvironmentVariableGroupsNamePatchRequest struct {
	ctx context.Context
	ApiService EnvironmentVariableGroupsAPI
	name string
	environmentVariableGroupUpdate *EnvironmentVariableGroupUpdate
}

func (r ApiV3EnvironmentVariableGroupsNamePatchRequest) EnvironmentVariableGroupUpdate(environmentVariableGroupUpdate EnvironmentVariableGroupUpdate) ApiV3EnvironmentVariableGroupsNamePatchRequest {
	r.environmentVariableGroupUpdate = &environmentVariableGroupUpdate
	return r
}

func (r ApiV3EnvironmentVariableGroupsNamePatchRequest) Execute() (*EnvironmentVariableGroup, *http.Response, error) {
	return r.ApiService.V3EnvironmentVariableGroupsNamePatchExecute(r)
}

/*
V3EnvironmentVariableGroupsNamePatch Update environment variable group

Update the environment variable group.

The variables given in the request will be merged with the existing environment
variable group. Any requested variables with a value of null will be removed
from the group.

Restrictions:
- Environment variable names may not start with VCAP_
- PORT is not a valid environment variable name
- CF_ prefixed variables are reserved for system use


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the environment variable group
 @return ApiV3EnvironmentVariableGroupsNamePatchRequest
*/
func (a *EnvironmentVariableGroupsAPIService) V3EnvironmentVariableGroupsNamePatch(ctx context.Context, name string) ApiV3EnvironmentVariableGroupsNamePatchRequest {
	return ApiV3EnvironmentVariableGroupsNamePatchRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return EnvironmentVariableGroup
func (a *EnvironmentVariableGroupsAPIService) V3EnvironmentVariableGroupsNamePatchExecute(r ApiV3EnvironmentVariableGroupsNamePatchRequest) (*EnvironmentVariableGroup, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnvironmentVariableGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentVariableGroupsAPIService.V3EnvironmentVariableGroupsNamePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/environment_variable_groups/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.environmentVariableGroupUpdate == nil {
		return localVarReturnValue, nil, reportError("environmentVariableGroupUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.environmentVariableGroupUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
